# 数据存储实现

## 1. 数据存储核心

### 1.1 数据存储架构

```rust
use std::collections::HashMap;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};

// 数据存储系统
#[derive(Debug, Clone)]
pub struct DataStorageSystem {
    pub storage_manager: StorageManager,
    pub cache_manager: CacheManager,
    pub backup_manager: BackupManager,
    pub replication_manager: ReplicationManager,
    pub data_migrator: DataMigrator,
}

impl DataStorageSystem {
    pub fn new() -> Self {
        Self {
            storage_manager: StorageManager::new(),
            cache_manager: CacheManager::new(),
            backup_manager: BackupManager::new(),
            replication_manager: ReplicationManager::new(),
            data_migrator: DataMigrator::new(),
        }
    }

    // 初始化数据存储系统
    pub async fn initialize(
        &self,
        config: &DataStorageConfig,
    ) -> Result<(), StorageError> {
        // 初始化存储管理器
        self.storage_manager.initialize(&config.storage).await?;
        
        // 初始化缓存管理器
        self.cache_manager.initialize(&config.cache).await?;
        
        // 初始化备份管理器
        self.backup_manager.initialize(&config.backup).await?;
        
        // 初始化复制管理器
        self.replication_manager.initialize(&config.replication).await?;
        
        // 初始化数据迁移器
        self.data_migrator.initialize(&config.migration).await?;
        
        Ok(())
    }

    // 存储数据
    pub async fn store_data(
        &self,
        key: &str,
        data: &[u8],
        options: &StorageOptions,
    ) -> Result<(), StorageError> {
        // 检查缓存
        if options.use_cache {
            self.cache_manager.set(key, data).await?;
        }
        
        // 存储到主存储
        self.storage_manager.store(key, data, options).await?;
        
        // 复制到副本
        if options.replicate {
            self.replication_manager.replicate_data(key, data).await?;
        }
        
        Ok(())
    }

    // 获取数据
    pub async fn get_data(
        &self,
        key: &str,
        options: &StorageOptions,
    ) -> Result<Option<Vec<u8>>, StorageError> {
        // 尝试从缓存获取
        if options.use_cache {
            if let Some(data) = self.cache_manager.get(key).await? {
                return Ok(Some(data));
            }
        }
        
        // 从主存储获取
        let data = self.storage_manager.get(key, options).await?;
        
        // 更新缓存
        if let Some(ref data) = data {
            if options.use_cache {
                self.cache_manager.set(key, data).await?;
            }
        }
        
        Ok(data)
    }

    // 删除数据
    pub async fn delete_data(
        &self,
        key: &str,
        options: &StorageOptions,
    ) -> Result<(), StorageError> {
        // 从缓存删除
        if options.use_cache {
            self.cache_manager.delete(key).await?;
        }
        
        // 从主存储删除
        self.storage_manager.delete(key, options).await?;
        
        // 从副本删除
        if options.replicate {
            self.replication_manager.delete_replica(key).await?;
        }
        
        Ok(())
    }

    // 创建备份
    pub async fn create_backup(
        &self,
        backup_config: &BackupConfig,
    ) -> Result<BackupInfo, StorageError> {
        let backup_info = self.backup_manager.create_backup(backup_config).await?;
        
        Ok(backup_info)
    }

    // 恢复备份
    pub async fn restore_backup(
        &self,
        backup_id: &str,
        restore_config: &RestoreConfig,
    ) -> Result<(), StorageError> {
        self.backup_manager.restore_backup(backup_id, restore_config).await?;
        
        Ok(())
    }

    // 迁移数据
    pub async fn migrate_data(
        &self,
        migration_config: &MigrationConfig,
    ) -> Result<MigrationResult, StorageError> {
        let result = self.data_migrator.migrate_data(migration_config).await?;
        
        Ok(result)
    }
}
```

### 1.2 存储管理器

```rust
// 存储管理器
#[derive(Debug, Clone)]
pub struct StorageManager {
    pub storage_backends: HashMap<StorageType, Box<dyn StorageBackend>>,
    pub storage_configs: HashMap<StorageType, StorageConfig>,
}

impl StorageManager {
    pub fn new() -> Self {
        let mut backends: HashMap<StorageType, Box<dyn StorageBackend>> = HashMap::new();
        backends.insert(StorageType::File, Box::new(FileStorage::new()));
        backends.insert(StorageType::Database, Box::new(DatabaseStorage::new()));
        backends.insert(StorageType::Object, Box::new(ObjectStorage::new()));
        
        Self {
            storage_backends: backends,
            storage_configs: HashMap::new(),
        }
    }

    // 初始化存储管理器
    pub async fn initialize(
        &self,
        configs: &[StorageConfig],
    ) -> Result<(), StorageError> {
        for config in configs {
            self.storage_configs.insert(config.storage_type.clone(), config.clone());
            
            if let Some(backend) = self.storage_backends.get(&config.storage_type) {
                backend.initialize(&config).await?;
            }
        }
        
        Ok(())
    }

    // 存储数据
    pub async fn store(
        &self,
        key: &str,
        data: &[u8],
        options: &StorageOptions,
    ) -> Result<(), StorageError> {
        let backend = self.get_backend(&options.storage_type)?;
        
        backend.store(key, data, options).await?;
        
        Ok(())
    }

    // 获取数据
    pub async fn get(
        &self,
        key: &str,
        options: &StorageOptions,
    ) -> Result<Option<Vec<u8>>, StorageError> {
        let backend = self.get_backend(&options.storage_type)?;
        
        let data = backend.get(key, options).await?;
        
        Ok(data)
    }

    // 删除数据
    pub async fn delete(
        &self,
        key: &str,
        options: &StorageOptions,
    ) -> Result<(), StorageError> {
        let backend = self.get_backend(&options.storage_type)?;
        
        backend.delete(key, options).await?;
        
        Ok(())
    }

    // 获取存储后端
    fn get_backend(
        &self,
        storage_type: &StorageType,
    ) -> Result<&Box<dyn StorageBackend>, StorageError> {
        self.storage_backends.get(storage_type)
            .ok_or(StorageError::BackendNotFound)
    }
}

// 存储后端trait
#[async_trait::async_trait]
pub trait StorageBackend: Send + Sync {
    async fn initialize(&self, config: &StorageConfig) -> Result<(), StorageError>;
    async fn store(&self, key: &str, data: &[u8], options: &StorageOptions) -> Result<(), StorageError>;
    async fn get(&self, key: &str, options: &StorageOptions) -> Result<Option<Vec<u8>>, StorageError>;
    async fn delete(&self, key: &str, options: &StorageOptions) -> Result<(), StorageError>;
}

// 文件存储
#[derive(Debug, Clone)]
pub struct FileStorage {
    pub base_path: std::path::PathBuf,
}

impl FileStorage {
    pub fn new() -> Self {
        Self {
            base_path: std::path::PathBuf::from("./data"),
        }
    }
}

#[async_trait::async_trait]
impl StorageBackend for FileStorage {
    async fn initialize(
        &self,
        config: &StorageConfig,
    ) -> Result<(), StorageError> {
        // 确保基础目录存在
        tokio::fs::create_dir_all(&self.base_path).await
            .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        
        Ok(())
    }

    async fn store(
        &self,
        key: &str,
        data: &[u8],
        _options: &StorageOptions,
    ) -> Result<(), StorageError> {
        let file_path = self.base_path.join(key);
        
        // 确保父目录存在
        if let Some(parent) = file_path.parent() {
            tokio::fs::create_dir_all(parent).await
                .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        }
        
        // 写入文件
        tokio::fs::write(&file_path, data).await
            .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        
        Ok(())
    }

    async fn get(
        &self,
        key: &str,
        _options: &StorageOptions,
    ) -> Result<Option<Vec<u8>>, StorageError> {
        let file_path = self.base_path.join(key);
        
        if !file_path.exists() {
            return Ok(None);
        }
        
        let data = tokio::fs::read(&file_path).await
            .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        
        Ok(Some(data))
    }

    async fn delete(
        &self,
        key: &str,
        _options: &StorageOptions,
    ) -> Result<(), StorageError> {
        let file_path = self.base_path.join(key);
        
        if file_path.exists() {
            tokio::fs::remove_file(&file_path).await
                .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        }
        
        Ok(())
    }
}

// 数据库存储
#[derive(Debug, Clone)]
pub struct DatabaseStorage {
    pub connection_pool: DatabaseConnectionPool,
}

impl DatabaseStorage {
    pub fn new() -> Self {
        Self {
            connection_pool: DatabaseConnectionPool::new(),
        }
    }
}

#[async_trait::async_trait]
impl StorageBackend for DatabaseStorage {
    async fn initialize(
        &self,
        config: &StorageConfig,
    ) -> Result<(), StorageError> {
        self.connection_pool.initialize(&config.database_config).await?;
        
        Ok(())
    }

    async fn store(
        &self,
        key: &str,
        data: &[u8],
        _options: &StorageOptions,
    ) -> Result<(), StorageError> {
        let mut conn = self.connection_pool.get_connection().await?;
        
        // 使用UPSERT语句
        let query = "INSERT INTO data_store (key, value, updated_at) VALUES (?, ?, ?) 
                     ON CONFLICT(key) DO UPDATE SET value = ?, updated_at = ?";
        
        let now = chrono::Utc::now();
        sqlx::query(query)
            .bind(key)
            .bind(data)
            .bind(now)
            .bind(data)
            .bind(now)
            .execute(&mut *conn)
            .await
            .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        
        Ok(())
    }

    async fn get(
        &self,
        key: &str,
        _options: &StorageOptions,
    ) -> Result<Option<Vec<u8>>, StorageError> {
        let mut conn = self.connection_pool.get_connection().await?;
        
        let query = "SELECT value FROM data_store WHERE key = ?";
        
        let row = sqlx::query_as::<_, (Vec<u8>,)>(query)
            .bind(key)
            .fetch_optional(&mut *conn)
            .await
            .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        
        Ok(row.map(|(value,)| value))
    }

    async fn delete(
        &self,
        key: &str,
        _options: &StorageOptions,
    ) -> Result<(), StorageError> {
        let mut conn = self.connection_pool.get_connection().await?;
        
        let query = "DELETE FROM data_store WHERE key = ?";
        
        sqlx::query(query)
            .bind(key)
            .execute(&mut *conn)
            .await
            .map_err(|e| StorageError::DatabaseError(e.to_string()))?;
        
        Ok(())
    }
}
```

## 2. 缓存管理器

### 2.1 缓存管理器

```rust
// 缓存管理器
#[derive(Debug, Clone)]
pub struct CacheManager {
    pub cache_backends: HashMap<CacheType, Box<dyn CacheBackend>>,
    pub cache_configs: HashMap<CacheType, CacheConfig>,
}

impl CacheManager {
    pub fn new() -> Self {
        let mut backends: HashMap<CacheType, Box<dyn CacheBackend>> = HashMap::new();
        backends.insert(CacheType::Memory, Box::new(MemoryCache::new()));
        backends.insert(CacheType::Redis, Box::new(RedisCache::new()));
        
        Self {
            cache_backends: backends,
            cache_configs: HashMap::new(),
        }
    }

    // 初始化缓存管理器
    pub async fn initialize(
        &self,
        configs: &[CacheConfig],
    ) -> Result<(), StorageError> {
        for config in configs {
            self.cache_configs.insert(config.cache_type.clone(), config.clone());
            
            if let Some(backend) = self.cache_backends.get(&config.cache_type) {
                backend.initialize(&config).await?;
            }
        }
        
        Ok(())
    }

    // 设置缓存
    pub async fn set(
        &self,
        key: &str,
        value: &[u8],
    ) -> Result<(), StorageError> {
        // 使用默认缓存类型
        let cache_type = CacheType::Memory;
        let backend = self.get_backend(&cache_type)?;
        
        backend.set(key, value, None).await?;
        
        Ok(())
    }

    // 获取缓存
    pub async fn get(
        &self,
        key: &str,
    ) -> Result<Option<Vec<u8>>, StorageError> {
        // 使用默认缓存类型
        let cache_type = CacheType::Memory;
        let backend = self.get_backend(&cache_type)?;
        
        let value = backend.get(key).await?;
        
        Ok(value)
    }

    // 删除缓存
    pub async fn delete(
        &self,
        key: &str,
    ) -> Result<(), StorageError> {
        // 使用默认缓存类型
        let cache_type = CacheType::Memory;
        let backend = self.get_backend(&cache_type)?;
        
        backend.delete(key).await?;
        
        Ok(())
    }

    // 清空缓存
    pub async fn clear(
        &self,
    ) -> Result<(), StorageError> {
        // 清空所有缓存后端
        for backend in self.cache_backends.values() {
            backend.clear().await?;
        }
        
        Ok(())
    }

    // 获取缓存后端
    fn get_backend(
        &self,
        cache_type: &CacheType,
    ) -> Result<&Box<dyn CacheBackend>, StorageError> {
        self.cache_backends.get(cache_type)
            .ok_or(StorageError::BackendNotFound)
    }
}

// 缓存后端trait
#[async_trait::async_trait]
pub trait CacheBackend: Send + Sync {
    async fn initialize(&self, config: &CacheConfig) -> Result<(), StorageError>;
    async fn set(&self, key: &str, value: &[u8], ttl: Option<chrono::Duration>) -> Result<(), StorageError>;
    async fn get(&self, key: &str) -> Result<Option<Vec<u8>>, StorageError>;
    async fn delete(&self, key: &str) -> Result<(), StorageError>;
    async fn clear(&self) -> Result<(), StorageError>;
}

// 内存缓存
#[derive(Debug, Clone)]
pub struct MemoryCache {
    pub cache: Arc<RwLock<HashMap<String, CacheEntry>>>,
}

impl MemoryCache {
    pub fn new() -> Self {
        Self {
            cache: Arc::new(RwLock::new(HashMap::new())),
        }
    }
}

#[async_trait::async_trait]
impl CacheBackend for MemoryCache {
    async fn initialize(
        &self,
        _config: &CacheConfig,
    ) -> Result<(), StorageError> {
        Ok(())
    }

    async fn set(
        &self,
        key: &str,
        value: &[u8],
        ttl: Option<chrono::Duration>,
    ) -> Result<(), StorageError> {
        let mut cache = self.cache.write().await;
        
        let entry = CacheEntry {
            value: value.to_vec(),
            created_at: chrono::Utc::now(),
            ttl,
        };
        
        cache.insert(key.to_string(), entry);
        
        Ok(())
    }

    async fn get(
        &self,
        key: &str,
    ) -> Result<Option<Vec<u8>>, StorageError> {
        let mut cache = self.cache.write().await;
        
        if let Some(entry) = cache.get(key) {
            // 检查是否过期
            if let Some(ttl) = entry.ttl {
                let expiry_time = entry.created_at + ttl;
                if chrono::Utc::now() > expiry_time {
                    cache.remove(key);
                    return Ok(None);
                }
            }
            
            Ok(Some(entry.value.clone()))
        } else {
            Ok(None)
        }
    }

    async fn delete(
        &self,
        key: &str,
    ) -> Result<(), StorageError> {
        let mut cache = self.cache.write().await;
        cache.remove(key);
        
        Ok(())
    }

    async fn clear(&self) -> Result<(), StorageError> {
        let mut cache = self.cache.write().await;
        cache.clear();
        
        Ok(())
    }
}

// Redis缓存
#[derive(Debug, Clone)]
pub struct RedisCache {
    pub redis_client: redis::Client,
}

impl RedisCache {
    pub fn new() -> Self {
        let client = redis::Client::open("redis://127.0.0.1/").unwrap();
        Self {
            redis_client: client,
        }
    }
}

#[async_trait::async_trait]
impl CacheBackend for RedisCache {
    async fn initialize(
        &self,
        _config: &CacheConfig,
    ) -> Result<(), StorageError> {
        Ok(())
    }

    async fn set(
        &self,
        key: &str,
        value: &[u8],
        ttl: Option<chrono::Duration>,
    ) -> Result<(), StorageError> {
        let mut conn = self.redis_client.get_async_connection().await
            .map_err(|e| StorageError::RedisError(e.to_string()))?;
        
        if let Some(ttl_duration) = ttl {
            redis::cmd("SETEX")
                .arg(key)
                .arg(ttl_duration.num_seconds() as usize)
                .arg(value)
                .query_async(&mut conn)
                .await
                .map_err(|e| StorageError::RedisError(e.to_string()))?;
        } else {
            redis::cmd("SET")
                .arg(key)
                .arg(value)
                .query_async(&mut conn)
                .await
                .map_err(|e| StorageError::RedisError(e.to_string()))?;
        }
        
        Ok(())
    }

    async fn get(
        &self,
        key: &str,
    ) -> Result<Option<Vec<u8>>, StorageError> {
        let mut conn = self.redis_client.get_async_connection().await
            .map_err(|e| StorageError::RedisError(e.to_string()))?;
        
        let value: Option<Vec<u8>> = redis::cmd("GET")
            .arg(key)
            .query_async(&mut conn)
            .await
            .map_err(|e| StorageError::RedisError(e.to_string()))?;
        
        Ok(value)
    }

    async fn delete(
        &self,
        key: &str,
    ) -> Result<(), StorageError> {
        let mut conn = self.redis_client.get_async_connection().await
            .map_err(|e| StorageError::RedisError(e.to_string()))?;
        
        redis::cmd("DEL")
            .arg(key)
            .query_async(&mut conn)
            .await
            .map_err(|e| StorageError::RedisError(e.to_string()))?;
        
        Ok(())
    }

    async fn clear(&self) -> Result<(), StorageError> {
        let mut conn = self.redis_client.get_async_connection().await
            .map_err(|e| StorageError::RedisError(e.to_string()))?;
        
        redis::cmd("FLUSHALL")
            .query_async(&mut conn)
            .await
            .map_err(|e| StorageError::RedisError(e.to_string()))?;
        
        Ok(())
    }
}
```

## 3. 备份管理器

### 3.1 备份管理器

```rust
// 备份管理器
#[derive(Debug, Clone)]
pub struct BackupManager {
    pub backup_storage: BackupStorage,
    pub backup_scheduler: BackupScheduler,
}

impl BackupManager {
    pub fn new() -> Self {
        Self {
            backup_storage: BackupStorage::new(),
            backup_scheduler: BackupScheduler::new(),
        }
    }

    // 初始化备份管理器
    pub async fn initialize(
        &self,
        config: &BackupConfig,
    ) -> Result<(), StorageError> {
        self.backup_storage.initialize(&config.storage).await?;
        self.backup_scheduler.initialize(&config.scheduler).await?;
        
        Ok(())
    }

    // 创建备份
    pub async fn create_backup(
        &self,
        config: &BackupConfig,
    ) -> Result<BackupInfo, StorageError> {
        // 生成备份ID
        let backup_id = self.generate_backup_id().await?;
        
        // 创建备份
        let backup_info = self.backup_storage.create_backup(&backup_id, config).await?;
        
        // 调度下次备份
        if config.schedule_backup {
            self.backup_scheduler.schedule_backup(config).await?;
        }
        
        Ok(backup_info)
    }

    // 恢复备份
    pub async fn restore_backup(
        &self,
        backup_id: &str,
        config: &RestoreConfig,
    ) -> Result<(), StorageError> {
        self.backup_storage.restore_backup(backup_id, config).await?;
        
        Ok(())
    }

    // 列出备份
    pub async fn list_backups(
        &self,
    ) -> Result<Vec<BackupInfo>, StorageError> {
        let backups = self.backup_storage.list_backups().await?;
        
        Ok(backups)
    }

    // 删除备份
    pub async fn delete_backup(
        &self,
        backup_id: &str,
    ) -> Result<(), StorageError> {
        self.backup_storage.delete_backup(backup_id).await?;
        
        Ok(())
    }

    // 生成备份ID
    async fn generate_backup_id(&self) -> Result<String, StorageError> {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        let id: String = (0..16)
            .map(|_| rng.sample(rand::distributions::Alphanumeric) as char)
            .collect();
        
        Ok(format!("backup_{}", id))
    }
}

// 备份存储
#[derive(Debug, Clone)]
pub struct BackupStorage {
    pub storage_path: std::path::PathBuf,
}

impl BackupStorage {
    pub fn new() -> Self {
        Self {
            storage_path: std::path::PathBuf::from("./backups"),
        }
    }

    // 初始化备份存储
    pub async fn initialize(
        &self,
        config: &BackupStorageConfig,
    ) -> Result<(), StorageError> {
        // 确保备份目录存在
        tokio::fs::create_dir_all(&self.storage_path).await
            .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        
        Ok(())
    }

    // 创建备份
    pub async fn create_backup(
        &self,
        backup_id: &str,
        config: &BackupConfig,
    ) -> Result<BackupInfo, StorageError> {
        let backup_path = self.storage_path.join(format!("{}.tar.gz", backup_id));
        
        // 创建备份文件
        let backup_file = tokio::fs::File::create(&backup_path).await
            .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        
        // 压缩数据
        let mut archive = tar::Builder::new(flate2::write::GzEncoder::new(
            backup_file,
            flate2::Compression::default(),
        ));
        
        // 添加数据文件到归档
        self.add_data_to_archive(&mut archive, &config.data_paths).await?;
        
        // 完成归档
        archive.finish()
            .map_err(|e| StorageError::CompressionError(e.to_string()))?;
        
        // 创建备份信息
        let backup_info = BackupInfo {
            id: backup_id.to_string(),
            path: backup_path.to_string_lossy().to_string(),
            size: backup_path.metadata()
                .map_err(|e| StorageError::FileSystemError(e.to_string()))?
                .len(),
            created_at: chrono::Utc::now(),
            status: BackupStatus::Completed,
        };
        
        Ok(backup_info)
    }

    // 恢复备份
    pub async fn restore_backup(
        &self,
        backup_id: &str,
        config: &RestoreConfig,
    ) -> Result<(), StorageError> {
        let backup_path = self.storage_path.join(format!("{}.tar.gz", backup_id));
        
        if !backup_path.exists() {
            return Err(StorageError::BackupNotFound);
        }
        
        // 打开备份文件
        let backup_file = tokio::fs::File::open(&backup_path).await
            .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        
        // 解压数据
        let archive = flate2::read::GzDecoder::new(backup_file);
        let mut archive = tar::Archive::new(archive);
        
        // 提取数据
        archive.unpack(&config.restore_path)
            .map_err(|e| StorageError::CompressionError(e.to_string()))?;
        
        Ok(())
    }

    // 列出备份
    pub async fn list_backups(
        &self,
    ) -> Result<Vec<BackupInfo>, StorageError> {
        let mut backups = Vec::new();
        
        let mut entries = tokio::fs::read_dir(&self.storage_path).await
            .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        
        while let Some(entry) = entries.next_entry().await
            .map_err(|e| StorageError::FileSystemError(e.to_string()))? {
            
            if let Some(extension) = entry.path().extension() {
                if extension == "gz" {
                    let metadata = entry.metadata().await
                        .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
                    
                    let backup_info = BackupInfo {
                        id: entry.file_name().to_string_lossy().replace(".tar.gz", ""),
                        path: entry.path().to_string_lossy().to_string(),
                        size: metadata.len(),
                        created_at: metadata.created()
                            .map_err(|e| StorageError::FileSystemError(e.to_string()))?
                            .into(),
                        status: BackupStatus::Completed,
                    };
                    
                    backups.push(backup_info);
                }
            }
        }
        
        Ok(backups)
    }

    // 删除备份
    pub async fn delete_backup(
        &self,
        backup_id: &str,
    ) -> Result<(), StorageError> {
        let backup_path = self.storage_path.join(format!("{}.tar.gz", backup_id));
        
        if backup_path.exists() {
            tokio::fs::remove_file(&backup_path).await
                .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        }
        
        Ok(())
    }

    // 添加数据到归档
    async fn add_data_to_archive(
        &self,
        archive: &mut tar::Builder<flate2::write::GzEncoder<tokio::fs::File>>,
        data_paths: &[String],
    ) -> Result<(), StorageError> {
        for path in data_paths {
            let path = std::path::Path::new(path);
            
            if path.is_file() {
                let mut file = tokio::fs::File::open(path).await
                    .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
                
                let mut buffer = Vec::new();
                file.read_to_end(&mut buffer).await
                    .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
                
                let mut header = tar::Header::new_gnu();
                header.set_path(path.file_name().unwrap())
                    .map_err(|e| StorageError::CompressionError(e.to_string()))?;
                header.set_size(buffer.len() as u64);
                header.set_cksum();
                
                archive.append(&header, &buffer[..])
                    .map_err(|e| StorageError::CompressionError(e.to_string()))?;
            } else if path.is_dir() {
                self.add_directory_to_archive(archive, path).await?;
            }
        }
        
        Ok(())
    }

    // 添加目录到归档
    async fn add_directory_to_archive(
        &self,
        archive: &mut tar::Builder<flate2::write::GzEncoder<tokio::fs::File>>,
        dir_path: &std::path::Path,
    ) -> Result<(), StorageError> {
        let mut entries = tokio::fs::read_dir(dir_path).await
            .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
        
        while let Some(entry) = entries.next_entry().await
            .map_err(|e| StorageError::FileSystemError(e.to_string()))? {
            
            let path = entry.path();
            
            if path.is_file() {
                let mut file = tokio::fs::File::open(&path).await
                    .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
                
                let mut buffer = Vec::new();
                file.read_to_end(&mut buffer).await
                    .map_err(|e| StorageError::FileSystemError(e.to_string()))?;
                
                let mut header = tar::Header::new_gnu();
                header.set_path(&path)
                    .map_err(|e| StorageError::CompressionError(e.to_string()))?;
                header.set_size(buffer.len() as u64);
                header.set_cksum();
                
                archive.append(&header, &buffer[..])
                    .map_err(|e| StorageError::CompressionError(e.to_string()))?;
            } else if path.is_dir() {
                self.add_directory_to_archive(archive, &path).await?;
            }
        }
        
        Ok(())
    }
}
```

---

**数据存储实现完成** - 包含数据存储核心、存储管理器、缓存管理器、备份管理器等核心功能。
