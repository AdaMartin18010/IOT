# 协议适配器实现

## 1. 统一协议适配架构

### 1.1 适配器接口定义

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use async_trait::async_trait;
use tokio::sync::mpsc;

/// 协议类型
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ProtocolType {
    OPCUA,
    MQTT,
    HTTP,
    CoAP,
    Modbus,
    Zigbee,
    Bluetooth,
    WiFi,
    LoRaWAN,
    NB_IoT,
}

/// 设备消息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceMessage {
    pub device_id: String,
    pub protocol: ProtocolType,
    pub message_type: MessageType,
    pub payload: Vec<u8>,
    pub timestamp: u64,
    pub metadata: HashMap<String, String>,
}

/// 消息类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessageType {
    Data,
    Command,
    Status,
    Alert,
    Configuration,
    Discovery,
}

/// 协议适配器接口
#[async_trait]
pub trait ProtocolAdapter: Send + Sync {
    /// 协议类型
    fn protocol_type(&self) -> ProtocolType;
    
    /// 初始化适配器
    async fn initialize(&mut self, config: AdapterConfig) -> Result<(), Box<dyn std::error::Error>>;
    
    /// 连接设备
    async fn connect(&mut self, device_info: DeviceInfo) -> Result<(), Box<dyn std::error::Error>>;
    
    /// 断开连接
    async fn disconnect(&mut self, device_id: &str) -> Result<(), Box<dyn std::error::Error>>;
    
    /// 发送消息
    async fn send_message(&self, message: DeviceMessage) -> Result<(), Box<dyn std::error::Error>>;
    
    /// 接收消息
    async fn receive_message(&mut self) -> Result<Option<DeviceMessage>, Box<dyn std::error::Error>>;
    
    /// 获取设备状态
    async fn get_device_status(&self, device_id: &str) -> Result<DeviceStatus, Box<dyn std::error::Error>>;
    
    /// 配置设备
    async fn configure_device(&self, device_id: &str, config: HashMap<String, String>) -> Result<(), Box<dyn std::error::Error>>;
}

/// 适配器配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AdapterConfig {
    pub protocol: ProtocolType,
    pub connection_params: HashMap<String, String>,
    pub security_config: SecurityConfig,
    pub timeout_ms: u64,
    pub retry_count: u32,
}

/// 安全配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityConfig {
    pub encryption_enabled: bool,
    pub authentication_required: bool,
    pub certificate_path: Option<String>,
    pub private_key_path: Option<String>,
    pub username: Option<String>,
    pub password: Option<String>,
}

/// 设备信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceInfo {
    pub device_id: String,
    pub device_type: String,
    pub protocol: ProtocolType,
    pub connection_params: HashMap<String, String>,
    pub capabilities: Vec<String>,
}

/// 设备状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceStatus {
    pub device_id: String,
    pub connected: bool,
    pub last_seen: u64,
    pub error_count: u32,
    pub message_count: u64,
    pub battery_level: Option<f64>,
    pub signal_strength: Option<i32>,
}
```

### 1.2 适配器管理器

```rust
/// 协议适配器管理器
pub struct ProtocolAdapterManager {
    adapters: HashMap<ProtocolType, Box<dyn ProtocolAdapter>>,
    message_sender: mpsc::Sender<DeviceMessage>,
    message_receiver: mpsc::Receiver<DeviceMessage>,
}

impl ProtocolAdapterManager {
    pub fn new() -> Self {
        let (tx, rx) = mpsc::channel(1000);
        Self {
            adapters: HashMap::new(),
            message_sender: tx,
            message_receiver: rx,
        }
    }

    /// 注册适配器
    pub fn register_adapter(&mut self, adapter: Box<dyn ProtocolAdapter>) {
        let protocol_type = adapter.protocol_type();
        self.adapters.insert(protocol_type, adapter);
    }

    /// 初始化所有适配器
    pub async fn initialize_adapters(&mut self, configs: Vec<AdapterConfig>) -> Result<(), Box<dyn std::error::Error>> {
        for config in configs {
            if let Some(adapter) = self.adapters.get_mut(&config.protocol) {
                adapter.initialize(config).await?;
            }
        }
        Ok(())
    }

    /// 发送消息
    pub async fn send_message(&self, message: DeviceMessage) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(adapter) = self.adapters.get(&message.protocol) {
            adapter.send_message(message).await?;
        } else {
            return Err(format!("No adapter found for protocol: {:?}", message.protocol).into());
        }
        Ok(())
    }

    /// 接收消息
    pub async fn receive_message(&mut self) -> Result<Option<DeviceMessage>, Box<dyn std::error::Error>> {
        // 从所有适配器接收消息
        for adapter in self.adapters.values_mut() {
            if let Some(message) = adapter.receive_message().await? {
                return Ok(Some(message));
            }
        }
        Ok(None)
    }

    /// 获取适配器
    pub fn get_adapter(&self, protocol: &ProtocolType) -> Option<&dyn ProtocolAdapter> {
        self.adapters.get(protocol).map(|a| a.as_ref())
    }

    /// 获取所有支持的协议
    pub fn get_supported_protocols(&self) -> Vec<ProtocolType> {
        self.adapters.keys().cloned().collect()
    }
}
```

## 2. OPC UA适配器实现

### 2.1 Rust实现

```rust
use opcua::client::prelude::*;
use opcua::server::prelude::*;
use opcua::types::*;

/// OPC UA适配器
pub struct OPCUAAdapter {
    client: Option<Client>,
    server: Option<Server>,
    config: AdapterConfig,
    connected_devices: HashMap<String, NodeId>,
}

impl OPCUAAdapter {
    pub fn new() -> Self {
        Self {
            client: None,
            server: None,
            config: AdapterConfig {
                protocol: ProtocolType::OPCUA,
                connection_params: HashMap::new(),
                security_config: SecurityConfig {
                    encryption_enabled: true,
                    authentication_required: true,
                    certificate_path: None,
                    private_key_path: None,
                    username: None,
                    password: None,
                },
                timeout_ms: 5000,
                retry_count: 3,
            },
            connected_devices: HashMap::new(),
        }
    }

    /// 创建OPC UA客户端
    async fn create_client(&mut self, endpoint_url: &str) -> Result<(), Box<dyn std::error::Error>> {
        let client_config = ClientConfig::new(
            "IoT-OPC-UA-Client",
            "urn:iot:opcua:client",
            endpoint_url,
            SecurityPolicy::None,
            MessageSecurityMode::None,
            ClientUserToken::Anonymous,
        );

        let client = Client::new(client_config);
        self.client = Some(client);
        Ok(())
    }

    /// 创建OPC UA服务器
    async fn create_server(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let server_config = ServerConfig::new(
            "IoT-OPC-UA-Server",
            "urn:iot:opcua:server",
            "iot.opcua.server",
        );

        let server = Server::new(server_config);
        self.server = Some(server);
        Ok(())
    }
}

#[async_trait]
impl ProtocolAdapter for OPCUAAdapter {
    fn protocol_type(&self) -> ProtocolType {
        ProtocolType::OPCUA
    }

    async fn initialize(&mut self, config: AdapterConfig) -> Result<(), Box<dyn std::error::Error>> {
        self.config = config;
        
        // 根据配置决定创建客户端还是服务器
        if let Some(endpoint_url) = self.config.connection_params.get("endpoint_url") {
            self.create_client(endpoint_url).await?;
        } else {
            self.create_server().await?;
        }
        
        Ok(())
    }

    async fn connect(&mut self, device_info: DeviceInfo) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(client) = &mut self.client {
            let endpoint_url = device_info.connection_params.get("endpoint_url")
                .ok_or("Missing endpoint_url")?;
            
            client.connect(endpoint_url).await?;
            
            // 注册设备节点
            let node_id = NodeId::new(2, device_info.device_id.clone());
            self.connected_devices.insert(device_info.device_id, node_id);
        }
        
        Ok(())
    }

    async fn disconnect(&mut self, device_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(client) = &mut self.client {
            client.disconnect().await?;
        }
        
        self.connected_devices.remove(device_id);
        Ok(())
    }

    async fn send_message(&self, message: DeviceMessage) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(client) = &self.client {
            if let Some(node_id) = self.connected_devices.get(&message.device_id) {
                // 将消息转换为OPC UA写入请求
                let value = DataValue::new_now(message.payload);
                client.write_value(node_id.clone(), value).await?;
            }
        }
        
        Ok(())
    }

    async fn receive_message(&mut self) -> Result<Option<DeviceMessage>, Box<dyn std::error::Error>> {
        if let Some(client) = &mut self.client {
            // 订阅数据变化通知
            // 这里简化实现，实际应该处理OPC UA订阅
            return Ok(None);
        }
        
        Ok(None)
    }

    async fn get_device_status(&self, device_id: &str) -> Result<DeviceStatus, Box<dyn std::error::Error>> {
        let connected = self.connected_devices.contains_key(device_id);
        
        Ok(DeviceStatus {
            device_id: device_id.to_string(),
            connected,
            last_seen: chrono::Utc::now().timestamp() as u64,
            error_count: 0,
            message_count: 0,
            battery_level: None,
            signal_strength: None,
        })
    }

    async fn configure_device(&self, device_id: &str, config: HashMap<String, String>) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(client) = &self.client {
            if let Some(node_id) = self.connected_devices.get(device_id) {
                // 配置设备参数
                for (key, value) in config {
                    let config_node_id = NodeId::new(2, format!("{}.{}", device_id, key));
                    let data_value = DataValue::new_now(value.as_bytes());
                    client.write_value(config_node_id, data_value).await?;
                }
            }
        }
        
        Ok(())
    }
}
```

### 2.2 Go实现

```go
package opcua

import (
    "context"
    "fmt"
    "time"
    
    "github.com/gopcua/opcua"
    "github.com/gopcua/opcua/ua"
)

// OPCUAAdapter OPC UA适配器
type OPCUAAdapter struct {
    client           *opcua.Client
    server           *opcua.Server
    config           AdapterConfig
    connectedDevices map[string]*ua.NodeID
}

// NewOPCUAAdapter 创建OPC UA适配器
func NewOPCUAAdapter() *OPCUAAdapter {
    return &OPCUAAdapter{
        config: AdapterConfig{
            Protocol: OPCUA,
            ConnectionParams: make(map[string]string),
            SecurityConfig: SecurityConfig{
                EncryptionEnabled:     true,
                AuthenticationRequired: true,
            },
            TimeoutMs:  5000,
            RetryCount: 3,
        },
        connectedDevices: make(map[string]*ua.NodeID),
    }
}

// Initialize 初始化适配器
func (a *OPCUAAdapter) Initialize(config AdapterConfig) error {
    a.config = config
    
    if endpointURL, exists := config.ConnectionParams["endpoint_url"]; exists {
        return a.createClient(endpointURL)
    } else {
        return a.createServer()
    }
}

// createClient 创建客户端
func (a *OPCUAAdapter) createClient(endpointURL string) error {
    opts := []opcua.Option{
        opcua.SecurityPolicy(ua.SecurityPolicyURINone),
        opcua.SecurityModeString(ua.MessageSecurityModeNone),
        opcua.AuthAnonymous(),
        opcua.RequestTimeout(time.Duration(a.config.TimeoutMs) * time.Millisecond),
    }
    
    client := opcua.NewClient(endpointURL, opts...)
    if err := client.Connect(context.Background()); err != nil {
        return fmt.Errorf("failed to connect: %v", err)
    }
    
    a.client = client
    return nil
}

// createServer 创建服务器
func (a *OPCUAAdapter) createServer() error {
    // 实现OPC UA服务器
    return nil
}

// Connect 连接设备
func (a *OPCUAAdapter) Connect(deviceInfo DeviceInfo) error {
    if a.client != nil {
        // 注册设备节点
        nodeID := ua.NewStringNodeID(2, deviceInfo.DeviceID)
        a.connectedDevices[deviceInfo.DeviceID] = nodeID
    }
    
    return nil
}

// Disconnect 断开连接
func (a *OPCUAAdapter) Disconnect(deviceID string) error {
    if a.client != nil {
        a.client.Close()
    }
    
    delete(a.connectedDevices, deviceID)
    return nil
}

// SendMessage 发送消息
func (a *OPCUAAdapter) SendMessage(message DeviceMessage) error {
    if a.client != nil {
        if nodeID, exists := a.connectedDevices[message.DeviceID]; exists {
            // 写入数据
            value := ua.NewDataValue(message.Payload, 0, time.Now(), 0, time.Now(), 0)
            req := &ua.WriteRequest{
                NodesToWrite: []*ua.WriteValue{
                    {
                        NodeID:      nodeID,
                        AttributeID: ua.AttributeIDValue,
                        Value:       value,
                    },
                },
            }
            
            _, err := a.client.Write(req)
            return err
        }
    }
    
    return fmt.Errorf("device not connected: %s", message.DeviceID)
}

// ReceiveMessage 接收消息
func (a *OPCUAAdapter) ReceiveMessage() (*DeviceMessage, error) {
    // 实现消息接收逻辑
    return nil, nil
}

// GetDeviceStatus 获取设备状态
func (a *OPCUAAdapter) GetDeviceStatus(deviceID string) (*DeviceStatus, error) {
    connected := false
    if _, exists := a.connectedDevices[deviceID]; exists {
        connected = true
    }
    
    return &DeviceStatus{
        DeviceID:      deviceID,
        Connected:     connected,
        LastSeen:      time.Now().Unix(),
        ErrorCount:    0,
        MessageCount:  0,
        BatteryLevel:  nil,
        SignalStrength: nil,
    }, nil
}

// ConfigureDevice 配置设备
func (a *OPCUAAdapter) ConfigureDevice(deviceID string, config map[string]string) error {
    if a.client != nil {
        if _, exists := a.connectedDevices[deviceID]; exists {
            for key, value := range config {
                configNodeID := ua.NewStringNodeID(2, fmt.Sprintf("%s.%s", deviceID, key))
                dataValue := ua.NewDataValue([]byte(value), 0, time.Now(), 0, time.Now(), 0)
                
                req := &ua.WriteRequest{
                    NodesToWrite: []*ua.WriteValue{
                        {
                            NodeID:      configNodeID,
                            AttributeID: ua.AttributeIDValue,
                            Value:       dataValue,
                        },
                    },
                }
                
                if _, err := a.client.Write(req); err != nil {
                    return err
                }
            }
        }
    }
    
    return nil
}
```

## 3. MQTT适配器实现

### 3.1 Rust实现

```rust
use paho_mqtt as mqtt;
use serde_json;

/// MQTT适配器
pub struct MQTTAdapter {
    client: Option<mqtt::AsyncClient>,
    config: AdapterConfig,
    connected_devices: HashMap<String, String>,
    message_sender: mpsc::Sender<DeviceMessage>,
}

impl MQTTAdapter {
    pub fn new() -> Self {
        let (tx, _) = mpsc::channel(100);
        Self {
            client: None,
            config: AdapterConfig {
                protocol: ProtocolType::MQTT,
                connection_params: HashMap::new(),
                security_config: SecurityConfig {
                    encryption_enabled: false,
                    authentication_required: false,
                    certificate_path: None,
                    private_key_path: None,
                    username: None,
                    password: None,
                },
                timeout_ms: 5000,
                retry_count: 3,
            },
            connected_devices: HashMap::new(),
            message_sender: tx,
        }
    }

    /// 创建MQTT客户端
    async fn create_client(&mut self, broker_url: &str) -> Result<(), Box<dyn std::error::Error>> {
        let create_opts = mqtt::CreateOptionsBuilder::new()
            .server_uri(broker_url)
            .client_id("iot-mqtt-adapter")
            .finalize();

        let client = mqtt::AsyncClient::new(create_opts)?;
        
        // 设置回调
        let message_sender = self.message_sender.clone();
        client.set_message_callback(move |client, msg| {
            if let Some(msg) = msg {
                // 处理接收到的消息
                if let Ok(device_message) = Self::parse_mqtt_message(msg) {
                    let _ = message_sender.blocking_send(device_message);
                }
            }
        });

        self.client = Some(client);
        Ok(())
    }

    /// 解析MQTT消息
    fn parse_mqtt_message(msg: mqtt::Message) -> Result<DeviceMessage, Box<dyn std::error::Error>> {
        let topic = msg.topic();
        let payload = msg.payload_str();
        
        // 解析主题格式: devices/{device_id}/{message_type}
        let parts: Vec<&str> = topic.split('/').collect();
        if parts.len() >= 3 {
            let device_id = parts[1].to_string();
            let message_type = match parts[2] {
                "data" => MessageType::Data,
                "command" => MessageType::Command,
                "status" => MessageType::Status,
                "alert" => MessageType::Alert,
                _ => MessageType::Data,
            };
            
            return Ok(DeviceMessage {
                device_id,
                protocol: ProtocolType::MQTT,
                message_type,
                payload: payload.as_bytes().to_vec(),
                timestamp: chrono::Utc::now().timestamp() as u64,
                metadata: HashMap::new(),
            });
        }
        
        Err("Invalid MQTT topic format".into())
    }
}

#[async_trait]
impl ProtocolAdapter for MQTTAdapter {
    fn protocol_type(&self) -> ProtocolType {
        ProtocolType::MQTT
    }

    async fn initialize(&mut self, config: AdapterConfig) -> Result<(), Box<dyn std::error::Error>> {
        self.config = config;
        
        if let Some(broker_url) = self.config.connection_params.get("broker_url") {
            self.create_client(broker_url).await?;
        }
        
        Ok(())
    }

    async fn connect(&mut self, device_info: DeviceInfo) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(client) = &mut self.client {
            let connect_opts = mqtt::ConnectOptionsBuilder::new()
                .keep_alive_interval(Duration::from_secs(30))
                .clean_session(true)
                .finalize();

            client.connect(connect_opts).await?;
            
            // 订阅设备主题
            let topic = format!("devices/{}/#", device_info.device_id);
            client.subscribe(&topic, 1).await?;
            
            self.connected_devices.insert(device_info.device_id, topic);
        }
        
        Ok(())
    }

    async fn disconnect(&mut self, device_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(client) = &mut self.client {
            if let Some(topic) = self.connected_devices.get(device_id) {
                client.unsubscribe(topic).await?;
            }
            client.disconnect(None).await?;
        }
        
        self.connected_devices.remove(device_id);
        Ok(())
    }

    async fn send_message(&self, message: DeviceMessage) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(client) = &self.client {
            let topic = format!("devices/{}/{}", 
                message.device_id, 
                match message.message_type {
                    MessageType::Data => "data",
                    MessageType::Command => "command",
                    MessageType::Status => "status",
                    MessageType::Alert => "alert",
                    _ => "data",
                }
            );
            
            let mqtt_message = mqtt::MessageBuilder::new()
                .topic(&topic)
                .payload(message.payload)
                .qos(1)
                .finalize();
            
            client.publish(mqtt_message).await?;
        }
        
        Ok(())
    }

    async fn receive_message(&mut self) -> Result<Option<DeviceMessage>, Box<dyn std::error::Error>> {
        // 从消息通道接收消息
        if let Ok(message) = self.message_sender.try_recv() {
            return Ok(Some(message));
        }
        
        Ok(None)
    }

    async fn get_device_status(&self, device_id: &str) -> Result<DeviceStatus, Box<dyn std::error::Error>> {
        let connected = self.connected_devices.contains_key(device_id);
        
        Ok(DeviceStatus {
            device_id: device_id.to_string(),
            connected,
            last_seen: chrono::Utc::now().timestamp() as u64,
            error_count: 0,
            message_count: 0,
            battery_level: None,
            signal_strength: None,
        })
    }

    async fn configure_device(&self, device_id: &str, config: HashMap<String, String>) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(client) = &self.client {
            let topic = format!("devices/{}/config", device_id);
            let payload = serde_json::to_vec(&config)?;
            
            let mqtt_message = mqtt::MessageBuilder::new()
                .topic(&topic)
                .payload(payload)
                .qos(1)
                .finalize();
            
            client.publish(mqtt_message).await?;
        }
        
        Ok(())
    }
}
```

## 4. 应用示例

### 4.1 多协议设备管理

```rust
use crate::protocol::{ProtocolAdapterManager, AdapterConfig, DeviceInfo, DeviceMessage};

async fn manage_multi_protocol_devices() -> Result<(), Box<dyn std::error::Error>> {
    let mut manager = ProtocolAdapterManager::new();
    
    // 注册OPC UA适配器
    let opcua_adapter = Box::new(OPCUAAdapter::new());
    manager.register_adapter(opcua_adapter);
    
    // 注册MQTT适配器
    let mqtt_adapter = Box::new(MQTTAdapter::new());
    manager.register_adapter(mqtt_adapter);
    
    // 配置适配器
    let configs = vec![
        AdapterConfig {
            protocol: ProtocolType::OPCUA,
            connection_params: {
                let mut params = HashMap::new();
                params.insert("endpoint_url".to_string(), "opc.tcp://localhost:4840".to_string());
                params
            },
            security_config: SecurityConfig {
                encryption_enabled: true,
                authentication_required: true,
                certificate_path: None,
                private_key_path: None,
                username: None,
                password: None,
            },
            timeout_ms: 5000,
            retry_count: 3,
        },
        AdapterConfig {
            protocol: ProtocolType::MQTT,
            connection_params: {
                let mut params = HashMap::new();
                params.insert("broker_url".to_string(), "mqtt://localhost:1883".to_string());
                params
            },
            security_config: SecurityConfig {
                encryption_enabled: false,
                authentication_required: false,
                certificate_path: None,
                private_key_path: None,
                username: None,
                password: None,
            },
            timeout_ms: 5000,
            retry_count: 3,
        },
    ];
    
    manager.initialize_adapters(configs).await?;
    
    // 连接设备
    let devices = vec![
        DeviceInfo {
            device_id: "sensor_001".to_string(),
            device_type: "Temperature Sensor".to_string(),
            protocol: ProtocolType::OPCUA,
            connection_params: {
                let mut params = HashMap::new();
                params.insert("endpoint_url".to_string(), "opc.tcp://sensor_001:4840".to_string());
                params
            },
            capabilities: vec!["temperature_reading".to_string()],
        },
        DeviceInfo {
            device_id: "actuator_001".to_string(),
            device_type: "Light Switch".to_string(),
            protocol: ProtocolType::MQTT,
            connection_params: {
                let mut params = HashMap::new();
                params.insert("broker_url".to_string(), "mqtt://actuator_001:1883".to_string());
                params
            },
            capabilities: vec!["light_control".to_string()],
        },
    ];
    
    for device in devices {
        if let Some(adapter) = manager.get_adapter(&device.protocol) {
            // 连接设备
            // adapter.connect(device).await?;
            
            // 发送配置消息
            let config_message = DeviceMessage {
                device_id: device.device_id.clone(),
                protocol: device.protocol,
                message_type: MessageType::Configuration,
                payload: b"{\"sampling_rate\": 1000}".to_vec(),
                timestamp: chrono::Utc::now().timestamp() as u64,
                metadata: HashMap::new(),
            };
            
            manager.send_message(config_message).await?;
        }
    }
    
    // 消息处理循环
    loop {
        if let Some(message) = manager.receive_message().await? {
            println!("Received message from {}: {:?}", message.device_id, message.message_type);
            
            // 处理消息
            match message.message_type {
                MessageType::Data => {
                    // 处理数据消息
                    println!("Data: {:?}", String::from_utf8_lossy(&message.payload));
                }
                MessageType::Alert => {
                    // 处理告警消息
                    println!("Alert: {:?}", String::from_utf8_lossy(&message.payload));
                }
                _ => {
                    // 处理其他消息类型
                }
            }
        }
        
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
}
```

## 5. 总结

本实现提供了：

1. **统一协议适配架构** - 支持多种IoT协议的统一接口
2. **OPC UA适配器** - 完整的OPC UA客户端和服务器实现
3. **MQTT适配器** - 轻量级消息传输协议支持
4. **可扩展设计** - 易于添加新的协议适配器
5. **实际应用示例** - 多协议设备管理场景

这个协议适配器系统为IoT平台提供了强大的多协议支持能力，实现了不同协议设备间的统一管理和通信。
