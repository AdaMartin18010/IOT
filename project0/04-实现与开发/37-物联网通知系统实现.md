# 物联网通知系统实现

## 概述

物联网通知系统提供多渠道通知发送、模板管理、通知调度和通知历史记录等核心功能。

## 核心架构

### 1. 通知系统核心

```rust
pub struct NotificationSystem {
    channels: Arc<RwLock<HashMap<String, Box<dyn NotificationChannel>>>>,
    templates: Arc<RwLock<HashMap<String, NotificationTemplate>>>,
    scheduler: Arc<NotificationScheduler>,
    history: Arc<NotificationHistory>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Notification {
    pub id: String,
    pub title: String,
    pub message: String,
    pub notification_type: NotificationType,
    pub priority: NotificationPriority,
    pub recipients: Vec<String>,
    pub channels: Vec<String>,
    pub template_id: Option<String>,
    pub data: HashMap<String, String>,
    pub scheduled_at: Option<DateTime<Utc>>,
    pub created_at: DateTime<Utc>,
    pub status: NotificationStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NotificationType {
    Alert,
    Warning,
    Info,
    Success,
    Error,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NotificationPriority {
    Low,
    Normal,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NotificationStatus {
    Pending,
    Sending,
    Sent,
    Failed,
    Cancelled,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationTemplate {
    pub id: String,
    pub name: String,
    pub description: String,
    pub title_template: String,
    pub message_template: String,
    pub channels: Vec<String>,
    pub variables: Vec<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

impl NotificationSystem {
    pub fn new() -> Self {
        Self {
            channels: Arc::new(RwLock::new(HashMap::new())),
            templates: Arc::new(RwLock::new(HashMap::new())),
            scheduler: Arc::new(NotificationScheduler::new()),
            history: Arc::new(NotificationHistory::new()),
        }
    }

    // 注册通知渠道
    pub async fn register_channel(&self, name: String, channel: Box<dyn NotificationChannel>) {
        let mut channels = self.channels.write().await;
        channels.insert(name, channel);
    }

    // 发送通知
    pub async fn send_notification(&self, notification: Notification) -> Result<Vec<NotificationResult>, NotificationError> {
        let mut results = Vec::new();
        
        // 处理模板
        let processed_notification = if let Some(template_id) = &notification.template_id {
            self.process_template(notification, template_id).await?
        } else {
            notification
        };
        
        // 发送到各个渠道
        let channels = self.channels.read().await;
        for channel_name in &processed_notification.channels {
            if let Some(channel) = channels.get(channel_name) {
                let result = channel.send(&processed_notification).await;
                results.push(NotificationResult {
                    channel: channel_name.clone(),
                    success: result.is_ok(),
                    error: result.err().map(|e| e.to_string()),
                    sent_at: Utc::now(),
                });
            }
        }
        
        // 记录历史
        self.history.record_notification(&processed_notification, &results).await;
        
        Ok(results)
    }

    // 处理模板
    async fn process_template(&self, mut notification: Notification, template_id: &str) -> Result<Notification, NotificationError> {
        let templates = self.templates.read().await;
        let template = templates.get(template_id)
            .ok_or(NotificationError::TemplateNotFound)?;
        
        // 替换标题模板
        notification.title = self.replace_variables(&template.title_template, &notification.data);
        
        // 替换消息模板
        notification.message = self.replace_variables(&template.message_template, &notification.data);
        
        // 使用模板的渠道
        if notification.channels.is_empty() {
            notification.channels = template.channels.clone();
        }
        
        Ok(notification)
    }

    // 替换变量
    fn replace_variables(&self, template: &str, data: &HashMap<String, String>) -> String {
        let mut result = template.to_string();
        
        for (key, value) in data {
            let placeholder = format!("{{{{{}}}}}", key);
            result = result.replace(&placeholder, value);
        }
        
        result
    }

    // 调度通知
    pub async fn schedule_notification(&self, notification: Notification, scheduled_at: DateTime<Utc>) -> Result<String, NotificationError> {
        let scheduled_id = Uuid::new_v4().to_string();
        
        self.scheduler.schedule_notification(scheduled_id.clone(), notification, scheduled_at).await?;
        
        Ok(scheduled_id)
    }

    // 取消调度通知
    pub async fn cancel_scheduled_notification(&self, scheduled_id: &str) -> Result<(), NotificationError> {
        self.scheduler.cancel_notification(scheduled_id).await
    }
}
```

### 2. 通知渠道接口

```rust
pub trait NotificationChannel: Send + Sync {
    async fn send(&self, notification: &Notification) -> Result<(), NotificationError>;
    fn get_name(&self) -> &str;
    fn is_enabled(&self) -> bool;
}

// 邮件通知渠道
pub struct EmailChannel {
    smtp_config: SmtpConfig,
    enabled: bool,
}

#[derive(Debug, Clone)]
pub struct SmtpConfig {
    pub host: String,
    pub port: u16,
    pub username: String,
    pub password: String,
    pub use_tls: bool,
    pub from_address: String,
    pub from_name: String,
}

impl NotificationChannel for EmailChannel {
    async fn send(&self, notification: &Notification) -> Result<(), NotificationError> {
        if !self.enabled {
            return Err(NotificationError::ChannelDisabled);
        }
        
        // 构建邮件内容
        let email = Email::new()
            .from((self.smtp_config.from_address.clone(), self.smtp_config.from_name.clone()))
            .to(notification.recipients.clone())
            .subject(&notification.title)
            .body(&notification.message);
        
        // 发送邮件
        let mailer = SmtpTransport::relay(&self.smtp_config.host)
            .map_err(|e| NotificationError::ChannelError(e.to_string()))?
            .port(self.smtp_config.port)
            .credentials(Credentials::new(
                self.smtp_config.username.clone(),
                self.smtp_config.password.clone(),
            ))
            .build();
        
        mailer.send(&email)
            .map_err(|e| NotificationError::ChannelError(e.to_string()))?;
        
        Ok(())
    }
    
    fn get_name(&self) -> &str {
        "email"
    }
    
    fn is_enabled(&self) -> bool {
        self.enabled
    }
}

// Webhook通知渠道
pub struct WebhookChannel {
    webhook_url: String,
    headers: HashMap<String, String>,
    enabled: bool,
}

impl NotificationChannel for WebhookChannel {
    async fn send(&self, notification: &Notification) -> Result<(), NotificationError> {
        if !self.enabled {
            return Err(NotificationError::ChannelDisabled);
        }
        
        let client = reqwest::Client::new();
        
        let payload = serde_json::json!({
            "title": notification.title,
            "message": notification.message,
            "type": notification.notification_type,
            "priority": notification.priority,
            "recipients": notification.recipients,
            "data": notification.data,
            "timestamp": notification.created_at,
        });
        
        let mut request = client.post(&self.webhook_url)
            .json(&payload);
        
        for (key, value) in &self.headers {
            request = request.header(key, value);
        }
        
        request.send().await
            .map_err(|e| NotificationError::ChannelError(e.to_string()))?;
        
        Ok(())
    }
    
    fn get_name(&self) -> &str {
        "webhook"
    }
    
    fn is_enabled(&self) -> bool {
        self.enabled
    }
}

// 短信通知渠道
pub struct SmsChannel {
    provider: SmsProvider,
    api_key: String,
    enabled: bool,
}

#[derive(Debug, Clone)]
pub enum SmsProvider {
    Twilio,
    Aliyun,
    Tencent,
    Custom(String),
}

impl NotificationChannel for SmsChannel {
    async fn send(&self, notification: &Notification) -> Result<(), NotificationError> {
        if !self.enabled {
            return Err(NotificationError::ChannelDisabled);
        }
        
        match &self.provider {
            SmsProvider::Twilio => {
                self.send_twilio_sms(notification).await
            }
            SmsProvider::Aliyun => {
                self.send_aliyun_sms(notification).await
            }
            SmsProvider::Tencent => {
                self.send_tencent_sms(notification).await
            }
            SmsProvider::Custom(_) => {
                Err(NotificationError::ChannelError("自定义短信提供商未实现".to_string()))
            }
        }
    }
    
    fn get_name(&self) -> &str {
        "sms"
    }
    
    fn is_enabled(&self) -> bool {
        self.enabled
    }
}

impl SmsChannel {
    async fn send_twilio_sms(&self, notification: &Notification) -> Result<(), NotificationError> {
        let client = reqwest::Client::new();
        
        for recipient in &notification.recipients {
            let form_data = [
                ("To", recipient),
                ("From", &self.api_key),
                ("Body", &notification.message),
            ];
            
            client.post("https://api.twilio.com/2010-04-01/Accounts/ACCOUNT_SID/Messages.json")
                .basic_auth(&self.api_key, None)
                .form(&form_data)
                .send().await
                .map_err(|e| NotificationError::ChannelError(e.to_string()))?;
        }
        
        Ok(())
    }
    
    async fn send_aliyun_sms(&self, notification: &Notification) -> Result<(), NotificationError> {
        // 阿里云短信发送实现
        Ok(())
    }
    
    async fn send_tencent_sms(&self, notification: &Notification) -> Result<(), NotificationError> {
        // 腾讯云短信发送实现
        Ok(())
    }
}
```

### 3. 通知调度器

```rust
pub struct NotificationScheduler {
    scheduled_notifications: Arc<RwLock<HashMap<String, ScheduledNotification>>>,
    scheduler_handle: Option<JoinHandle<()>>,
    notification_system: Arc<NotificationSystem>,
}

#[derive(Debug, Clone)]
pub struct ScheduledNotification {
    pub id: String,
    pub notification: Notification,
    pub scheduled_at: DateTime<Utc>,
    pub status: ScheduledStatus,
}

#[derive(Debug, Clone)]
pub enum ScheduledStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
}

impl NotificationScheduler {
    pub fn new() -> Self {
        Self {
            scheduled_notifications: Arc::new(RwLock::new(HashMap::new())),
            scheduler_handle: None,
            notification_system: Arc::new(NotificationSystem::new()),
        }
    }

    // 启动调度器
    pub async fn start(&mut self) {
        let scheduled_notifications = self.scheduled_notifications.clone();
        let notification_system = self.notification_system.clone();
        
        let handle = tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_secs(30));
            
            loop {
                interval.tick().await;
                
                let now = Utc::now();
                let mut notifications = scheduled_notifications.write().await;
                
                let mut to_send = Vec::new();
                
                for (id, scheduled) in notifications.iter_mut() {
                    if scheduled.status == ScheduledStatus::Pending && scheduled.scheduled_at <= now {
                        scheduled.status = ScheduledStatus::Running;
                        to_send.push((id.clone(), scheduled.notification.clone()));
                    }
                }
                
                drop(notifications);
                
                for (id, notification) in to_send {
                    let result = notification_system.send_notification(notification).await;
                    
                    let mut notifications = scheduled_notifications.write().await;
                    if let Some(scheduled) = notifications.get_mut(&id) {
                        scheduled.status = if result.is_ok() {
                            ScheduledStatus::Completed
                        } else {
                            ScheduledStatus::Failed
                        };
                    }
                }
            }
        });
        
        self.scheduler_handle = Some(handle);
    }

    // 停止调度器
    pub async fn stop(&mut self) {
        if let Some(handle) = self.scheduler_handle.take() {
            handle.abort().await;
        }
    }

    // 调度通知
    pub async fn schedule_notification(&self, id: String, notification: Notification, scheduled_at: DateTime<Utc>) -> Result<(), NotificationError> {
        let scheduled = ScheduledNotification {
            id: id.clone(),
            notification,
            scheduled_at,
            status: ScheduledStatus::Pending,
        };
        
        let mut notifications = self.scheduled_notifications.write().await;
        notifications.insert(id, scheduled);
        
        Ok(())
    }

    // 取消通知
    pub async fn cancel_notification(&self, id: &str) -> Result<(), NotificationError> {
        let mut notifications = self.scheduled_notifications.write().await;
        
        if let Some(scheduled) = notifications.get_mut(id) {
            scheduled.status = ScheduledStatus::Cancelled;
        }
        
        Ok(())
    }

    // 获取调度状态
    pub async fn get_scheduled_status(&self, id: &str) -> Option<ScheduledStatus> {
        let notifications = self.scheduled_notifications.read().await;
        notifications.get(id).map(|s| s.status.clone())
    }
}
```

### 4. 通知历史记录

```rust
pub struct NotificationHistory {
    history_store: Arc<RwLock<Vec<NotificationRecord>>>,
    max_records: usize,
}

#[derive(Debug, Clone)]
pub struct NotificationRecord {
    pub notification: Notification,
    pub results: Vec<NotificationResult>,
    pub recorded_at: DateTime<Utc>,
}

#[derive(Debug, Clone)]
pub struct NotificationResult {
    pub channel: String,
    pub success: bool,
    pub error: Option<String>,
    pub sent_at: DateTime<Utc>,
}

impl NotificationHistory {
    pub fn new() -> Self {
        Self {
            history_store: Arc::new(RwLock::new(Vec::new())),
            max_records: 10000,
        }
    }

    // 记录通知
    pub async fn record_notification(&self, notification: &Notification, results: &[NotificationResult]) {
        let record = NotificationRecord {
            notification: notification.clone(),
            results: results.to_vec(),
            recorded_at: Utc::now(),
        };
        
        let mut history = self.history_store.write().await;
        history.push(record);
        
        // 限制历史记录数量
        if history.len() > self.max_records {
            history.remove(0);
        }
    }

    // 获取通知历史
    pub async fn get_history(&self, limit: Option<usize>) -> Vec<NotificationRecord> {
        let history = self.history_store.read().await;
        let limit = limit.unwrap_or(100);
        
        history.iter()
            .rev()
            .take(limit)
            .cloned()
            .collect()
    }

    // 按类型获取历史
    pub async fn get_history_by_type(&self, notification_type: &NotificationType) -> Vec<NotificationRecord> {
        let history = self.history_store.read().await;
        
        history.iter()
            .filter(|record| record.notification.notification_type == *notification_type)
            .cloned()
            .collect()
    }

    // 按时间范围获取历史
    pub async fn get_history_by_time_range(&self, start: DateTime<Utc>, end: DateTime<Utc>) -> Vec<NotificationRecord> {
        let history = self.history_store.read().await;
        
        history.iter()
            .filter(|record| record.recorded_at >= start && record.recorded_at <= end)
            .cloned()
            .collect()
    }
}
```

### 5. 通知系统API

```rust
#[derive(Deserialize)]
pub struct SendNotificationRequest {
    pub title: String,
    pub message: String,
    pub notification_type: NotificationType,
    pub priority: NotificationPriority,
    pub recipients: Vec<String>,
    pub channels: Vec<String>,
    pub template_id: Option<String>,
    pub data: HashMap<String, String>,
    pub scheduled_at: Option<DateTime<Utc>>,
}

#[derive(Serialize)]
pub struct NotificationResponse {
    pub notification_id: String,
    pub status: NotificationStatus,
    pub results: Vec<NotificationResult>,
}

// 通知系统API路由
pub fn notification_routes() -> Router {
    Router::new()
        .route("/notifications", post(send_notification))
        .route("/notifications", get(list_notifications))
        .route("/notifications/:id", get(get_notification))
        .route("/notifications/schedule", post(schedule_notification))
        .route("/notifications/schedule/:id", delete(cancel_scheduled))
        .route("/templates", post(create_template))
        .route("/templates", get(list_templates))
        .route("/templates/:id", get(get_template))
        .route("/templates/:id", put(update_template))
        .route("/templates/:id", delete(delete_template))
        .route("/history", get(get_history))
        .route("/channels", get(list_channels))
}

async fn send_notification(
    Json(request): Json<SendNotificationRequest>,
    State(notification_system): State<Arc<NotificationSystem>>,
) -> Result<Json<NotificationResponse>, StatusCode> {
    let notification = Notification {
        id: Uuid::new_v4().to_string(),
        title: request.title,
        message: request.message,
        notification_type: request.notification_type,
        priority: request.priority,
        recipients: request.recipients,
        channels: request.channels,
        template_id: request.template_id,
        data: request.data,
        scheduled_at: request.scheduled_at,
        created_at: Utc::now(),
        status: NotificationStatus::Pending,
    };
    
    let results = notification_system.send_notification(notification.clone()).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    let success_count = results.iter().filter(|r| r.success).count();
    let status = if success_count > 0 {
        NotificationStatus::Sent
    } else {
        NotificationStatus::Failed
    };
    
    Ok(Json(NotificationResponse {
        notification_id: notification.id,
        status,
        results,
    }))
}

async fn schedule_notification(
    Json(request): Json<SendNotificationRequest>,
    State(notification_system): State<Arc<NotificationSystem>>,
) -> Result<Json<String>, StatusCode> {
    let scheduled_at = request.scheduled_at
        .ok_or(StatusCode::BAD_REQUEST)?;
    
    let notification = Notification {
        id: Uuid::new_v4().to_string(),
        title: request.title,
        message: request.message,
        notification_type: request.notification_type,
        priority: request.priority,
        recipients: request.recipients,
        channels: request.channels,
        template_id: request.template_id,
        data: request.data,
        scheduled_at: Some(scheduled_at),
        created_at: Utc::now(),
        status: NotificationStatus::Pending,
    };
    
    let scheduled_id = notification_system.schedule_notification(notification, scheduled_at).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(scheduled_id))
}

async fn get_history(
    Query(params): Query<HistoryQuery>,
    State(notification_system): State<Arc<NotificationSystem>>,
) -> Result<Json<Vec<NotificationRecord>>, StatusCode> {
    let history = notification_system.history.get_history(params.limit).await;
    Ok(Json(history))
}
```

## 使用示例

### 1. 发送即时通知

```rust
#[tokio::main]
async fn main() {
    let notification_system = Arc::new(NotificationSystem::new());
    
    // 注册通知渠道
    notification_system.register_channel(
        "email".to_string(),
        Box::new(EmailChannel {
            smtp_config: SmtpConfig {
                host: "smtp.gmail.com".to_string(),
                port: 587,
                username: "your-email@gmail.com".to_string(),
                password: "your-password".to_string(),
                use_tls: true,
                from_address: "your-email@gmail.com".to_string(),
                from_name: "IoT System".to_string(),
            },
            enabled: true,
        }),
    ).await;
    
    // 发送通知
    let notification = Notification {
        id: Uuid::new_v4().to_string(),
        title: "设备告警".to_string(),
        message: "温度传感器温度过高: 35°C".to_string(),
        notification_type: NotificationType::Alert,
        priority: NotificationPriority::High,
        recipients: vec!["admin@example.com".to_string()],
        channels: vec!["email".to_string()],
        template_id: None,
        data: HashMap::new(),
        scheduled_at: None,
        created_at: Utc::now(),
        status: NotificationStatus::Pending,
    };
    
    let results = notification_system.send_notification(notification).await.unwrap();
    
    for result in results {
        if result.success {
            println!("通知发送成功: {}", result.channel);
        } else {
            println!("通知发送失败: {} - {:?}", result.channel, result.error);
        }
    }
}
```

### 2. 使用模板发送通知

```rust
// 创建通知模板
async fn create_notification_template(notification_system: Arc<NotificationSystem>) {
    let template = NotificationTemplate {
        id: "device-alert".to_string(),
        name: "设备告警模板".to_string(),
        description: "设备告警通知模板".to_string(),
        title_template: "设备告警: {device_name}".to_string(),
        message_template: "设备 {device_name} 在 {location} 发生告警: {alert_message}".to_string(),
        channels: vec!["email".to_string(), "sms".to_string()],
        variables: vec!["device_name".to_string(), "location".to_string(), "alert_message".to_string()],
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };
    
    let mut templates = notification_system.templates.write().await;
    templates.insert(template.id.clone(), template);
    
    // 使用模板发送通知
    let notification = Notification {
        id: Uuid::new_v4().to_string(),
        title: "".to_string(), // 将由模板生成
        message: "".to_string(), // 将由模板生成
        notification_type: NotificationType::Alert,
        priority: NotificationPriority::High,
        recipients: vec!["admin@example.com".to_string()],
        channels: vec![],
        template_id: Some("device-alert".to_string()),
        data: HashMap::from([
            ("device_name".to_string(), "温度传感器001".to_string()),
            ("location".to_string(), "车间A".to_string()),
            ("alert_message".to_string(), "温度过高: 35°C".to_string()),
        ]),
        scheduled_at: None,
        created_at: Utc::now(),
        status: NotificationStatus::Pending,
    };
    
    let results = notification_system.send_notification(notification).await.unwrap();
    println!("模板通知发送完成");
}
```

### 3. 调度通知

```rust
// 调度延迟通知
async fn schedule_delayed_notification(notification_system: Arc<NotificationSystem>) {
    let notification = Notification {
        id: Uuid::new_v4().to_string(),
        title: "定时提醒".to_string(),
        message: "请检查设备状态".to_string(),
        notification_type: NotificationType::Info,
        priority: NotificationPriority::Normal,
        recipients: vec!["operator@example.com".to_string()],
        channels: vec!["email".to_string()],
        template_id: None,
        data: HashMap::new(),
        scheduled_at: None,
        created_at: Utc::now(),
        status: NotificationStatus::Pending,
    };
    
    let scheduled_at = Utc::now() + Duration::from_hours(2);
    let scheduled_id = notification_system.schedule_notification(notification, scheduled_at).await.unwrap();
    
    println!("通知已调度: {}", scheduled_id);
}
```

## 核心特性

1. **多渠道支持**: 邮件、短信、Webhook、推送通知等
2. **模板管理**: 支持变量替换的通知模板
3. **通知调度**: 支持延迟发送和定时通知
4. **优先级管理**: 不同优先级的通知处理
5. **历史记录**: 完整的通知发送历史
6. **状态跟踪**: 通知发送状态实时跟踪
7. **错误处理**: 失败重试和错误报告
8. **API接口**: 完整的RESTful API支持

这个物联网通知系统实现提供了全面的通知功能，支持多种通知渠道和灵活的配置选项。
