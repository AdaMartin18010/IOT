# 配置管理实现

## 概述

配置管理系统是IoT系统的核心基础设施，负责管理应用程序的各种配置参数，支持多种配置源、热重载、验证和加密等功能。本文档提供基于Rust和Go的配置管理实现。

## 核心架构

### 1. 配置结构定义

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

/// 数据库配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseConfig {
    pub host: String,
    pub port: u16,
    pub username: String,
    pub password: String,
    pub database: String,
    pub max_connections: u32,
    pub connection_timeout: u64,
}

/// Redis配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RedisConfig {
    pub host: String,
    pub port: u16,
    pub password: Option<String>,
    pub database: u8,
    pub pool_size: u32,
    pub timeout: u64,
}

/// 日志配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogConfig {
    pub level: String,
    pub file_path: Option<PathBuf>,
    pub max_file_size: u64,
    pub max_files: u32,
    pub format: String,
}

/// 安全配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityConfig {
    pub jwt_secret: String,
    pub token_expiry: u64,
    pub encryption_key: String,
    pub allowed_origins: Vec<String>,
}

/// 应用配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    pub name: String,
    pub version: String,
    pub environment: String,
    pub port: u16,
    pub host: String,
    pub database: DatabaseConfig,
    pub redis: RedisConfig,
    pub log: LogConfig,
    pub security: SecurityConfig,
    pub custom: HashMap<String, serde_json::Value>,
}
```

### 2. 配置管理器

```rust
use tokio::sync::RwLock;
use std::sync::Arc;
use std::fs;
use std::time::Duration;
use tokio::time::interval;
use notify::{Watcher, RecursiveMode};

/// 配置源类型
#[derive(Debug, Clone)]
pub enum ConfigSource {
    File(PathBuf),
    Environment,
    Database,
    Remote(String),
}

/// 配置管理器
pub struct ConfigManager {
    config: Arc<RwLock<AppConfig>>,
    sources: Vec<ConfigSource>,
    watchers: Vec<Box<dyn ConfigWatcher>>,
    validators: Vec<Box<dyn ConfigValidator>>,
}

impl ConfigManager {
    pub fn new() -> Self {
        Self {
            config: Arc::new(RwLock::new(AppConfig::default())),
            sources: Vec::new(),
            watchers: Vec::new(),
            validators: Vec::new(),
        }
    }

    /// 添加配置源
    pub fn add_source(&mut self, source: ConfigSource) {
        self.sources.push(source);
    }

    /// 添加配置验证器
    pub fn add_validator(&mut self, validator: Box<dyn ConfigValidator>) {
        self.validators.push(validator);
    }

    /// 添加配置监听器
    pub fn add_watcher(&mut self, watcher: Box<dyn ConfigWatcher>) {
        self.watchers.push(watcher);
    }

    /// 加载配置
    pub async fn load_config(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let mut config = AppConfig::default();

        // 从不同源加载配置
        for source in &self.sources {
            match source {
                ConfigSource::File(path) => {
                    self.load_from_file(&mut config, path).await?;
                }
                ConfigSource::Environment => {
                    self.load_from_environment(&mut config).await?;
                }
                ConfigSource::Database => {
                    self.load_from_database(&mut config).await?;
                }
                ConfigSource::Remote(url) => {
                    self.load_from_remote(&mut config, url).await?;
                }
            }
        }

        // 验证配置
        self.validate_config(&config).await?;

        // 更新配置
        {
            let mut current_config = self.config.write().await;
            *current_config = config;
        }

        // 通知监听器
        self.notify_watchers().await;

        Ok(())
    }

    /// 从文件加载配置
    async fn load_from_file(&self, config: &mut AppConfig, path: &PathBuf) -> Result<(), Box<dyn std::error::Error>> {
        let content = fs::read_to_string(path)?;
        let file_config: AppConfig = serde_json::from_str(&content)?;
        
        // 合并配置
        self.merge_config(config, &file_config);
        Ok(())
    }

    /// 从环境变量加载配置
    async fn load_from_environment(&self, config: &mut AppConfig) -> Result<(), Box<dyn std::error::Error>> {
        if let Ok(port) = std::env::var("APP_PORT") {
            if let Ok(port_num) = port.parse::<u16>() {
                config.port = port_num;
            }
        }

        if let Ok(host) = std::env::var("APP_HOST") {
            config.host = host;
        }

        if let Ok(env) = std::env::var("APP_ENVIRONMENT") {
            config.environment = env;
        }

        // 数据库配置
        if let Ok(db_host) = std::env::var("DB_HOST") {
            config.database.host = db_host;
        }

        if let Ok(db_port) = std::env::var("DB_PORT") {
            if let Ok(port_num) = db_port.parse::<u16>() {
                config.database.port = port_num;
            }
        }

        Ok(())
    }

    /// 从数据库加载配置
    async fn load_from_database(&self, _config: &mut AppConfig) -> Result<(), Box<dyn std::error::Error>> {
        // 实现从数据库加载配置的逻辑
        Ok(())
    }

    /// 从远程服务加载配置
    async fn load_from_remote(&self, _config: &mut AppConfig, _url: &str) -> Result<(), Box<dyn std::error::Error>> {
        // 实现从远程服务加载配置的逻辑
        Ok(())
    }

    /// 合并配置
    fn merge_config(&self, target: &mut AppConfig, source: &AppConfig) {
        // 简单的配置合并逻辑
        if !source.name.is_empty() {
            target.name = source.name.clone();
        }
        if !source.version.is_empty() {
            target.version = source.version.clone();
        }
        if !source.environment.is_empty() {
            target.environment = source.environment.clone();
        }
        if source.port != 0 {
            target.port = source.port;
        }
        if !source.host.is_empty() {
            target.host = source.host.clone();
        }
    }

    /// 验证配置
    async fn validate_config(&self, config: &AppConfig) -> Result<(), Box<dyn std::error::Error>> {
        for validator in &self.validators {
            validator.validate(config).await?;
        }
        Ok(())
    }

    /// 通知配置监听器
    async fn notify_watchers(&self) {
        let config = self.config.read().await;
        for watcher in &self.watchers {
            if let Err(e) = watcher.on_config_changed(&config).await {
                eprintln!("配置监听器通知失败: {}", e);
            }
        }
    }

    /// 获取配置
    pub async fn get_config(&self) -> AppConfig {
        self.config.read().await.clone()
    }

    /// 更新配置
    pub async fn update_config(&self, new_config: AppConfig) -> Result<(), Box<dyn std::error::Error>> {
        // 验证新配置
        self.validate_config(&new_config).await?;

        // 更新配置
        {
            let mut config = self.config.write().await;
            *config = new_config;
        }

        // 通知监听器
        self.notify_watchers().await;

        Ok(())
    }

    /// 启动配置热重载
    pub async fn start_hot_reload(&self) -> Result<(), Box<dyn std::error::Error>> {
        let config_manager = Arc::new(self.clone());
        
        tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(30));
            loop {
                interval.tick().await;
                if let Err(e) = config_manager.reload_config().await {
                    eprintln!("配置热重载失败: {}", e);
                }
            }
        });

        Ok(())
    }

    /// 重新加载配置
    async fn reload_config(&self) -> Result<(), Box<dyn std::error::Error>> {
        // 实现配置重新加载逻辑
        Ok(())
    }
}

impl Clone for ConfigManager {
    fn clone(&self) -> Self {
        Self {
            config: Arc::clone(&self.config),
            sources: self.sources.clone(),
            watchers: Vec::new(), // 监听器不克隆
            validators: Vec::new(), // 验证器不克隆
        }
    }
}
```

### 3. 配置验证器接口

```rust
use async_trait::async_trait;

/// 配置验证器接口
#[async_trait]
pub trait ConfigValidator: Send + Sync {
    async fn validate(&self, config: &AppConfig) -> Result<(), Box<dyn std::error::Error>>;
    fn get_name(&self) -> &str;
}

/// 数据库配置验证器
pub struct DatabaseConfigValidator;

#[async_trait]
impl ConfigValidator for DatabaseConfigValidator {
    async fn validate(&self, config: &AppConfig) -> Result<(), Box<dyn std::error::Error>> {
        let db_config = &config.database;
        
        if db_config.host.is_empty() {
            return Err("数据库主机不能为空".into());
        }
        
        if db_config.port == 0 {
            return Err("数据库端口不能为0".into());
        }
        
        if db_config.username.is_empty() {
            return Err("数据库用户名不能为空".into());
        }
        
        if db_config.max_connections == 0 {
            return Err("数据库最大连接数不能为0".into());
        }
        
        Ok(())
    }

    fn get_name(&self) -> &str {
        "database_validator"
    }
}

/// 安全配置验证器
pub struct SecurityConfigValidator;

#[async_trait]
impl ConfigValidator for SecurityConfigValidator {
    async fn validate(&self, config: &AppConfig) -> Result<(), Box<dyn std::error::Error>> {
        let security_config = &config.security;
        
        if security_config.jwt_secret.is_empty() {
            return Err("JWT密钥不能为空".into());
        }
        
        if security_config.jwt_secret.len() < 32 {
            return Err("JWT密钥长度至少32位".into());
        }
        
        if security_config.token_expiry == 0 {
            return Err("Token过期时间不能为0".into());
        }
        
        Ok(())
    }

    fn get_name(&self) -> &str {
        "security_validator"
    }
}
```

### 4. 配置监听器接口

```rust
/// 配置监听器接口
#[async_trait]
pub trait ConfigWatcher: Send + Sync {
    async fn on_config_changed(&self, config: &AppConfig) -> Result<(), Box<dyn std::error::Error>>;
    fn get_name(&self) -> &str;
}

/// 日志配置监听器
pub struct LogConfigWatcher;

#[async_trait]
impl ConfigWatcher for LogConfigWatcher {
    async fn on_config_changed(&self, config: &AppConfig) -> Result<(), Box<dyn std::error::Error>> {
        println!("日志配置已更新: {:?}", config.log);
        // 重新初始化日志系统
        Ok(())
    }

    fn get_name(&self) -> &str {
        "log_watcher"
    }
}

/// 数据库配置监听器
pub struct DatabaseConfigWatcher;

#[async_trait]
impl ConfigWatcher for DatabaseConfigWatcher {
    async fn on_config_changed(&self, config: &AppConfig) -> Result<(), Box<dyn std::error::Error>> {
        println!("数据库配置已更新: {:?}", config.database);
        // 重新初始化数据库连接池
        Ok(())
    }

    fn get_name(&self) -> &str {
        "database_watcher"
    }
}
```

## Go实现

### 1. 配置结构定义

```go
package config

import (
    "encoding/json"
    "os"
    "path/filepath"
    "strconv"
    "time"
)

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
    Host              string `json:"host"`
    Port              uint16 `json:"port"`
    Username          string `json:"username"`
    Password          string `json:"password"`
    Database          string `json:"database"`
    MaxConnections    uint32 `json:"max_connections"`
    ConnectionTimeout uint64 `json:"connection_timeout"`
}

// RedisConfig Redis配置
type RedisConfig struct {
    Host       string `json:"host"`
    Port       uint16 `json:"port"`
    Password   string `json:"password,omitempty"`
    Database   uint8  `json:"database"`
    PoolSize   uint32 `json:"pool_size"`
    Timeout    uint64 `json:"timeout"`
}

// LogConfig 日志配置
type LogConfig struct {
    Level        string `json:"level"`
    FilePath     string `json:"file_path,omitempty"`
    MaxFileSize  uint64 `json:"max_file_size"`
    MaxFiles     uint32 `json:"max_files"`
    Format       string `json:"format"`
}

// SecurityConfig 安全配置
type SecurityConfig struct {
    JWTSecret       string   `json:"jwt_secret"`
    TokenExpiry     uint64   `json:"token_expiry"`
    EncryptionKey   string   `json:"encryption_key"`
    AllowedOrigins  []string `json:"allowed_origins"`
}

// AppConfig 应用配置
type AppConfig struct {
    Name        string                 `json:"name"`
    Version     string                 `json:"version"`
    Environment string                 `json:"environment"`
    Port        uint16                 `json:"port"`
    Host        string                 `json:"host"`
    Database    DatabaseConfig         `json:"database"`
    Redis       RedisConfig            `json:"redis"`
    Log         LogConfig              `json:"log"`
    Security    SecurityConfig         `json:"security"`
    Custom      map[string]interface{} `json:"custom"`
}

// ConfigSource 配置源类型
type ConfigSource struct {
    Type string
    Path string
    URL  string
}
```

### 2. 配置管理器

```go
import (
    "fmt"
    "io/ioutil"
    "sync"
    "time"
)

// ConfigManager 配置管理器
type ConfigManager struct {
    config     *AppConfig
    sources    []ConfigSource
    watchers   []ConfigWatcher
    validators []ConfigValidator
    mu         sync.RWMutex
}

// NewConfigManager 创建配置管理器
func NewConfigManager() *ConfigManager {
    return &ConfigManager{
        config:     &AppConfig{},
        sources:    make([]ConfigSource, 0),
        watchers:   make([]ConfigWatcher, 0),
        validators: make([]ConfigValidator, 0),
    }
}

// AddSource 添加配置源
func (cm *ConfigManager) AddSource(source ConfigSource) {
    cm.mu.Lock()
    defer cm.mu.Unlock()
    cm.sources = append(cm.sources, source)
}

// AddValidator 添加配置验证器
func (cm *ConfigManager) AddValidator(validator ConfigValidator) {
    cm.mu.Lock()
    defer cm.mu.Unlock()
    cm.validators = append(cm.validators, validator)
}

// AddWatcher 添加配置监听器
func (cm *ConfigManager) AddWatcher(watcher ConfigWatcher) {
    cm.mu.Lock()
    defer cm.mu.Unlock()
    cm.watchers = append(cm.watchers, watcher)
}

// LoadConfig 加载配置
func (cm *ConfigManager) LoadConfig() error {
    cm.mu.Lock()
    defer cm.mu.Unlock()

    config := &AppConfig{}

    // 从不同源加载配置
    for _, source := range cm.sources {
        switch source.Type {
        case "file":
            if err := cm.loadFromFile(config, source.Path); err != nil {
                return fmt.Errorf("从文件加载配置失败: %w", err)
            }
        case "environment":
            if err := cm.loadFromEnvironment(config); err != nil {
                return fmt.Errorf("从环境变量加载配置失败: %w", err)
            }
        case "database":
            if err := cm.loadFromDatabase(config); err != nil {
                return fmt.Errorf("从数据库加载配置失败: %w", err)
            }
        case "remote":
            if err := cm.loadFromRemote(config, source.URL); err != nil {
                return fmt.Errorf("从远程服务加载配置失败: %w", err)
            }
        }
    }

    // 验证配置
    if err := cm.validateConfig(config); err != nil {
        return fmt.Errorf("配置验证失败: %w", err)
    }

    // 更新配置
    cm.config = config

    // 通知监听器
    cm.notifyWatchers()

    return nil
}

// loadFromFile 从文件加载配置
func (cm *ConfigManager) loadFromFile(config *AppConfig, path string) error {
    data, err := ioutil.ReadFile(path)
    if err != nil {
        return err
    }

    fileConfig := &AppConfig{}
    if err := json.Unmarshal(data, fileConfig); err != nil {
        return err
    }

    // 合并配置
    cm.mergeConfig(config, fileConfig)
    return nil
}

// loadFromEnvironment 从环境变量加载配置
func (cm *ConfigManager) loadFromEnvironment(config *AppConfig) error {
    if port := os.Getenv("APP_PORT"); port != "" {
        if portNum, err := strconv.ParseUint(port, 10, 16); err == nil {
            config.Port = uint16(portNum)
        }
    }

    if host := os.Getenv("APP_HOST"); host != "" {
        config.Host = host
    }

    if env := os.Getenv("APP_ENVIRONMENT"); env != "" {
        config.Environment = env
    }

    // 数据库配置
    if dbHost := os.Getenv("DB_HOST"); dbHost != "" {
        config.Database.Host = dbHost
    }

    if dbPort := os.Getenv("DB_PORT"); dbPort != "" {
        if portNum, err := strconv.ParseUint(dbPort, 10, 16); err == nil {
            config.Database.Port = uint16(portNum)
        }
    }

    return nil
}

// loadFromDatabase 从数据库加载配置
func (cm *ConfigManager) loadFromDatabase(config *AppConfig) error {
    // 实现从数据库加载配置的逻辑
    return nil
}

// loadFromRemote 从远程服务加载配置
func (cm *ConfigManager) loadFromRemote(config *AppConfig, url string) error {
    // 实现从远程服务加载配置的逻辑
    return nil
}

// mergeConfig 合并配置
func (cm *ConfigManager) mergeConfig(target, source *AppConfig) {
    if source.Name != "" {
        target.Name = source.Name
    }
    if source.Version != "" {
        target.Version = source.Version
    }
    if source.Environment != "" {
        target.Environment = source.Environment
    }
    if source.Port != 0 {
        target.Port = source.Port
    }
    if source.Host != "" {
        target.Host = source.Host
    }
}

// validateConfig 验证配置
func (cm *ConfigManager) validateConfig(config *AppConfig) error {
    for _, validator := range cm.validators {
        if err := validator.Validate(config); err != nil {
            return err
        }
    }
    return nil
}

// notifyWatchers 通知配置监听器
func (cm *ConfigManager) notifyWatchers() {
    for _, watcher := range cm.watchers {
        if err := watcher.OnConfigChanged(cm.config); err != nil {
            fmt.Printf("配置监听器通知失败: %v\n", err)
        }
    }
}

// GetConfig 获取配置
func (cm *ConfigManager) GetConfig() *AppConfig {
    cm.mu.RLock()
    defer cm.mu.RUnlock()
    return cm.config
}

// UpdateConfig 更新配置
func (cm *ConfigManager) UpdateConfig(newConfig *AppConfig) error {
    cm.mu.Lock()
    defer cm.mu.Unlock()

    // 验证新配置
    if err := cm.validateConfig(newConfig); err != nil {
        return fmt.Errorf("配置验证失败: %w", err)
    }

    // 更新配置
    cm.config = newConfig

    // 通知监听器
    cm.notifyWatchers()

    return nil
}

// StartHotReload 启动配置热重载
func (cm *ConfigManager) StartHotReload() {
    go func() {
        ticker := time.NewTicker(30 * time.Second)
        defer ticker.Stop()

        for range ticker.C {
            if err := cm.LoadConfig(); err != nil {
                fmt.Printf("配置热重载失败: %v\n", err)
            }
        }
    }()
}
```

### 3. 配置验证器接口

```go
// ConfigValidator 配置验证器接口
type ConfigValidator interface {
    Validate(config *AppConfig) error
    GetName() string
}

// DatabaseConfigValidator 数据库配置验证器
type DatabaseConfigValidator struct{}

func (v *DatabaseConfigValidator) Validate(config *AppConfig) error {
    dbConfig := &config.Database

    if dbConfig.Host == "" {
        return fmt.Errorf("数据库主机不能为空")
    }

    if dbConfig.Port == 0 {
        return fmt.Errorf("数据库端口不能为0")
    }

    if dbConfig.Username == "" {
        return fmt.Errorf("数据库用户名不能为空")
    }

    if dbConfig.MaxConnections == 0 {
        return fmt.Errorf("数据库最大连接数不能为0")
    }

    return nil
}

func (v *DatabaseConfigValidator) GetName() string {
    return "database_validator"
}

// SecurityConfigValidator 安全配置验证器
type SecurityConfigValidator struct{}

func (v *SecurityConfigValidator) Validate(config *AppConfig) error {
    securityConfig := &config.Security

    if securityConfig.JWTSecret == "" {
        return fmt.Errorf("JWT密钥不能为空")
    }

    if len(securityConfig.JWTSecret) < 32 {
        return fmt.Errorf("JWT密钥长度至少32位")
    }

    if securityConfig.TokenExpiry == 0 {
        return fmt.Errorf("Token过期时间不能为0")
    }

    return nil
}

func (v *SecurityConfigValidator) GetName() string {
    return "security_validator"
}
```

### 4. 配置监听器接口

```go
// ConfigWatcher 配置监听器接口
type ConfigWatcher interface {
    OnConfigChanged(config *AppConfig) error
    GetName() string
}

// LogConfigWatcher 日志配置监听器
type LogConfigWatcher struct{}

func (w *LogConfigWatcher) OnConfigChanged(config *AppConfig) error {
    fmt.Printf("日志配置已更新: %+v\n", config.Log)
    // 重新初始化日志系统
    return nil
}

func (w *LogConfigWatcher) GetName() string {
    return "log_watcher"
}

// DatabaseConfigWatcher 数据库配置监听器
type DatabaseConfigWatcher struct{}

func (w *DatabaseConfigWatcher) OnConfigChanged(config *AppConfig) error {
    fmt.Printf("数据库配置已更新: %+v\n", config.Database)
    // 重新初始化数据库连接池
    return nil
}

func (w *DatabaseConfigWatcher) GetName() string {
    return "database_watcher"
}
```

## 使用示例

### Rust示例

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建配置管理器
    let mut config_manager = ConfigManager::new();
    
    // 添加配置源
    config_manager.add_source(ConfigSource::File(PathBuf::from("config.json")));
    config_manager.add_source(ConfigSource::Environment);
    
    // 添加验证器
    config_manager.add_validator(Box::new(DatabaseConfigValidator));
    config_manager.add_validator(Box::new(SecurityConfigValidator));
    
    // 添加监听器
    config_manager.add_watcher(Box::new(LogConfigWatcher));
    config_manager.add_watcher(Box::new(DatabaseConfigWatcher));
    
    // 加载配置
    config_manager.load_config().await?;
    
    // 启动热重载
    config_manager.start_hot_reload().await?;
    
    // 获取配置
    let config = config_manager.get_config().await;
    println!("应用配置: {:?}", config);
    
    Ok(())
}
```

### Go示例

```go
func main() {
    // 创建配置管理器
    configManager := NewConfigManager()
    
    // 添加配置源
    configManager.AddSource(ConfigSource{
        Type: "file",
        Path: "config.json",
    })
    configManager.AddSource(ConfigSource{
        Type: "environment",
    })
    
    // 添加验证器
    configManager.AddValidator(&DatabaseConfigValidator{})
    configManager.AddValidator(&SecurityConfigValidator{})
    
    // 添加监听器
    configManager.AddWatcher(&LogConfigWatcher{})
    configManager.AddWatcher(&DatabaseConfigWatcher{})
    
    // 加载配置
    if err := configManager.LoadConfig(); err != nil {
        log.Fatal(err)
    }
    
    // 启动热重载
    configManager.StartHotReload()
    
    // 获取配置
    config := configManager.GetConfig()
    fmt.Printf("应用配置: %+v\n", config)
    
    // 保持程序运行
    select {}
}
```

## 总结

配置管理系统提供了：

1. **多源配置支持**：文件、环境变量、数据库、远程服务
2. **配置验证**：类型安全的数据验证
3. **热重载**：运行时配置更新
4. **监听机制**：配置变更通知
5. **配置合并**：多源配置优先级处理
6. **类型安全**：强类型配置结构
7. **跨语言支持**：Rust和Go双语言实现

这个实现为IoT系统提供了灵活、可靠的配置管理基础，支持复杂的配置需求和运行时配置更新。
