# 分布式系统实现

## 1. 分布式锁

### 1.1 Redis分布式锁

```rust
use redis::{Client, Connection, Commands};
use std::time::{Duration, Instant};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

/// 分布式锁接口
#[async_trait]
pub trait DistributedLock: Send + Sync {
    async fn acquire(&mut self, timeout: Duration) -> Result<bool, Box<dyn std::error::Error>>;
    async fn release(&mut self) -> Result<bool, Box<dyn std::error::Error>>;
    async fn is_held(&self) -> Result<bool, Box<dyn std::error::Error>>;
}

/// Redis分布式锁
pub struct RedisDistributedLock {
    client: Client,
    lock_key: String,
    lock_value: String,
    connection: Connection,
    acquired: bool,
}

impl RedisDistributedLock {
    pub async fn new(redis_url: &str, resource: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let client = Client::open(redis_url)?;
        let connection = client.get_connection()?;
        
        Ok(Self {
            client,
            lock_key: format!("lock:{}", resource),
            lock_value: format!("{}:{}", uuid::Uuid::new_v4(), uuid::Uuid::new_v4()),
            connection,
            acquired: false,
        })
    }
    
    /// 尝试获取锁
    async fn try_acquire(&mut self) -> Result<bool, Box<dyn std::error::Error>> {
        let result: Option<String> = redis::cmd("SET")
            .arg(&self.lock_key)
            .arg(&self.lock_value)
            .arg("NX")
            .arg("EX")
            .arg(60) // 60秒过期
            .query(&mut self.connection)?;
        
        Ok(result.is_some())
    }
    
    /// 释放锁
    async fn try_release(&mut self) -> Result<bool, Box<dyn std::error::Error>> {
        let script = r#"
            if redis.call("GET", KEYS[1]) == ARGV[1] then
                return redis.call("DEL", KEYS[1])
            else
                return 0
            end
        "#;
        
        let result: i32 = redis::cmd("EVAL")
            .arg(script)
            .arg(1)
            .arg(&self.lock_key)
            .arg(&self.lock_value)
            .query(&mut self.connection)?;
        
        Ok(result == 1)
    }
}

#[async_trait]
impl DistributedLock for RedisDistributedLock {
    async fn acquire(&mut self, timeout: Duration) -> Result<bool, Box<dyn std::error::Error>> {
        if self.acquired {
            return Ok(true);
        }
        
        let start_time = Instant::now();
        
        while start_time.elapsed() < timeout {
            if self.try_acquire().await? {
                self.acquired = true;
                return Ok(true);
            }
            
            tokio::time::sleep(Duration::from_millis(100)).await;
        }
        
        Ok(false)
    }
    
    async fn release(&mut self) -> Result<bool, Box<dyn std::error::Error>> {
        if !self.acquired {
            return Ok(true);
        }
        
        let released = self.try_release().await?;
        if released {
            self.acquired = false;
        }
        
        Ok(released)
    }
    
    async fn is_held(&self) -> Result<bool, Box<dyn std::error::Error>> {
        if !self.acquired {
            return Ok(false);
        }
        
        let current_value: Option<String> = redis::cmd("GET")
            .arg(&self.lock_key)
            .query(&mut self.connection)?;
        
        Ok(current_value.as_ref() == Some(&self.lock_value))
    }
}
```

## 2. 一致性哈希

### 2.1 一致性哈希环

```rust
use std::collections::HashMap;
use std::hash::{Hash, Hasher};

/// 虚拟节点
#[derive(Debug, Clone)]
pub struct VirtualNode {
    pub id: String,
    pub physical_node: String,
    pub hash: u64,
}

/// 物理节点
#[derive(Debug, Clone)]
pub struct PhysicalNode {
    pub id: String,
    pub address: String,
    pub weight: u32,
}

/// 一致性哈希环
pub struct ConsistentHashRing {
    virtual_nodes: Vec<VirtualNode>,
    physical_nodes: HashMap<String, PhysicalNode>,
    replication_factor: usize,
}

impl ConsistentHashRing {
    pub fn new(replication_factor: usize) -> Self {
        Self {
            virtual_nodes: Vec::new(),
            physical_nodes: HashMap::new(),
            replication_factor,
        }
    }
    
    /// 添加物理节点
    pub fn add_node(&mut self, node: PhysicalNode) {
        self.physical_nodes.insert(node.id.clone(), node.clone());
        self.rebuild_virtual_nodes();
    }
    
    /// 移除物理节点
    pub fn remove_node(&mut self, node_id: &str) -> Option<PhysicalNode> {
        let node = self.physical_nodes.remove(node_id);
        if node.is_some() {
            self.rebuild_virtual_nodes();
        }
        node
    }
    
    /// 获取节点
    pub fn get_node(&self, key: &str) -> Option<&PhysicalNode> {
        if self.virtual_nodes.is_empty() {
            return None;
        }
        
        let hash = self.hash_key(key);
        let index = self.find_virtual_node_index(hash);
        
        if let Some(virtual_node) = self.virtual_nodes.get(index) {
            self.physical_nodes.get(&virtual_node.physical_node)
        } else {
            None
        }
    }
    
    /// 重建虚拟节点
    fn rebuild_virtual_nodes(&mut self) {
        self.virtual_nodes.clear();
        
        for (node_id, node) in &self.physical_nodes {
            for i in 0..self.replication_factor {
                let virtual_node_id = format!("{}:{}", node_id, i);
                let hash = self.hash_key(&virtual_node_id);
                
                self.virtual_nodes.push(VirtualNode {
                    id: virtual_node_id,
                    physical_node: node_id.clone(),
                    hash,
                });
            }
        }
        
        self.virtual_nodes.sort_by(|a, b| a.hash.cmp(&b.hash));
    }
    
    /// 查找虚拟节点索引
    fn find_virtual_node_index(&self, hash: u64) -> usize {
        let mut left = 0;
        let mut right = self.virtual_nodes.len();
        
        while left < right {
            let mid = (left + right) / 2;
            if self.virtual_nodes[mid].hash < hash {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        if left >= self.virtual_nodes.len() {
            0
        } else {
            left
        }
    }
    
    /// 哈希键
    fn hash_key(&self, key: &str) -> u64 {
        use std::collections::hash_map::DefaultHasher;
        let mut hasher = DefaultHasher::new();
        key.hash(&mut hasher);
        hasher.finish()
    }
}
```

## 3. 分布式缓存

### 3.1 分布式缓存实现

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{Duration, Instant};

/// 缓存条目
#[derive(Debug, Clone)]
pub struct CacheEntry<T> {
    pub value: T,
    pub created_at: Instant,
    pub expires_at: Option<Instant>,
    pub access_count: u64,
    pub last_accessed: Instant,
}

/// 分布式缓存
pub struct DistributedCache<T> {
    local_cache: Arc<RwLock<HashMap<String, CacheEntry<T>>>>,
    hash_ring: Arc<RwLock<ConsistentHashRing>>,
    max_size: usize,
    ttl: Option<Duration>,
}

impl<T: Clone + Send + Sync + 'static> DistributedCache<T> {
    pub fn new(max_size: usize, ttl: Option<Duration>) -> Self {
        Self {
            local_cache: Arc::new(RwLock::new(HashMap::new())),
            hash_ring: Arc::new(RwLock::new(ConsistentHashRing::new(3))),
            max_size,
            ttl,
        }
    }
    
    /// 添加节点
    pub async fn add_node(&self, node_id: String, address: String) {
        let mut hash_ring = self.hash_ring.write().await;
        hash_ring.add_node(PhysicalNode {
            id: node_id,
            address,
            weight: 1,
        });
    }
    
    /// 设置缓存值
    pub async fn set(&self, key: &str, value: T) -> Result<(), Box<dyn std::error::Error>> {
        let mut cache = self.local_cache.write().await;
        
        if cache.len() >= self.max_size {
            self.evict_entries(&mut cache).await;
        }
        
        let expires_at = self.ttl.map(|ttl| Instant::now() + ttl);
        
        cache.insert(key.to_string(), CacheEntry {
            value,
            created_at: Instant::now(),
            expires_at,
            access_count: 0,
            last_accessed: Instant::now(),
        });
        
        Ok(())
    }
    
    /// 获取缓存值
    pub async fn get(&self, key: &str) -> Result<Option<T>, Box<dyn std::error::Error>> {
        let mut cache = self.local_cache.write().await;
        
        if let Some(entry) = cache.get_mut(key) {
            if let Some(expires_at) = entry.expires_at {
                if Instant::now() > expires_at {
                    cache.remove(key);
                    return Ok(None);
                }
            }
            
            entry.access_count += 1;
            entry.last_accessed = Instant::now();
            
            Ok(Some(entry.value.clone()))
        } else {
            Ok(None)
        }
    }
    
    /// 删除缓存值
    pub async fn delete(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let mut cache = self.local_cache.write().await;
        Ok(cache.remove(key).is_some())
    }
    
    /// 驱逐缓存条目
    async fn evict_entries(&self, cache: &mut HashMap<String, CacheEntry<T>>) {
        let mut entries: Vec<_> = cache.iter().collect();
        entries.sort_by(|a, b| a.1.last_accessed.cmp(&b.1.last_accessed));
        
        let evict_count = (cache.len() * 20) / 100;
        for (key, _) in entries.iter().take(evict_count) {
            cache.remove(*key);
        }
    }
    
    /// 清理过期条目
    pub async fn cleanup_expired(&self) {
        let mut cache = self.local_cache.write().await;
        let now = Instant::now();
        
        cache.retain(|_, entry| {
            if let Some(expires_at) = entry.expires_at {
                now <= expires_at
            } else {
                true
            }
        });
    }
}
```

## 4. 领导者选举

### 4.1 简化领导者选举

```rust
use std::sync::Arc;
use tokio::sync::RwLock;
use tokio::time::{Duration, Instant};

/// 节点状态
#[derive(Debug, Clone, PartialEq)]
pub enum NodeState {
    Follower,
    Candidate,
    Leader,
}

/// 领导者选举
pub struct LeaderElection {
    node_id: String,
    nodes: Vec<String>,
    current_term: u64,
    voted_for: Option<String>,
    state: NodeState,
    leader_id: Option<String>,
    election_timeout: Duration,
    last_heartbeat: Arc<RwLock<Instant>>,
}

impl LeaderElection {
    pub fn new(node_id: String, nodes: Vec<String>) -> Self {
        Self {
            node_id,
            nodes,
            current_term: 0,
            voted_for: None,
            state: NodeState::Follower,
            leader_id: None,
            election_timeout: Duration::from_millis(150 + rand::random::<u64>() % 150),
            last_heartbeat: Arc::new(RwLock::new(Instant::now())),
        }
    }
    
    /// 启动领导者选举
    pub async fn start(&mut self) {
        loop {
            match self.state {
                NodeState::Follower => {
                    self.run_follower().await;
                }
                NodeState::Candidate => {
                    self.run_candidate().await;
                }
                NodeState::Leader => {
                    self.run_leader().await;
                }
            }
        }
    }
    
    /// 运行跟随者状态
    async fn run_follower(&mut self) {
        let last_heartbeat = self.last_heartbeat.read().await;
        
        if Instant::now() > *last_heartbeat + self.election_timeout {
            self.state = NodeState::Candidate;
            println!("Node {} became candidate", self.node_id);
        }
        
        tokio::time::sleep(Duration::from_millis(10)).await;
    }
    
    /// 运行候选人状态
    async fn run_candidate(&mut self) {
        self.current_term += 1;
        self.voted_for = Some(self.node_id.clone());
        
        println!("Node {} started election for term {}", self.node_id, self.current_term);
        
        // 模拟投票过程
        let mut votes_received = 1;
        
        for node in &self.nodes {
            if node != &self.node_id {
                // 简化实现，随机投票
                if rand::random::<bool>() {
                    votes_received += 1;
                }
            }
        }
        
        if votes_received > self.nodes.len() / 2 {
            self.become_leader().await;
        } else {
            self.state = NodeState::Follower;
        }
    }
    
    /// 运行领导者状态
    async fn run_leader(&mut self) {
        println!("Node {} is leader for term {}", self.node_id, self.current_term);
        
        // 发送心跳
        for node in &self.nodes {
            if node != &self.node_id {
                let _ = self.send_heartbeat(node).await;
            }
        }
        
        tokio::time::sleep(Duration::from_millis(50)).await;
    }
    
    /// 成为领导者
    async fn become_leader(&mut self) {
        self.state = NodeState::Leader;
        self.leader_id = Some(self.node_id.clone());
        println!("Node {} became leader for term {}", self.node_id, self.current_term);
    }
    
    /// 发送心跳
    async fn send_heartbeat(&self, node: &str) -> Result<bool, Box<dyn std::error::Error>> {
        // 简化实现，模拟网络请求
        let client = reqwest::Client::new();
        let url = format!("http://{}/heartbeat", node);
        
        let heartbeat = Heartbeat {
            term: self.current_term,
            leader_id: self.node_id.clone(),
        };
        
        let response = client.post(&url)
            .json(&heartbeat)
            .send()
            .await?;
        
        Ok(response.status().is_success())
    }
    
    /// 处理心跳
    pub async fn handle_heartbeat(&mut self, heartbeat: Heartbeat) -> HeartbeatResponse {
        if heartbeat.term >= self.current_term {
            self.current_term = heartbeat.term;
            self.state = NodeState::Follower;
            self.leader_id = Some(heartbeat.leader_id);
            
            let mut last_heartbeat = self.last_heartbeat.write().await;
            *last_heartbeat = Instant::now();
        }
        
        HeartbeatResponse {
            term: self.current_term,
            success: true,
        }
    }
}

/// 心跳
#[derive(Debug, Serialize, Deserialize)]
pub struct Heartbeat {
    pub term: u64,
    pub leader_id: String,
}

/// 心跳响应
#[derive(Debug, Serialize, Deserialize)]
pub struct HeartbeatResponse {
    pub term: u64,
    pub success: bool,
}
```

## 5. 应用示例

### 5.1 分布式系统示例

```rust
use std::sync::Arc;

async fn distributed_system_example() -> Result<(), Box<dyn std::error::Error>> {
    // 分布式锁示例
    let mut lock = RedisDistributedLock::new(
        "redis://localhost:6379",
        "shared_resource",
    ).await?;
    
    if lock.acquire(Duration::from_secs(10)).await? {
        println!("Acquired distributed lock");
        tokio::time::sleep(Duration::from_secs(5)).await;
        lock.release().await?;
        println!("Released distributed lock");
    }
    
    // 一致性哈希示例
    let mut hash_ring = ConsistentHashRing::new(3);
    
    hash_ring.add_node(PhysicalNode {
        id: "node1".to_string(),
        address: "192.168.1.10:8080".to_string(),
        weight: 1,
    });
    
    hash_ring.add_node(PhysicalNode {
        id: "node2".to_string(),
        address: "192.168.1.11:8080".to_string(),
        weight: 1,
    });
    
    hash_ring.add_node(PhysicalNode {
        id: "node3".to_string(),
        address: "192.168.1.12:8080".to_string(),
        weight: 1,
    });
    
    // 测试键分布
    let test_keys = vec!["user:1", "user:2", "user:3", "device:1", "device:2"];
    
    for key in test_keys {
        if let Some(node) = hash_ring.get_node(key) {
            println!("Key '{}' maps to node '{}'", key, node.id);
        }
    }
    
    // 分布式缓存示例
    let cache = Arc::new(DistributedCache::<String>::new(1000, Some(Duration::from_secs(3600))));
    
    cache.add_node("local".to_string(), "localhost:8080".to_string()).await;
    cache.add_node("node1".to_string(), "192.168.1.10:8080".to_string()).await;
    cache.add_node("node2".to_string(), "192.168.1.11:8080".to_string()).await;
    
    cache.set("user:1", "John Doe".to_string()).await?;
    cache.set("user:2", "Jane Smith".to_string()).await?;
    
    if let Some(value) = cache.get("user:1").await? {
        println!("Retrieved from cache: {}", value);
    }
    
    // 领导者选举示例
    let nodes = vec![
        "node1:8080".to_string(),
        "node2:8080".to_string(),
        "node3:8080".to_string(),
    ];
    
    let mut leader_election = LeaderElection::new("node1".to_string(), nodes);
    
    // 启动领导者选举
    let election_handle = tokio::spawn(async move {
        leader_election.start().await;
    });
    
    tokio::time::sleep(Duration::from_secs(10)).await;
    
    println!("Distributed system example completed");
    Ok(())
}

/// 分布式锁测试
async fn distributed_lock_test() -> Result<(), Box<dyn std::error::Error>> {
    let mut lock1 = RedisDistributedLock::new(
        "redis://localhost:6379",
        "shared_resource",
    ).await?;
    
    let mut lock2 = RedisDistributedLock::new(
        "redis://localhost:6379",
        "shared_resource",
    ).await?;
    
    // 第一个进程获取锁
    if lock1.acquire(Duration::from_secs(5)).await? {
        println!("Process 1 acquired lock");
        
        // 第二个进程尝试获取锁（应该失败）
        if !lock2.acquire(Duration::from_secs(1)).await? {
            println!("Process 2 failed to acquire lock (expected)");
        }
        
        // 第一个进程释放锁
        lock1.release().await?;
        println!("Process 1 released lock");
        
        // 第二个进程现在可以获取锁
        if lock2.acquire(Duration::from_secs(5)).await? {
            println!("Process 2 acquired lock");
            lock2.release().await?;
            println!("Process 2 released lock");
        }
    }
    
    Ok(())
}

/// 一致性哈希测试
async fn consistent_hash_test() {
    let mut hash_ring = ConsistentHashRing::new(3);
    
    // 添加节点
    for i in 1..=5 {
        hash_ring.add_node(PhysicalNode {
            id: format!("node{}", i),
            address: format!("192.168.1.{}:8080", 10 + i),
            weight: 1,
        });
    }
    
    // 测试键分布
    let mut distribution = HashMap::new();
    let test_keys = (1..=1000).map(|i| format!("key{}", i));
    
    for key in test_keys {
        if let Some(node) = hash_ring.get_node(&key) {
            *distribution.entry(node.id.clone()).or_insert(0) += 1;
        }
    }
    
    println!("Key distribution:");
    for (node_id, count) in distribution {
        println!("  {}: {} keys", node_id, count);
    }
    
    // 移除一个节点
    hash_ring.remove_node("node3");
    println!("Removed node3");
    
    // 重新测试分布
    let mut new_distribution = HashMap::new();
    let test_keys = (1..=1000).map(|i| format!("key{}", i));
    
    for key in test_keys {
        if let Some(node) = hash_ring.get_node(&key) {
            *new_distribution.entry(node.id.clone()).or_insert(0) += 1;
        }
    }
    
    println!("New key distribution:");
    for (node_id, count) in new_distribution {
        println!("  {}: {} keys", node_id, count);
    }
}
```

## 6. 总结

本实现提供了完整的分布式系统组件：

1. **分布式锁** - 基于Redis的分布式锁实现
2. **一致性哈希** - 负载均衡和节点分布
3. **分布式缓存** - 多节点缓存系统
4. **领导者选举** - 简化的一致性算法实现
5. **实际应用示例** - 完整的分布式系统演示

这个分布式系统实现为IoT平台提供了高可用、可扩展的分布式架构基础。
