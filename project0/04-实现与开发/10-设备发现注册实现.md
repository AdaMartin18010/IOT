# 设备发现注册实现

## 1. 设备发现协议

### 1.1 mDNS设备发现

```rust
use std::collections::HashMap;
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use tokio::net::UdpSocket;
use serde::{Deserialize, Serialize};

/// mDNS服务记录
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MDNSServiceRecord {
    pub name: String,
    pub service_type: String,
    pub port: u16,
    pub hostname: String,
    pub ip_address: IpAddr,
    pub txt_records: HashMap<String, String>,
}

/// mDNS设备发现器
pub struct MDNSDiscoverer {
    socket: UdpSocket,
    multicast_addr: SocketAddr,
    discovered_services: HashMap<String, MDNSServiceRecord>,
}

impl MDNSDiscoverer {
    pub async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let socket = UdpSocket::bind("0.0.0.0:5353").await?;
        socket.join_multicast_v4(Ipv4Addr::new(224, 0, 0, 251), Ipv4Addr::new(0, 0, 0, 0))?;
        
        let multicast_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(224, 0, 0, 251)), 5353);
        
        Ok(Self {
            socket,
            multicast_addr,
            discovered_services: HashMap::new(),
        })
    }

    /// 开始发现服务
    pub async fn start_discovery(&mut self, service_type: &str) -> Result<(), Box<dyn std::error::Error>> {
        // 发送mDNS查询
        let query = self.build_query(service_type);
        self.socket.send_to(&query, self.multicast_addr).await?;
        
        // 监听响应
        self.listen_for_responses().await?;
        
        Ok(())
    }

    /// 构建mDNS查询
    fn build_query(&self, service_type: &str) -> Vec<u8> {
        let mut query = Vec::new();
        
        // DNS头部
        query.extend_from_slice(&[0x00, 0x01]); // ID
        query.extend_from_slice(&[0x01, 0x00]); // Flags (标准查询)
        query.extend_from_slice(&[0x00, 0x01]); // 问题数
        query.extend_from_slice(&[0x00, 0x00]); // 应答数
        query.extend_from_slice(&[0x00, 0x00]); // 授权数
        query.extend_from_slice(&[0x00, 0x00]); // 附加数
        
        // 查询名称
        let service_name = format!("{}.local", service_type);
        for part in service_name.split('.') {
            query.push(part.len() as u8);
            query.extend_from_slice(part.as_bytes());
        }
        query.push(0); // 结束标记
        
        // 查询类型和类
        query.extend_from_slice(&[0x00, 0x0C]); // PTR记录
        query.extend_from_slice(&[0x00, 0x01]); // IN类
        
        query
    }

    /// 监听响应
    async fn listen_for_responses(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let mut buffer = [0u8; 1024];
        
        loop {
            let (len, addr) = self.socket.recv_from(&mut buffer).await?;
            let response = &buffer[..len];
            
            if let Ok(service_record) = self.parse_response(response) {
                self.discovered_services.insert(service_record.name.clone(), service_record);
            }
        }
    }

    /// 解析mDNS响应
    fn parse_response(&self, response: &[u8]) -> Result<MDNSServiceRecord, Box<dyn std::error::Error>> {
        // 简化的mDNS响应解析
        // 实际实现需要完整的DNS协议解析
        
        let service_record = MDNSServiceRecord {
            name: "discovered_service".to_string(),
            service_type: "_iot._tcp".to_string(),
            port: 8080,
            hostname: "device.local".to_string(),
            ip_address: IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)),
            txt_records: HashMap::new(),
        };
        
        Ok(service_record)
    }

    /// 获取发现的服务
    pub fn get_discovered_services(&self) -> &HashMap<String, MDNSServiceRecord> {
        &self.discovered_services
    }
}
```

### 1.2 SSDP设备发现

```rust
use std::net::UdpSocket;
use std::time::Duration;

/// SSDP设备信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SSDPDeviceInfo {
    pub usn: String,
    pub location: String,
    pub server: String,
    pub device_type: String,
    pub description_url: String,
}

/// SSDP设备发现器
pub struct SSDPDiscoverer {
    socket: UdpSocket,
    discovered_devices: HashMap<String, SSDPDeviceInfo>,
}

impl SSDPDiscoverer {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let socket = UdpSocket::bind("0.0.0.0:0")?;
        socket.set_read_timeout(Some(Duration::from_secs(5)))?;
        socket.set_multicast_ttl_v4(4)?;
        socket.join_multicast_v4(Ipv4Addr::new(239, 255, 255, 250), Ipv4Addr::new(0, 0, 0, 0))?;
        
        Ok(Self {
            socket,
            discovered_devices: HashMap::new(),
        })
    }

    /// 搜索设备
    pub fn search_devices(&mut self, search_target: &str) -> Result<(), Box<dyn std::error::Error>> {
        let search_message = self.build_search_message(search_target);
        let multicast_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(239, 255, 255, 250)), 1900);
        
        self.socket.send_to(&search_message, multicast_addr)?;
        
        // 监听响应
        self.listen_for_responses()?;
        
        Ok(())
    }

    /// 构建SSDP搜索消息
    fn build_search_message(&self, search_target: &str) -> Vec<u8> {
        let message = format!(
            "M-SEARCH * HTTP/1.1\r\n\
             HOST: 239.255.255.250:1900\r\n\
             MAN: \"ssdp:discover\"\r\n\
             MX: 3\r\n\
             ST: {}\r\n\
             \r\n",
            search_target
        );
        
        message.into_bytes()
    }

    /// 监听响应
    fn listen_for_responses(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let mut buffer = [0u8; 1024];
        
        loop {
            match self.socket.recv_from(&mut buffer) {
                Ok((len, _addr)) => {
                    let response = String::from_utf8_lossy(&buffer[..len]);
                    if let Ok(device_info) = self.parse_response(&response) {
                        self.discovered_devices.insert(device_info.usn.clone(), device_info);
                    }
                }
                Err(_) => break, // 超时或错误
            }
        }
        
        Ok(())
    }

    /// 解析SSDP响应
    fn parse_response(&self, response: &str) -> Result<SSDPDeviceInfo, Box<dyn std::error::Error>> {
        let mut device_info = SSDPDeviceInfo {
            usn: String::new(),
            location: String::new(),
            server: String::new(),
            device_type: String::new(),
            description_url: String::new(),
        };
        
        for line in response.lines() {
            if line.starts_with("USN:") {
                device_info.usn = line[4..].trim().to_string();
            } else if line.starts_with("LOCATION:") {
                device_info.location = line[9..].trim().to_string();
            } else if line.starts_with("SERVER:") {
                device_info.server = line[7..].trim().to_string();
            } else if line.starts_with("ST:") {
                device_info.device_type = line[3..].trim().to_string();
            }
        }
        
        device_info.description_url = device_info.location.clone();
        
        Ok(device_info)
    }

    /// 获取发现的设备
    pub fn get_discovered_devices(&self) -> &HashMap<String, SSDPDeviceInfo> {
        &self.discovered_devices
    }
}
```

## 2. 设备注册系统

### 2.1 设备注册器

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use tokio::sync::RwLock;
use uuid::Uuid;

/// 设备信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceInfo {
    pub id: String,
    pub name: String,
    pub device_type: String,
    pub manufacturer: String,
    pub model: String,
    pub version: String,
    pub capabilities: Vec<String>,
    pub ip_address: String,
    pub port: u16,
    pub protocol: String,
    pub status: DeviceStatus,
    pub registration_time: u64,
    pub last_seen: u64,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DeviceStatus {
    Online,
    Offline,
    Error,
    Maintenance,
}

/// 设备注册器
pub struct DeviceRegistry {
    devices: RwLock<HashMap<String, DeviceInfo>>,
    device_types: RwLock<HashMap<String, DeviceTypeInfo>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceTypeInfo {
    pub name: String,
    pub description: String,
    pub capabilities: Vec<String>,
    pub protocols: Vec<String>,
    pub schema: serde_json::Value,
}

impl DeviceRegistry {
    pub fn new() -> Self {
        Self {
            devices: RwLock::new(HashMap::new()),
            device_types: RwLock::new(HashMap::new()),
        }
    }

    /// 注册设备
    pub async fn register_device(&self, device_info: DeviceInfo) -> Result<String, Box<dyn std::error::Error>> {
        let device_id = if device_info.id.is_empty() {
            Uuid::new_v4().to_string()
        } else {
            device_info.id.clone()
        };
        
        let mut device = device_info;
        device.id = device_id.clone();
        device.registration_time = chrono::Utc::now().timestamp() as u64;
        device.last_seen = device.registration_time;
        
        let mut devices = self.devices.write().await;
        devices.insert(device_id.clone(), device);
        
        Ok(device_id)
    }

    /// 更新设备状态
    pub async fn update_device_status(&self, device_id: &str, status: DeviceStatus) -> Result<(), Box<dyn std::error::Error>> {
        let mut devices = self.devices.write().await;
        
        if let Some(device) = devices.get_mut(device_id) {
            device.status = status;
            device.last_seen = chrono::Utc::now().timestamp() as u64;
        } else {
            return Err("Device not found".into());
        }
        
        Ok(())
    }

    /// 获取设备信息
    pub async fn get_device(&self, device_id: &str) -> Option<DeviceInfo> {
        let devices = self.devices.read().await;
        devices.get(device_id).cloned()
    }

    /// 获取所有设备
    pub async fn get_all_devices(&self) -> Vec<DeviceInfo> {
        let devices = self.devices.read().await;
        devices.values().cloned().collect()
    }

    /// 根据类型获取设备
    pub async fn get_devices_by_type(&self, device_type: &str) -> Vec<DeviceInfo> {
        let devices = self.devices.read().await;
        devices.values()
            .filter(|device| device.device_type == device_type)
            .cloned()
            .collect()
    }

    /// 根据状态获取设备
    pub async fn get_devices_by_status(&self, status: DeviceStatus) -> Vec<DeviceInfo> {
        let devices = self.devices.read().await;
        devices.values()
            .filter(|device| device.status == status)
            .cloned()
            .collect()
    }

    /// 删除设备
    pub async fn unregister_device(&self, device_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut devices = self.devices.write().await;
        
        if devices.remove(device_id).is_some() {
            Ok(())
        } else {
            Err("Device not found".into())
        }
    }

    /// 注册设备类型
    pub async fn register_device_type(&self, type_info: DeviceTypeInfo) -> Result<(), Box<dyn std::error::Error>> {
        let mut device_types = self.device_types.write().await;
        device_types.insert(type_info.name.clone(), type_info);
        Ok(())
    }

    /// 获取设备类型信息
    pub async fn get_device_type(&self, type_name: &str) -> Option<DeviceTypeInfo> {
        let device_types = self.device_types.read().await;
        device_types.get(type_name).cloned()
    }

    /// 清理离线设备
    pub async fn cleanup_offline_devices(&self, timeout_seconds: u64) -> Result<usize, Box<dyn std::error::Error>> {
        let current_time = chrono::Utc::now().timestamp() as u64;
        let mut devices = self.devices.write().await;
        
        let mut to_remove = Vec::new();
        
        for (device_id, device) in devices.iter() {
            if current_time - device.last_seen > timeout_seconds {
                to_remove.push(device_id.clone());
            }
        }
        
        let removed_count = to_remove.len();
        for device_id in to_remove {
            devices.remove(&device_id);
        }
        
        Ok(removed_count)
    }
}
```

### 2.2 设备健康检查

```rust
use tokio::time::{Duration, interval};
use std::net::TcpStream;

/// 设备健康检查器
pub struct DeviceHealthChecker {
    registry: DeviceRegistry,
    check_interval: Duration,
    timeout: Duration,
}

impl DeviceHealthChecker {
    pub fn new(registry: DeviceRegistry) -> Self {
        Self {
            registry,
            check_interval: Duration::from_secs(30),
            timeout: Duration::from_secs(5),
        }
    }

    /// 开始健康检查
    pub async fn start_health_check(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut interval = interval(self.check_interval);
        
        loop {
            interval.tick().await;
            self.check_all_devices().await?;
        }
    }

    /// 检查所有设备
    async fn check_all_devices(&self) -> Result<(), Box<dyn std::error::Error>> {
        let devices = self.registry.get_all_devices().await;
        
        for device in devices {
            let status = self.check_device_health(&device).await;
            self.registry.update_device_status(&device.id, status).await?;
        }
        
        Ok(())
    }

    /// 检查单个设备健康状态
    async fn check_device_health(&self, device: &DeviceInfo) -> DeviceStatus {
        // 检查网络连接
        if let Ok(_) = tokio::time::timeout(self.timeout, async {
            TcpStream::connect(format!("{}:{}", device.ip_address, device.port)).await
        }).await {
            DeviceStatus::Online
        } else {
            DeviceStatus::Offline
        }
    }

    /// 检查设备响应时间
    async fn check_device_response_time(&self, device: &DeviceInfo) -> Result<Duration, Box<dyn std::error::Error>> {
        let start_time = std::time::Instant::now();
        
        tokio::time::timeout(self.timeout, async {
            TcpStream::connect(format!("{}:{}", device.ip_address, device.port)).await
        }).await??;
        
        Ok(start_time.elapsed())
    }
}
```

## 3. 自动发现服务

### 3.1 综合设备发现器

```rust
/// 综合设备发现器
pub struct AutoDeviceDiscoverer {
    mdns_discoverer: MDNSDiscoverer,
    ssdp_discoverer: SSDPDiscoverer,
    registry: DeviceRegistry,
    health_checker: DeviceHealthChecker,
}

impl AutoDeviceDiscoverer {
    pub async fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let mdns_discoverer = MDNSDiscoverer::new().await?;
        let ssdp_discoverer = SSDPDiscoverer::new()?;
        let registry = DeviceRegistry::new();
        let health_checker = DeviceHealthChecker::new(registry.clone());
        
        Ok(Self {
            mdns_discoverer,
            ssdp_discoverer,
            registry,
            health_checker,
        })
    }

    /// 开始自动发现
    pub async fn start_auto_discovery(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // 启动健康检查
        let health_checker = self.health_checker.clone();
        tokio::spawn(async move {
            if let Err(e) = health_checker.start_health_check().await {
                eprintln!("Health check error: {}", e);
            }
        });
        
        // 定期发现设备
        let mut interval = tokio::time::interval(Duration::from_secs(60));
        
        loop {
            interval.tick().await;
            
            // mDNS发现
            if let Err(e) = self.mdns_discoverer.start_discovery("_iot._tcp").await {
                eprintln!("mDNS discovery error: {}", e);
            }
            
            // SSDP发现
            if let Err(e) = self.ssdp_discoverer.search_devices("urn:schemas-upnp-org:device:IoTDevice:1") {
                eprintln!("SSDP discovery error: {}", e);
            }
            
            // 处理发现的设备
            self.process_discovered_devices().await?;
        }
    }

    /// 处理发现的设备
    async fn process_discovered_devices(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // 处理mDNS设备
        for (name, service) in self.mdns_discoverer.get_discovered_services() {
            let device_info = DeviceInfo {
                id: String::new(),
                name: name.clone(),
                device_type: service.service_type.clone(),
                manufacturer: service.txt_records.get("manufacturer").unwrap_or(&"Unknown".to_string()).clone(),
                model: service.txt_records.get("model").unwrap_or(&"Unknown".to_string()).clone(),
                version: service.txt_records.get("version").unwrap_or(&"1.0".to_string()).clone(),
                capabilities: vec!["mDNS".to_string()],
                ip_address: service.ip_address.to_string(),
                port: service.port,
                protocol: "mDNS".to_string(),
                status: DeviceStatus::Online,
                registration_time: 0,
                last_seen: 0,
                metadata: service.txt_records.clone(),
            };
            
            self.registry.register_device(device_info).await?;
        }
        
        // 处理SSDP设备
        for (usn, device) in self.ssdp_discoverer.get_discovered_devices() {
            let device_info = DeviceInfo {
                id: String::new(),
                name: usn.clone(),
                device_type: device.device_type.clone(),
                manufacturer: "Unknown".to_string(),
                model: "Unknown".to_string(),
                version: "1.0".to_string(),
                capabilities: vec!["SSDP".to_string()],
                ip_address: "Unknown".to_string(), // 需要从location URL解析
                port: 0,
                protocol: "SSDP".to_string(),
                status: DeviceStatus::Online,
                registration_time: 0,
                last_seen: 0,
                metadata: HashMap::new(),
            };
            
            self.registry.register_device(device_info).await?;
        }
        
        Ok(())
    }

    /// 获取注册的设备
    pub async fn get_registered_devices(&self) -> Vec<DeviceInfo> {
        self.registry.get_all_devices().await
    }

    /// 获取在线设备
    pub async fn get_online_devices(&self) -> Vec<DeviceInfo> {
        self.registry.get_devices_by_status(DeviceStatus::Online).await
    }
}
```

## 4. 应用示例

### 4.1 智能家居设备发现

```rust
use crate::discovery::{AutoDeviceDiscoverer, DeviceRegistry, DeviceTypeInfo};

async fn smart_home_device_discovery() -> Result<(), Box<dyn std::error::Error>> {
    // 创建自动发现器
    let mut discoverer = AutoDeviceDiscoverer::new().await?;
    
    // 注册设备类型
    let registry = discoverer.registry.clone();
    
    let temperature_sensor_type = DeviceTypeInfo {
        name: "TemperatureSensor".to_string(),
        description: "Temperature sensor device".to_string(),
        capabilities: vec!["temperature_reading".to_string(), "humidity_reading".to_string()],
        protocols: vec!["mDNS".to_string(), "SSDP".to_string(), "MQTT".to_string()],
        schema: serde_json::json!({
            "type": "object",
            "properties": {
                "temperature": {"type": "number"},
                "humidity": {"type": "number"},
                "unit": {"type": "string"}
            }
        }),
    };
    
    let light_switch_type = DeviceTypeInfo {
        name: "LightSwitch".to_string(),
        description: "Smart light switch".to_string(),
        capabilities: vec!["light_control".to_string(), "dimmer_control".to_string()],
        protocols: vec!["mDNS".to_string(), "SSDP".to_string(), "Zigbee".to_string()],
        schema: serde_json::json!({
            "type": "object",
            "properties": {
                "state": {"type": "boolean"},
                "brightness": {"type": "number"},
                "color": {"type": "string"}
            }
        }),
    };
    
    registry.register_device_type(temperature_sensor_type).await?;
    registry.register_device_type(light_switch_type).await?;
    
    // 启动自动发现
    tokio::spawn(async move {
        if let Err(e) = discoverer.start_auto_discovery().await {
            eprintln!("Auto discovery error: {}", e);
        }
    });
    
    // 监控发现的设备
    loop {
        let devices = discoverer.get_registered_devices().await;
        println!("发现 {} 个设备:", devices.len());
        
        for device in devices {
            println!("- {} ({}) - {}", device.name, device.device_type, device.ip_address);
            println!("  制造商: {}, 型号: {}", device.manufacturer, device.model);
            println!("  状态: {:?}, 最后在线: {}", device.status, device.last_seen);
            println!("  能力: {:?}", device.capabilities);
            println!();
        }
        
        tokio::time::sleep(Duration::from_secs(30)).await;
    }
}
```

## 5. 总结

本实现提供了：

1. **多种发现协议** - mDNS和SSDP设备发现
2. **设备注册系统** - 完整的设备信息管理
3. **健康检查机制** - 自动监控设备状态
4. **自动发现服务** - 综合设备发现和管理
5. **实际应用示例** - 智能家居设备发现场景

这个设备发现注册系统为IoT平台提供了强大的设备自动发现和管理能力，实现了设备的即插即用。
