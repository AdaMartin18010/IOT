# 微服务架构实现

## 1. 服务注册与发现

### 1.1 服务注册中心

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use serde::{Deserialize, Serialize};
use tokio::time::{Duration, Instant};
use uuid::Uuid;

/// 服务实例信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInstance {
    pub id: String,
    pub service_name: String,
    pub host: String,
    pub port: u16,
    pub health_check_url: Option<String>,
    pub metadata: HashMap<String, String>,
    pub status: ServiceStatus,
    pub last_heartbeat: Instant,
}

/// 服务状态
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum ServiceStatus {
    Healthy,
    Unhealthy,
    Starting,
    Stopping,
}

/// 服务注册中心
pub struct ServiceRegistry {
    services: Arc<RwLock<HashMap<String, Vec<ServiceInstance>>>>,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self {
            services: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// 注册服务实例
    pub async fn register_service(&self, instance: ServiceInstance) -> Result<(), Box<dyn std::error::Error>> {
        let mut services = self.services.write().unwrap();
        let service_instances = services.entry(instance.service_name.clone()).or_insert_with(Vec::new);
        
        if let Some(existing_index) = service_instances.iter().position(|existing| {
            existing.host == instance.host && existing.port == instance.port
        }) {
            service_instances[existing_index] = instance;
        } else {
            service_instances.push(instance);
        }
        
        Ok(())
    }
    
    /// 获取服务实例列表
    pub async fn get_service_instances(&self, service_name: &str) -> Result<Vec<ServiceInstance>, Box<dyn std::error::Error>> {
        let services = self.services.read().unwrap();
        
        if let Some(instances) = services.get(service_name) {
            Ok(instances.iter().filter(|instance| instance.status == ServiceStatus::Healthy).cloned().collect())
        } else {
            Ok(Vec::new())
        }
    }
    
    /// 更新服务实例心跳
    pub async fn update_heartbeat(&self, service_name: &str, instance_id: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let mut services = self.services.write().unwrap();
        
        if let Some(service_instances) = services.get_mut(service_name) {
            if let Some(instance) = service_instances.iter_mut().find(|instance| instance.id == instance_id) {
                instance.last_heartbeat = Instant::now();
                return Ok(true);
            }
        }
        
        Ok(false)
    }
}
```

### 1.2 服务发现客户端

```rust
use std::sync::Arc;
use tokio::time::{Duration, Instant};

/// 服务发现客户端
pub struct ServiceDiscoveryClient {
    registry_url: String,
    client: reqwest::Client,
    cache: Arc<RwLock<HashMap<String, (Vec<ServiceInstance>, Instant)>>>,
    cache_ttl: Duration,
}

impl ServiceDiscoveryClient {
    pub fn new(registry_url: String) -> Self {
        Self {
            registry_url,
            client: reqwest::Client::new(),
            cache: Arc::new(RwLock::new(HashMap::new())),
            cache_ttl: Duration::from_secs(30),
        }
    }
    
    /// 发现服务实例
    pub async fn discover_service(&self, service_name: &str) -> Result<Vec<ServiceInstance>, Box<dyn std::error::Error>> {
        // 检查缓存
        {
            let cache = self.cache.read().unwrap();
            if let Some((instances, cached_at)) = cache.get(service_name) {
                if Instant::now().duration_since(*cached_at) < self.cache_ttl {
                    return Ok(instances.clone());
                }
            }
        }
        
        // 从注册中心获取服务实例
        let url = format!("{}/services/{}", self.registry_url, service_name);
        let response = self.client.get(&url).send().await?;
        
        if response.status().is_success() {
            let instances: Vec<ServiceInstance> = response.json().await?;
            
            // 更新缓存
            {
                let mut cache = self.cache.write().unwrap();
                cache.insert(service_name.to_string(), (instances.clone(), Instant::now()));
            }
            
            Ok(instances)
        } else {
            Err("Failed to discover service".into())
        }
    }
}
```

## 2. 负载均衡器

### 2.1 负载均衡策略

```rust
use std::sync::atomic::{AtomicUsize, Ordering};

/// 负载均衡策略
pub enum LoadBalancingStrategy {
    RoundRobin,
    LeastConnections,
    Random,
}

/// 负载均衡器
pub struct LoadBalancer {
    strategy: LoadBalancingStrategy,
    instances: Arc<RwLock<Vec<ServiceInstance>>>,
    current_index: AtomicUsize,
    connection_counts: Arc<RwLock<HashMap<String, AtomicUsize>>>,
}

impl LoadBalancer {
    pub fn new(strategy: LoadBalancingStrategy) -> Self {
        Self {
            strategy,
            instances: Arc::new(RwLock::new(Vec::new())),
            current_index: AtomicUsize::new(0),
            connection_counts: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// 更新服务实例列表
    pub async fn update_instances(&self, instances: Vec<ServiceInstance>) {
        let mut current_instances = self.instances.write().unwrap();
        *current_instances = instances;
    }
    
    /// 选择下一个实例
    pub async fn next_instance(&self) -> Option<ServiceInstance> {
        let instances = self.instances.read().unwrap();
        
        if instances.is_empty() {
            return None;
        }
        
        match self.strategy {
            LoadBalancingStrategy::RoundRobin => self.round_robin(&instances),
            LoadBalancingStrategy::LeastConnections => self.least_connections(&instances).await,
            LoadBalancingStrategy::Random => self.random(&instances),
        }
    }
    
    /// 轮询策略
    fn round_robin(&self, instances: &[ServiceInstance]) -> Option<ServiceInstance> {
        let index = self.current_index.fetch_add(1, Ordering::Relaxed);
        instances.get(index % instances.len()).cloned()
    }
    
    /// 最少连接数策略
    async fn least_connections(&self, instances: &[ServiceInstance]) -> Option<ServiceInstance> {
        let connection_counts = self.connection_counts.read().unwrap();
        
        let mut min_connections = usize::MAX;
        let mut selected_instance = None;
        
        for instance in instances {
            let count = connection_counts
                .get(&instance.id)
                .map(|counter| counter.load(Ordering::Relaxed))
                .unwrap_or(0);
            
            if count < min_connections {
                min_connections = count;
                selected_instance = Some(instance.clone());
            }
        }
        
        selected_instance
    }
    
    /// 随机策略
    fn random(&self, instances: &[ServiceInstance]) -> Option<ServiceInstance> {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        let index = rng.gen_range(0..instances.len());
        instances.get(index).cloned()
    }
}
```

## 3. 熔断器模式

### 3.1 熔断器实现

```rust
use tokio::time::{Duration, Instant};

/// 熔断器状态
#[derive(Debug, Clone, PartialEq)]
pub enum CircuitBreakerState {
    Closed,    // 正常状态
    Open,      // 熔断状态
    HalfOpen,  // 半开状态
}

/// 熔断器配置
pub struct CircuitBreakerConfig {
    pub failure_threshold: u64,        // 失败阈值
    pub recovery_timeout: Duration,    // 恢复超时时间
    pub success_threshold: u64,        // 成功阈值（半开状态）
}

impl Default for CircuitBreakerConfig {
    fn default() -> Self {
        Self {
            failure_threshold: 5,
            recovery_timeout: Duration::from_secs(60),
            success_threshold: 3,
        }
    }
}

/// 熔断器
pub struct CircuitBreaker {
    config: CircuitBreakerConfig,
    state: AtomicU64, // 0=Closed, 1=Open, 2=HalfOpen
    failure_count: AtomicU64,
    success_count: AtomicU64,
    last_failure_time: Arc<RwLock<Option<Instant>>>,
}

impl CircuitBreaker {
    pub fn new(config: CircuitBreakerConfig) -> Self {
        Self {
            config,
            state: AtomicU64::new(0), // Closed
            failure_count: AtomicU64::new(0),
            success_count: AtomicU64::new(0),
            last_failure_time: Arc::new(RwLock::new(None)),
        }
    }
    
    /// 获取当前状态
    pub fn get_state(&self) -> CircuitBreakerState {
        match self.state.load(Ordering::Relaxed) {
            0 => CircuitBreakerState::Closed,
            1 => CircuitBreakerState::Open,
            2 => CircuitBreakerState::HalfOpen,
            _ => CircuitBreakerState::Closed,
        }
    }
    
    /// 检查是否允许请求
    pub fn is_allowed(&self) -> bool {
        match self.get_state() {
            CircuitBreakerState::Closed => true,
            CircuitBreakerState::Open => {
                let last_failure_time = self.last_failure_time.read().unwrap();
                if let Some(failure_time) = *last_failure_time {
                    if Instant::now().duration_since(failure_time) >= self.config.recovery_timeout {
                        self.transition_to_half_open();
                        true
                    } else {
                        false
                    }
                } else {
                    false
                }
            }
            CircuitBreakerState::HalfOpen => true,
        }
    }
    
    /// 记录成功
    pub fn record_success(&self) {
        match self.get_state() {
            CircuitBreakerState::Closed => {
                self.failure_count.store(0, Ordering::Relaxed);
            }
            CircuitBreakerState::HalfOpen => {
                let success_count = self.success_count.fetch_add(1, Ordering::Relaxed) + 1;
                if success_count >= self.config.success_threshold {
                    self.transition_to_closed();
                }
            }
            CircuitBreakerState::Open => {}
        }
    }
    
    /// 记录失败
    pub fn record_failure(&self) {
        match self.get_state() {
            CircuitBreakerState::Closed => {
                let failure_count = self.failure_count.fetch_add(1, Ordering::Relaxed) + 1;
                if failure_count >= self.config.failure_threshold {
                    self.transition_to_open();
                }
            }
            CircuitBreakerState::HalfOpen => {
                self.transition_to_open();
            }
            CircuitBreakerState::Open => {
                let mut last_failure_time = self.last_failure_time.write().unwrap();
                *last_failure_time = Some(Instant::now());
            }
        }
    }
    
    /// 转换到关闭状态
    fn transition_to_closed(&self) {
        self.state.store(0, Ordering::Relaxed);
        self.failure_count.store(0, Ordering::Relaxed);
        self.success_count.store(0, Ordering::Relaxed);
    }
    
    /// 转换到开启状态
    fn transition_to_open(&self) {
        self.state.store(1, Ordering::Relaxed);
        let mut last_failure_time = self.last_failure_time.write().unwrap();
        *last_failure_time = Some(Instant::now());
    }
    
    /// 转换到半开状态
    fn transition_to_half_open(&self) {
        self.state.store(2, Ordering::Relaxed);
        self.success_count.store(0, Ordering::Relaxed);
    }
}
```

## 4. 微服务网关

### 4.1 API网关实现

```rust
use axum::{
    routing::{get, post, put, delete},
    http::{StatusCode, HeaderMap},
    response::Json,
    extract::{Path, Query, State},
    Router,
};
use std::sync::Arc;
use serde::{Deserialize, Serialize};

/// 服务路由配置
#[derive(Debug, Clone)]
pub struct ServiceRoute {
    pub service_name: String,
    pub path_prefix: String,
    pub load_balancing_strategy: LoadBalancingStrategy,
    pub circuit_breaker_config: Option<CircuitBreakerConfig>,
    pub timeout: Duration,
    pub retry_count: u32,
}

/// 微服务网关
pub struct MicroserviceGateway {
    service_discovery: Arc<ServiceDiscoveryClient>,
    load_balancer: Arc<LoadBalancer>,
    circuit_breakers: Arc<RwLock<HashMap<String, Arc<CircuitBreaker>>>>,
    routes: Arc<RwLock<HashMap<String, ServiceRoute>>>,
}

impl MicroserviceGateway {
    pub fn new(service_discovery: Arc<ServiceDiscoveryClient>) -> Self {
        Self {
            service_discovery,
            load_balancer: Arc::new(LoadBalancer::new(LoadBalancingStrategy::RoundRobin)),
            circuit_breakers: Arc::new(RwLock::new(HashMap::new())),
            routes: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// 添加服务路由
    pub async fn add_route(&self, route: ServiceRoute) {
        let mut routes = self.routes.write().unwrap();
        routes.insert(route.path_prefix.clone(), route);
    }
    
    /// 创建网关路由
    pub fn create_gateway_routes(self: Arc<Self>) -> Router {
        Router::new()
            .route("/*path", get(self.clone().proxy_get))
            .route("/*path", post(self.clone().proxy_post))
            .route("/*path", put(self.clone().proxy_put))
            .route("/*path", delete(self.clone().proxy_delete))
            .with_state(self)
    }
    
    /// 代理GET请求
    async fn proxy_get(
        self: Arc<Self>,
        State(gateway): State<Arc<Self>>,
        Path(path): Path<String>,
        Query(query): Query<HashMap<String, String>>,
        headers: HeaderMap,
    ) -> Result<Json<serde_json::Value>, StatusCode> {
        gateway.proxy_request("GET", &path, query, headers, None).await
    }
    
    /// 代理POST请求
    async fn proxy_post(
        self: Arc<Self>,
        State(gateway): State<Arc<Self>>,
        Path(path): Path<String>,
        Query(query): Query<HashMap<String, String>>,
        headers: HeaderMap,
        body: axum::body::Body,
    ) -> Result<Json<serde_json::Value>, StatusCode> {
        let body_bytes = axum::body::to_bytes(body, usize::MAX).await
            .map_err(|_| StatusCode::BAD_REQUEST)?;
        gateway.proxy_request("POST", &path, query, headers, Some(body_bytes)).await
    }
    
    /// 代理PUT请求
    async fn proxy_put(
        self: Arc<Self>,
        State(gateway): State<Arc<Self>>,
        Path(path): Path<String>,
        Query(query): Query<HashMap<String, String>>,
        headers: HeaderMap,
        body: axum::body::Body,
    ) -> Result<Json<serde_json::Value>, StatusCode> {
        let body_bytes = axum::body::to_bytes(body, usize::MAX).await
            .map_err(|_| StatusCode::BAD_REQUEST)?;
        gateway.proxy_request("PUT", &path, query, headers, Some(body_bytes)).await
    }
    
    /// 代理DELETE请求
    async fn proxy_delete(
        self: Arc<Self>,
        State(gateway): State<Arc<Self>>,
        Path(path): Path<String>,
        Query(query): Query<HashMap<String, String>>,
        headers: HeaderMap,
    ) -> Result<Json<serde_json::Value>, StatusCode> {
        gateway.proxy_request("DELETE", &path, query, headers, None).await
    }
    
    /// 代理请求到目标服务
    async fn proxy_request(
        &self,
        method: &str,
        path: &str,
        query: HashMap<String, String>,
        headers: HeaderMap,
        body: Option<axum::body::Bytes>,
    ) -> Result<Json<serde_json::Value>, StatusCode> {
        // 查找匹配的路由
        let route = self.find_route(path)?;
        
        // 获取服务实例
        let instances = self.service_discovery.discover_service(&route.service_name).await
            .map_err(|_| StatusCode::SERVICE_UNAVAILABLE)?;
        
        if instances.is_empty() {
            return Err(StatusCode::SERVICE_UNAVAILABLE);
        }
        
        // 更新负载均衡器实例
        self.load_balancer.update_instances(instances).await;
        
        // 选择目标实例
        let target_instance = self.load_balancer.next_instance().await
            .ok_or(StatusCode::SERVICE_UNAVAILABLE)?;
        
        // 获取或创建熔断器
        let circuit_breaker = self.get_circuit_breaker(&route.service_name, &route.circuit_breaker_config).await;
        
        // 构建目标URL
        let target_url = self.build_target_url(&target_instance, path, &query)?;
        
        // 执行请求
        let response = self.execute_request_with_circuit_breaker(
            &circuit_breaker,
            method,
            &target_url,
            headers,
            body,
            route.timeout,
            route.retry_count,
        ).await?;
        
        Ok(Json(response))
    }
    
    /// 查找匹配的路由
    fn find_route(&self, path: &str) -> Result<ServiceRoute, StatusCode> {
        let routes = self.routes.read().unwrap();
        
        for (prefix, route) in routes.iter() {
            if path.starts_with(prefix) {
                return Ok(route.clone());
            }
        }
        
        Err(StatusCode::NOT_FOUND)
    }
    
    /// 获取熔断器
    async fn get_circuit_breaker(
        &self,
        service_name: &str,
        config: &Option<CircuitBreakerConfig>,
    ) -> Arc<CircuitBreaker> {
        let mut circuit_breakers = self.circuit_breakers.write().unwrap();
        
        if let Some(circuit_breaker) = circuit_breakers.get(service_name) {
            circuit_breaker.clone()
        } else {
            let config = config.clone().unwrap_or_default();
            let circuit_breaker = Arc::new(CircuitBreaker::new(config));
            circuit_breakers.insert(service_name.to_string(), circuit_breaker.clone());
            circuit_breaker
        }
    }
    
    /// 构建目标URL
    fn build_target_url(
        &self,
        instance: &ServiceInstance,
        path: &str,
        query: &HashMap<String, String>,
    ) -> Result<String, StatusCode> {
        let mut url = format!("http://{}:{}{}", instance.host, instance.port, path);
        
        if !query.is_empty() {
            let query_string: Vec<String> = query
                .iter()
                .map(|(k, v)| format!("{}={}", k, v))
                .collect();
            url.push_str(&format!("?{}", query_string.join("&")));
        }
        
        Ok(url)
    }
    
    /// 执行带熔断器的请求
    async fn execute_request_with_circuit_breaker(
        &self,
        circuit_breaker: &CircuitBreaker,
        method: &str,
        url: &str,
        headers: HeaderMap,
        body: Option<axum::body::Bytes>,
        timeout: Duration,
        retry_count: u32,
    ) -> Result<serde_json::Value, StatusCode> {
        let client = reqwest::Client::new();
        let mut request_builder = match method {
            "GET" => client.get(url),
            "POST" => client.post(url),
            "PUT" => client.put(url),
            "DELETE" => client.delete(url),
            _ => return Err(StatusCode::METHOD_NOT_ALLOWED),
        };
        
        // 添加请求头
        for (name, value) in headers.iter() {
            if let Some(name_str) = name.as_str() {
                if !name_str.starts_with("host") {
                    request_builder = request_builder.header(name_str, value);
                }
            }
        }
        
        // 添加请求体
        if let Some(body_bytes) = body {
            request_builder = request_builder.body(body_bytes);
        }
        
        // 执行请求
        let mut last_error = None;
        
        for attempt in 0..=retry_count {
            if !circuit_breaker.is_allowed() {
                return Err(StatusCode::SERVICE_UNAVAILABLE);
            }
            
            match tokio::time::timeout(timeout, request_builder.try_clone().unwrap().send()).await {
                Ok(Ok(response)) => {
                    if response.status().is_success() {
                        circuit_breaker.record_success();
                        let json: serde_json::Value = response.json().await
                            .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
                        return Ok(json);
                    } else {
                        circuit_breaker.record_failure();
                        last_error = Some(StatusCode::from_u16(response.status().as_u16())
                            .unwrap_or(StatusCode::INTERNAL_SERVER_ERROR));
                    }
                }
                Ok(Err(_)) => {
                    circuit_breaker.record_failure();
                    last_error = Some(StatusCode::INTERNAL_SERVER_ERROR);
                }
                Err(_) => {
                    circuit_breaker.record_timeout();
                    last_error = Some(StatusCode::REQUEST_TIMEOUT);
                }
            }
            
            if attempt < retry_count {
                tokio::time::sleep(Duration::from_millis(100 * (attempt + 1) as u64)).await;
            }
        }
        
        Err(last_error.unwrap_or(StatusCode::INTERNAL_SERVER_ERROR))
    }
}
```

## 5. 应用示例

### 5.1 微服务架构示例

```rust
use std::sync::Arc;

async fn microservice_architecture_example() -> Result<(), Box<dyn std::error::Error>> {
    // 创建服务发现客户端
    let service_discovery = Arc::new(ServiceDiscoveryClient::new(
        "http://localhost:8080".to_string(),
    ));
    
    // 创建微服务网关
    let gateway = Arc::new(MicroserviceGateway::new(service_discovery.clone()));
    
    // 添加服务路由
    gateway.add_route(ServiceRoute {
        service_name: "device-service".to_string(),
        path_prefix: "/api/devices".to_string(),
        load_balancing_strategy: LoadBalancingStrategy::RoundRobin,
        circuit_breaker_config: Some(CircuitBreakerConfig {
            failure_threshold: 5,
            recovery_timeout: Duration::from_secs(60),
            success_threshold: 3,
        }),
        timeout: Duration::from_secs(30),
        retry_count: 3,
    }).await;
    
    gateway.add_route(ServiceRoute {
        service_name: "sensor-service".to_string(),
        path_prefix: "/api/sensors".to_string(),
        load_balancing_strategy: LoadBalancingStrategy::LeastConnections,
        circuit_breaker_config: Some(CircuitBreakerConfig {
            failure_threshold: 3,
            recovery_timeout: Duration::from_secs(30),
            success_threshold: 2,
        }),
        timeout: Duration::from_secs(15),
        retry_count: 2,
    }).await;
    
    // 创建网关路由
    let app = gateway.create_gateway_routes();
    
    // 启动网关服务器
    let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("Microservice Gateway starting on {}", addr);
    
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await?;
    
    Ok(())
}

/// 设备服务示例
async fn device_service_example() -> Result<(), Box<dyn std::error::Error>> {
    // 创建服务实例
    let instance = ServiceInstance {
        id: Uuid::new_v4().to_string(),
        service_name: "device-service".to_string(),
        host: "localhost".to_string(),
        port: 8081,
        health_check_url: Some("/health".to_string()),
        metadata: HashMap::new(),
        status: ServiceStatus::Healthy,
        last_heartbeat: Instant::now(),
    };
    
    // 注册服务
    let registry = Arc::new(ServiceRegistry::new());
    registry.register_service(instance).await?;
    
    // 创建设备服务API
    let app = Router::new()
        .route("/health", get(health_check))
        .route("/devices", get(list_devices))
        .route("/devices", post(create_device));
    
    let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 8081));
    println!("Device Service starting on {}", addr);
    
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await?;
    
    Ok(())
}

/// 传感器服务示例
async fn sensor_service_example() -> Result<(), Box<dyn std::error::Error>> {
    // 创建服务实例
    let instance = ServiceInstance {
        id: Uuid::new_v4().to_string(),
        service_name: "sensor-service".to_string(),
        host: "localhost".to_string(),
        port: 8082,
        health_check_url: Some("/health".to_string()),
        metadata: HashMap::new(),
        status: ServiceStatus::Healthy,
        last_heartbeat: Instant::now(),
    };
    
    // 注册服务
    let registry = Arc::new(ServiceRegistry::new());
    registry.register_service(instance).await?;
    
    // 创建传感器服务API
    let app = Router::new()
        .route("/health", get(health_check))
        .route("/sensors", get(list_sensors))
        .route("/sensors", post(create_sensor_data));
    
    let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 8082));
    println!("Sensor Service starting on {}", addr);
    
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await?;
    
    Ok(())
}

/// 健康检查
async fn health_check() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "status": "healthy",
        "timestamp": chrono::Utc::now().to_rfc3339()
    }))
}

/// 列出设备
async fn list_devices() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "devices": [
            {
                "id": "device-1",
                "name": "Temperature Sensor",
                "type": "sensor",
                "status": "online"
            }
        ]
    }))
}

/// 创建设备
async fn create_device() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "id": "device-2",
        "name": "New Device",
        "type": "sensor",
        "status": "created"
    }))
}

/// 列出传感器
async fn list_sensors() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "sensors": [
            {
                "id": "sensor-1",
                "type": "temperature",
                "value": 25.5,
                "unit": "celsius"
            }
        ]
    }))
}

/// 创建传感器数据
async fn create_sensor_data() -> Json<serde_json::Value> {
    Json(serde_json::json!({
        "id": "sensor-2",
        "type": "humidity",
        "value": 60.0,
        "unit": "percent"
    }))
}
```

## 6. 总结

本实现提供了完整的微服务架构组件：

1. **服务注册与发现** - 自动服务注册、健康检查、实例管理
2. **负载均衡** - 多种负载均衡策略（轮询、最少连接、随机等）
3. **熔断器模式** - 故障隔离、自动恢复、状态管理
4. **API网关** - 请求路由、负载均衡、熔断器集成
5. **实际应用示例** - 完整的微服务架构演示

这个微服务架构实现为IoT平台提供了高可用、可扩展的服务架构基础。
