# 微服务架构实现

## 概述

微服务架构是IoT系统的重要架构模式，提供服务的独立部署、扩展和管理能力。本文档提供基于Rust和Go的微服务架构实现，包含服务注册发现、负载均衡、服务间通信等核心功能。

## 核心架构

### 1. 服务定义和注册

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use uuid::Uuid;

/// 服务状态枚举
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ServiceStatus {
    Healthy,
    Unhealthy,
    Starting,
    Stopping,
}

/// 服务实例信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceInstance {
    pub id: String,
    pub service_name: String,
    pub host: String,
    pub port: u16,
    pub status: ServiceStatus,
    pub metadata: HashMap<String, String>,
    pub health_check_url: Option<String>,
    pub last_heartbeat: DateTime<Utc>,
    pub created_at: DateTime<Utc>,
}

/// 服务定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceDefinition {
    pub name: String,
    pub version: String,
    pub description: String,
    pub endpoints: Vec<ServiceEndpoint>,
    pub dependencies: Vec<String>,
    pub config: HashMap<String, serde_json::Value>,
}

/// 服务端点
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ServiceEndpoint {
    pub path: String,
    pub method: String,
    pub description: String,
    pub parameters: Vec<EndpointParameter>,
}

/// 端点参数
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EndpointParameter {
    pub name: String,
    pub param_type: String,
    pub required: bool,
    pub description: String,
}
```

### 2. 服务注册中心

```rust
use tokio::sync::RwLock;
use std::sync::Arc;
use std::time::Duration;
use tokio::time::interval;

/// 服务注册中心
pub struct ServiceRegistry {
    services: Arc<RwLock<HashMap<String, Vec<ServiceInstance>>>>,
    definitions: Arc<RwLock<HashMap<String, ServiceDefinition>>>,
    health_check_interval: Duration,
}

impl ServiceRegistry {
    pub fn new() -> Self {
        Self {
            services: Arc::new(RwLock::new(HashMap::new())),
            definitions: Arc::new(RwLock::new(HashMap::new())),
            health_check_interval: Duration::from_secs(30),
        }
    }

    /// 注册服务实例
    pub async fn register_service(&self, instance: ServiceInstance) -> Result<(), Box<dyn std::error::Error>> {
        let mut services = self.services.write().await;
        let service_instances = services.entry(instance.service_name.clone()).or_insert_with(Vec::new);
        
        // 检查是否已存在
        if let Some(existing) = service_instances.iter_mut().find(|i| i.id == instance.id) {
            *existing = instance;
        } else {
            service_instances.push(instance);
        }
        
        Ok(())
    }

    /// 注销服务实例
    pub async fn deregister_service(&self, service_name: &str, instance_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut services = self.services.write().await;
        if let Some(instances) = services.get_mut(service_name) {
            instances.retain(|instance| instance.id != instance_id);
        }
        Ok(())
    }

    /// 获取服务实例
    pub async fn get_service_instances(&self, service_name: &str) -> Vec<ServiceInstance> {
        let services = self.services.read().await;
        services.get(service_name).cloned().unwrap_or_default()
    }

    /// 获取健康实例
    pub async fn get_healthy_instances(&self, service_name: &str) -> Vec<ServiceInstance> {
        let instances = self.get_service_instances(service_name).await;
        instances.into_iter()
            .filter(|instance| matches!(instance.status, ServiceStatus::Healthy))
            .collect()
    }

    /// 注册服务定义
    pub async fn register_definition(&self, definition: ServiceDefinition) -> Result<(), Box<dyn std::error::Error>> {
        let mut definitions = self.definitions.write().await;
        definitions.insert(definition.name.clone(), definition);
        Ok(())
    }

    /// 获取服务定义
    pub async fn get_definition(&self, service_name: &str) -> Option<ServiceDefinition> {
        let definitions = self.definitions.read().await;
        definitions.get(service_name).cloned()
    }

    /// 启动健康检查
    pub async fn start_health_check(&self) {
        let services = Arc::clone(&self.services);
        let interval_duration = self.health_check_interval;
        
        tokio::spawn(async move {
            let mut interval = interval(interval_duration);
            loop {
                interval.tick().await;
                Self::perform_health_check(&services).await;
            }
        });
    }

    /// 执行健康检查
    async fn perform_health_check(services: &Arc<RwLock<HashMap<String, Vec<ServiceInstance>>>>) {
        let mut services = services.write().await;
        
        for (service_name, instances) in services.iter_mut() {
            for instance in instances.iter_mut() {
                let is_healthy = Self::check_instance_health(instance).await;
                instance.status = if is_healthy {
                    ServiceStatus::Healthy
                } else {
                    ServiceStatus::Unhealthy
                };
                instance.last_heartbeat = Utc::now();
            }
        }
    }

    /// 检查实例健康状态
    async fn check_instance_health(instance: &ServiceInstance) -> bool {
        if let Some(health_url) = &instance.health_check_url {
            let client = reqwest::Client::new();
            if let Ok(response) = client.get(health_url).timeout(Duration::from_secs(5)).send().await {
                return response.status().is_success();
            }
        }
        false
    }
}
```

### 3. 服务发现客户端

```rust
use std::sync::Arc;
use tokio::time::{Duration, Instant};

/// 服务发现客户端
pub struct ServiceDiscoveryClient {
    registry_url: String,
    client: reqwest::Client,
    cache: Arc<RwLock<HashMap<String, Vec<ServiceInstance>>>>,
    cache_ttl: Duration,
}

impl ServiceDiscoveryClient {
    pub fn new(registry_url: String) -> Self {
        Self {
            registry_url,
            client: reqwest::Client::new(),
            cache: Arc::new(RwLock::new(HashMap::new())),
            cache_ttl: Duration::from_secs(60),
        }
    }

    /// 发现服务实例
    pub async fn discover_service(&self, service_name: &str) -> Result<Vec<ServiceInstance>, Box<dyn std::error::Error>> {
        // 先检查缓存
        if let Some(instances) = self.get_from_cache(service_name).await {
            return Ok(instances);
        }

        // 从注册中心获取
        let url = format!("{}/services/{}", self.registry_url, service_name);
        let response = self.client.get(&url).send().await?;
        
        if response.status().is_success() {
            let instances: Vec<ServiceInstance> = response.json().await?;
            self.update_cache(service_name, instances.clone()).await;
            Ok(instances)
        } else {
            Err(format!("服务发现失败: {}", response.status()).into())
        }
    }

    /// 从缓存获取
    async fn get_from_cache(&self, service_name: &str) -> Option<Vec<ServiceInstance>> {
        let cache = self.cache.read().await;
        cache.get(service_name).cloned()
    }

    /// 更新缓存
    async fn update_cache(&self, service_name: &str, instances: Vec<ServiceInstance>) {
        let mut cache = self.cache.write().await;
        cache.insert(service_name.to_string(), instances);
    }
}
```

### 4. 负载均衡器

```rust
use rand::Rng;

/// 负载均衡策略
#[derive(Debug, Clone)]
pub enum LoadBalancingStrategy {
    RoundRobin,
    Random,
    LeastConnections,
    WeightedRoundRobin,
}

/// 负载均衡器
pub struct LoadBalancer {
    strategy: LoadBalancingStrategy,
    current_index: Arc<RwLock<usize>>,
    connection_counts: Arc<RwLock<HashMap<String, u32>>>,
}

impl LoadBalancer {
    pub fn new(strategy: LoadBalancingStrategy) -> Self {
        Self {
            strategy,
            current_index: Arc::new(RwLock::new(0)),
            connection_counts: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// 选择服务实例
    pub async fn select_instance(&self, instances: &[ServiceInstance]) -> Option<ServiceInstance> {
        if instances.is_empty() {
            return None;
        }

        let healthy_instances: Vec<ServiceInstance> = instances
            .iter()
            .filter(|instance| matches!(instance.status, ServiceStatus::Healthy))
            .cloned()
            .collect();

        if healthy_instances.is_empty() {
            return None;
        }

        match self.strategy {
            LoadBalancingStrategy::RoundRobin => self.round_robin(&healthy_instances).await,
            LoadBalancingStrategy::Random => self.random(&healthy_instances),
            LoadBalancingStrategy::LeastConnections => self.least_connections(&healthy_instances).await,
            LoadBalancingStrategy::WeightedRoundRobin => self.weighted_round_robin(&healthy_instances).await,
        }
    }

    /// 轮询策略
    async fn round_robin(&self, instances: &[ServiceInstance]) -> Option<ServiceInstance> {
        let mut current_index = self.current_index.write().await;
        let instance = instances.get(*current_index % instances.len()).cloned();
        *current_index += 1;
        instance
    }

    /// 随机策略
    fn random(&self, instances: &[ServiceInstance]) -> Option<ServiceInstance> {
        let mut rng = rand::thread_rng();
        let index = rng.gen_range(0..instances.len());
        instances.get(index).cloned()
    }

    /// 最少连接策略
    async fn least_connections(&self, instances: &[ServiceInstance]) -> Option<ServiceInstance> {
        let connection_counts = self.connection_counts.read().await;
        
        let selected = instances.iter().min_by_key(|instance| {
            connection_counts.get(&instance.id).unwrap_or(&0)
        });
        
        selected.cloned()
    }

    /// 加权轮询策略
    async fn weighted_round_robin(&self, instances: &[ServiceInstance]) -> Option<ServiceInstance> {
        // 简化实现，实际应该考虑权重
        self.round_robin(instances).await
    }

    /// 增加连接计数
    pub async fn increment_connections(&self, instance_id: &str) {
        let mut connection_counts = self.connection_counts.write().await;
        *connection_counts.entry(instance_id.to_string()).or_insert(0) += 1;
    }

    /// 减少连接计数
    pub async fn decrement_connections(&self, instance_id: &str) {
        let mut connection_counts = self.connection_counts.write().await;
        if let Some(count) = connection_counts.get_mut(instance_id) {
            if *count > 0 {
                *count -= 1;
            }
        }
    }
}
```

### 5. 服务间通信

```rust
/// 服务间通信客户端
pub struct ServiceClient {
    discovery_client: ServiceDiscoveryClient,
    load_balancer: LoadBalancer,
    timeout: Duration,
}

impl ServiceClient {
    pub fn new(registry_url: String, strategy: LoadBalancingStrategy) -> Self {
        Self {
            discovery_client: ServiceDiscoveryClient::new(registry_url),
            load_balancer: LoadBalancer::new(strategy),
            timeout: Duration::from_secs(30),
        }
    }

    /// 调用服务
    pub async fn call_service(
        &self,
        service_name: &str,
        method: &str,
        path: &str,
        body: Option<serde_json::Value>,
    ) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        // 发现服务实例
        let instances = self.discovery_client.discover_service(service_name).await?;
        
        // 选择实例
        let instance = self.load_balancer.select_instance(&instances).await
            .ok_or("没有可用的服务实例")?;
        
        // 增加连接计数
        self.load_balancer.increment_connections(&instance.id).await;
        
        // 构建请求URL
        let url = format!("http://{}:{}{}", instance.host, instance.port, path);
        
        // 发送请求
        let client = reqwest::Client::new();
        let mut request = client.request(
            reqwest::Method::from_bytes(method.as_bytes())?,
            &url,
        ).timeout(self.timeout);
        
        if let Some(body_data) = body {
            request = request.json(&body_data);
        }
        
        let response = request.send().await?;
        
        // 减少连接计数
        self.load_balancer.decrement_connections(&instance.id).await;
        
        if response.status().is_success() {
            let result: serde_json::Value = response.json().await?;
            Ok(result)
        } else {
            Err(format!("服务调用失败: {}", response.status()).into())
        }
    }
}
```

## Go实现

### 1. 服务定义和注册1

```go
package microservice

import (
    "encoding/json"
    "time"
)

// ServiceStatus 服务状态
type ServiceStatus string

const (
    ServiceStatusHealthy   ServiceStatus = "healthy"
    ServiceStatusUnhealthy ServiceStatus = "unhealthy"
    ServiceStatusStarting  ServiceStatus = "starting"
    ServiceStatusStopping  ServiceStatus = "stopping"
)

// ServiceInstance 服务实例
type ServiceInstance struct {
    ID               string            `json:"id"`
    ServiceName      string            `json:"service_name"`
    Host             string            `json:"host"`
    Port             uint16            `json:"port"`
    Status           ServiceStatus     `json:"status"`
    Metadata         map[string]string `json:"metadata"`
    HealthCheckURL   string            `json:"health_check_url,omitempty"`
    LastHeartbeat    time.Time         `json:"last_heartbeat"`
    CreatedAt        time.Time         `json:"created_at"`
}

// ServiceDefinition 服务定义
type ServiceDefinition struct {
    Name         string              `json:"name"`
    Version      string              `json:"version"`
    Description  string              `json:"description"`
    Endpoints    []ServiceEndpoint   `json:"endpoints"`
    Dependencies []string            `json:"dependencies"`
    Config       map[string]interface{} `json:"config"`
}

// ServiceEndpoint 服务端点
type ServiceEndpoint struct {
    Path        string              `json:"path"`
    Method      string              `json:"method"`
    Description string              `json:"description"`
    Parameters  []EndpointParameter `json:"parameters"`
}

// EndpointParameter 端点参数
type EndpointParameter struct {
    Name        string `json:"name"`
    ParamType   string `json:"param_type"`
    Required    bool   `json:"required"`
    Description string `json:"description"`
}
```

### 2. 服务注册中心1

```go
import (
    "fmt"
    "net/http"
    "sync"
    "time"
)

// ServiceRegistry 服务注册中心
type ServiceRegistry struct {
    services              map[string][]ServiceInstance
    definitions           map[string]ServiceDefinition
    healthCheckInterval   time.Duration
    mu                    sync.RWMutex
}

// NewServiceRegistry 创建服务注册中心
func NewServiceRegistry() *ServiceRegistry {
    registry := &ServiceRegistry{
        services:            make(map[string][]ServiceInstance),
        definitions:         make(map[string]ServiceDefinition),
        healthCheckInterval: 30 * time.Second,
    }
    
    // 启动健康检查
    go registry.startHealthCheck()
    
    return registry
}

// RegisterService 注册服务实例
func (r *ServiceRegistry) RegisterService(instance ServiceInstance) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    instances := r.services[instance.ServiceName]
    
    // 检查是否已存在
    for i, existing := range instances {
        if existing.ID == instance.ID {
            instances[i] = instance
            r.services[instance.ServiceName] = instances
            return nil
        }
    }
    
    instances = append(instances, instance)
    r.services[instance.ServiceName] = instances
    return nil
}

// DeregisterService 注销服务实例
func (r *ServiceRegistry) DeregisterService(serviceName, instanceID string) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    instances := r.services[serviceName]
    for i, instance := range instances {
        if instance.ID == instanceID {
            instances = append(instances[:i], instances[i+1:]...)
            r.services[serviceName] = instances
            break
        }
    }
    return nil
}

// GetServiceInstances 获取服务实例
func (r *ServiceRegistry) GetServiceInstances(serviceName string) []ServiceInstance {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    instances, exists := r.services[serviceName]
    if !exists {
        return []ServiceInstance{}
    }
    return instances
}

// GetHealthyInstances 获取健康实例
func (r *ServiceRegistry) GetHealthyInstances(serviceName string) []ServiceInstance {
    instances := r.GetServiceInstances(serviceName)
    var healthyInstances []ServiceInstance
    
    for _, instance := range instances {
        if instance.Status == ServiceStatusHealthy {
            healthyInstances = append(healthyInstances, instance)
        }
    }
    
    return healthyInstances
}

// RegisterDefinition 注册服务定义
func (r *ServiceRegistry) RegisterDefinition(definition ServiceDefinition) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.definitions[definition.Name] = definition
    return nil
}

// GetDefinition 获取服务定义
func (r *ServiceRegistry) GetDefinition(serviceName string) (ServiceDefinition, bool) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    definition, exists := r.definitions[serviceName]
    return definition, exists
}

// startHealthCheck 启动健康检查
func (r *ServiceRegistry) startHealthCheck() {
    ticker := time.NewTicker(r.healthCheckInterval)
    defer ticker.Stop()
    
    for range ticker.C {
        r.performHealthCheck()
    }
}

// performHealthCheck 执行健康检查
func (r *ServiceRegistry) performHealthCheck() {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    for serviceName, instances := range r.services {
        for i, instance := range instances {
            isHealthy := r.checkInstanceHealth(instance)
            if isHealthy {
                instances[i].Status = ServiceStatusHealthy
            } else {
                instances[i].Status = ServiceStatusUnhealthy
            }
            instances[i].LastHeartbeat = time.Now()
        }
        r.services[serviceName] = instances
    }
}

// checkInstanceHealth 检查实例健康状态
func (r *ServiceRegistry) checkInstanceHealth(instance ServiceInstance) bool {
    if instance.HealthCheckURL == "" {
        return true
    }
    
    client := &http.Client{Timeout: 5 * time.Second}
    resp, err := client.Get(instance.HealthCheckURL)
    if err != nil {
        return false
    }
    defer resp.Body.Close()
    
    return resp.StatusCode == http.StatusOK
}
```

### 3. 服务发现客户端1

```go
// ServiceDiscoveryClient 服务发现客户端
type ServiceDiscoveryClient struct {
    registryURL string
    client      *http.Client
    cache       map[string][]ServiceInstance
    cacheTTL    time.Duration
    mu          sync.RWMutex
}

// NewServiceDiscoveryClient 创建服务发现客户端
func NewServiceDiscoveryClient(registryURL string) *ServiceDiscoveryClient {
    return &ServiceDiscoveryClient{
        registryURL: registryURL,
        client:      &http.Client{Timeout: 10 * time.Second},
        cache:       make(map[string][]ServiceInstance),
        cacheTTL:    60 * time.Second,
    }
}

// DiscoverService 发现服务实例
func (c *ServiceDiscoveryClient) DiscoverService(serviceName string) ([]ServiceInstance, error) {
    // 先检查缓存
    if instances := c.getFromCache(serviceName); len(instances) > 0 {
        return instances, nil
    }
    
    // 从注册中心获取
    url := fmt.Sprintf("%s/services/%s", c.registryURL, serviceName)
    resp, err := c.client.Get(url)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode == http.StatusOK {
        var instances []ServiceInstance
        if err := json.NewDecoder(resp.Body).Decode(&instances); err != nil {
            return nil, err
        }
        
        c.updateCache(serviceName, instances)
        return instances, nil
    }
    
    return nil, fmt.Errorf("服务发现失败: %d", resp.StatusCode)
}

// getFromCache 从缓存获取
func (c *ServiceDiscoveryClient) getFromCache(serviceName string) []ServiceInstance {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    instances, exists := c.cache[serviceName]
    if !exists {
        return []ServiceInstance{}
    }
    return instances
}

// updateCache 更新缓存
func (c *ServiceDiscoveryClient) updateCache(serviceName string, instances []ServiceInstance) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.cache[serviceName] = instances
}
```

### 4. 负载均衡器1

```go
import (
    "math/rand"
)

// LoadBalancingStrategy 负载均衡策略
type LoadBalancingStrategy string

const (
    LoadBalancingStrategyRoundRobin       LoadBalancingStrategy = "round_robin"
    LoadBalancingStrategyRandom           LoadBalancingStrategy = "random"
    LoadBalancingStrategyLeastConnections LoadBalancingStrategy = "least_connections"
    LoadBalancingStrategyWeightedRoundRobin LoadBalancingStrategy = "weighted_round_robin"
)

// LoadBalancer 负载均衡器
type LoadBalancer struct {
    strategy         LoadBalancingStrategy
    currentIndex     int
    connectionCounts map[string]uint32
    mu               sync.RWMutex
}

// NewLoadBalancer 创建负载均衡器
func NewLoadBalancer(strategy LoadBalancingStrategy) *LoadBalancer {
    return &LoadBalancer{
        strategy:         strategy,
        connectionCounts: make(map[string]uint32),
    }
}

// SelectInstance 选择服务实例
func (lb *LoadBalancer) SelectInstance(instances []ServiceInstance) *ServiceInstance {
    if len(instances) == 0 {
        return nil
    }
    
    // 过滤健康实例
    var healthyInstances []ServiceInstance
    for _, instance := range instances {
        if instance.Status == ServiceStatusHealthy {
            healthyInstances = append(healthyInstances, instance)
        }
    }
    
    if len(healthyInstances) == 0 {
        return nil
    }
    
    switch lb.strategy {
    case LoadBalancingStrategyRoundRobin:
        return lb.roundRobin(healthyInstances)
    case LoadBalancingStrategyRandom:
        return lb.random(healthyInstances)
    case LoadBalancingStrategyLeastConnections:
        return lb.leastConnections(healthyInstances)
    case LoadBalancingStrategyWeightedRoundRobin:
        return lb.weightedRoundRobin(healthyInstances)
    default:
        return lb.roundRobin(healthyInstances)
    }
}

// roundRobin 轮询策略
func (lb *LoadBalancer) roundRobin(instances []ServiceInstance) *ServiceInstance {
    lb.mu.Lock()
    defer lb.mu.Unlock()
    
    instance := &instances[lb.currentIndex%len(instances)]
    lb.currentIndex++
    return instance
}

// random 随机策略
func (lb *LoadBalancer) random(instances []ServiceInstance) *ServiceInstance {
    index := rand.Intn(len(instances))
    return &instances[index]
}

// leastConnections 最少连接策略
func (lb *LoadBalancer) leastConnections(instances []ServiceInstance) *ServiceInstance {
    lb.mu.RLock()
    defer lb.mu.RUnlock()
    
    var selected *ServiceInstance
    minConnections := uint32(^uint32(0)) // 最大值
    
    for i := range instances {
        connections := lb.connectionCounts[instances[i].ID]
        if connections < minConnections {
            minConnections = connections
            selected = &instances[i]
        }
    }
    
    return selected
}

// weightedRoundRobin 加权轮询策略
func (lb *LoadBalancer) weightedRoundRobin(instances []ServiceInstance) *ServiceInstance {
    // 简化实现，实际应该考虑权重
    return lb.roundRobin(instances)
}

// IncrementConnections 增加连接计数
func (lb *LoadBalancer) IncrementConnections(instanceID string) {
    lb.mu.Lock()
    defer lb.mu.Unlock()
    
    lb.connectionCounts[instanceID]++
}

// DecrementConnections 减少连接计数
func (lb *LoadBalancer) DecrementConnections(instanceID string) {
    lb.mu.Lock()
    defer lb.mu.Unlock()
    
    if count, exists := lb.connectionCounts[instanceID]; exists && count > 0 {
        lb.connectionCounts[instanceID]--
    }
}
```

### 5. 服务间通信1

```go
// ServiceClient 服务间通信客户端
type ServiceClient struct {
    discoveryClient *ServiceDiscoveryClient
    loadBalancer    *LoadBalancer
    timeout         time.Duration
}

// NewServiceClient 创建服务客户端
func NewServiceClient(registryURL string, strategy LoadBalancingStrategy) *ServiceClient {
    return &ServiceClient{
        discoveryClient: NewServiceDiscoveryClient(registryURL),
        loadBalancer:    NewLoadBalancer(strategy),
        timeout:         30 * time.Second,
    }
}

// CallService 调用服务
func (c *ServiceClient) CallService(serviceName, method, path string, body interface{}) (interface{}, error) {
    // 发现服务实例
    instances, err := c.discoveryClient.DiscoverService(serviceName)
    if err != nil {
        return nil, err
    }
    
    // 选择实例
    instance := c.loadBalancer.SelectInstance(instances)
    if instance == nil {
        return nil, fmt.Errorf("没有可用的服务实例")
    }
    
    // 增加连接计数
    c.loadBalancer.IncrementConnections(instance.ID)
    defer c.loadBalancer.DecrementConnections(instance.ID)
    
    // 构建请求URL
    url := fmt.Sprintf("http://%s:%d%s", instance.Host, instance.Port, path)
    
    // 发送请求
    client := &http.Client{Timeout: c.timeout}
    
    var req *http.Request
    var err2 error
    
    if body != nil {
        jsonBody, err := json.Marshal(body)
        if err != nil {
            return nil, err
        }
        
        req, err2 = http.NewRequest(method, url, bytes.NewBuffer(jsonBody))
        if err2 != nil {
            return nil, err2
        }
        req.Header.Set("Content-Type", "application/json")
    } else {
        req, err2 = http.NewRequest(method, url, nil)
        if err2 != nil {
            return nil, err2
        }
    }
    
    resp, err := client.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode == http.StatusOK {
        var result interface{}
        if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
            return nil, err
        }
        return result, nil
    }
    
    return nil, fmt.Errorf("服务调用失败: %d", resp.StatusCode)
}
```

## 使用示例

### Rust示例

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建服务注册中心
    let registry = ServiceRegistry::new();
    
    // 注册服务定义
    let definition = ServiceDefinition {
        name: "user-service".to_string(),
        version: "1.0.0".to_string(),
        description: "用户服务".to_string(),
        endpoints: vec![
            ServiceEndpoint {
                path: "/users".to_string(),
                method: "GET".to_string(),
                description: "获取用户列表".to_string(),
                parameters: vec![],
            }
        ],
        dependencies: vec![],
        config: HashMap::new(),
    };
    registry.register_definition(definition).await?;
    
    // 注册服务实例
    let instance = ServiceInstance {
        id: Uuid::new_v4().to_string(),
        service_name: "user-service".to_string(),
        host: "localhost".to_string(),
        port: 8080,
        status: ServiceStatus::Healthy,
        metadata: HashMap::new(),
        health_check_url: Some("http://localhost:8080/health".to_string()),
        last_heartbeat: Utc::now(),
        created_at: Utc::now(),
    };
    registry.register_service(instance).await?;
    
    // 创建服务客户端
    let client = ServiceClient::new(
        "http://localhost:8081".to_string(),
        LoadBalancingStrategy::RoundRobin,
    );
    
    // 调用服务
    let result = client.call_service(
        "user-service",
        "GET",
        "/users",
        None,
    ).await?;
    
    println!("服务调用结果: {:?}", result);
    
    Ok(())
}
```

### Go示例

```go
func main() {
    // 创建服务注册中心
    registry := NewServiceRegistry()
    
    // 注册服务定义
    definition := ServiceDefinition{
        Name:        "user-service",
        Version:     "1.0.0",
        Description: "用户服务",
        Endpoints: []ServiceEndpoint{
            {
                Path:        "/users",
                Method:      "GET",
                Description: "获取用户列表",
                Parameters:  []EndpointParameter{},
            },
        },
        Dependencies: []string{},
        Config:       make(map[string]interface{}),
    }
    registry.RegisterDefinition(definition)
    
    // 注册服务实例
    instance := ServiceInstance{
        ID:              "instance-1",
        ServiceName:     "user-service",
        Host:            "localhost",
        Port:            8080,
        Status:          ServiceStatusHealthy,
        Metadata:        make(map[string]string),
        HealthCheckURL:  "http://localhost:8080/health",
        LastHeartbeat:   time.Now(),
        CreatedAt:       time.Now(),
    }
    registry.RegisterService(instance)
    
    // 创建服务客户端
    client := NewServiceClient(
        "http://localhost:8081",
        LoadBalancingStrategyRoundRobin,
    )
    
    // 调用服务
    result, err := client.CallService("user-service", "GET", "/users", nil)
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("服务调用结果: %+v\n", result)
}
```

## 总结

微服务架构提供了：

1. **服务注册发现**：自动服务注册和发现机制
2. **负载均衡**：多种负载均衡策略支持
3. **健康检查**：自动健康检查和状态管理
4. **服务间通信**：统一的服务调用接口
5. **服务定义**：标准化的服务描述
6. **缓存机制**：提高服务发现性能
7. **跨语言支持**：Rust和Go双语言实现

这个实现为IoT系统提供了完整的微服务架构基础，支持服务的独立部署、扩展和管理。
