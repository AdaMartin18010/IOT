# 统一数据模型实现

## 1. 时序数据模型

### 1.1 时序数据定义

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

/// 时序数据点
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimeSeriesPoint {
    pub timestamp: DateTime<Utc>,
    pub value: DataValue,
    pub quality: DataQuality,
    pub metadata: HashMap<String, String>,
}

/// 数据值类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DataValue {
    Number(f64),
    Integer(i64),
    Boolean(bool),
    String(String),
    Array(Vec<DataValue>),
    Object(HashMap<String, DataValue>),
    Null,
}

/// 数据质量
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DataQuality {
    Good,
    Uncertain,
    Bad,
    NotApplicable,
}

/// 时序数据序列
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimeSeries {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub unit: Option<String>,
    pub data_type: DataType,
    pub points: Vec<TimeSeriesPoint>,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DataType {
    Float,
    Double,
    Int32,
    Int64,
    Boolean,
    String,
    Timestamp,
    Array,
    Object,
}

/// 时序数据管理器
pub struct TimeSeriesManager {
    series: HashMap<String, TimeSeries>,
    storage: Box<dyn TimeSeriesStorage>,
}

/// 时序数据存储接口
pub trait TimeSeriesStorage: Send + Sync {
    fn store_point(&mut self, series_id: &str, point: TimeSeriesPoint) -> Result<(), Box<dyn std::error::Error>>;
    fn get_points(&self, series_id: &str, start_time: DateTime<Utc>, end_time: DateTime<Utc>) -> Result<Vec<TimeSeriesPoint>, Box<dyn std::error::Error>>;
    fn get_latest_point(&self, series_id: &str) -> Result<Option<TimeSeriesPoint>, Box<dyn std::error::Error>>;
    fn delete_points(&mut self, series_id: &str, start_time: DateTime<Utc>, end_time: DateTime<Utc>) -> Result<(), Box<dyn std::error::Error>>;
}

impl TimeSeriesManager {
    pub fn new(storage: Box<dyn TimeSeriesStorage>) -> Self {
        Self {
            series: HashMap::new(),
            storage,
        }
    }

    /// 创建时序数据序列
    pub fn create_series(&mut self, id: String, name: String, data_type: DataType) -> Result<(), Box<dyn std::error::Error>> {
        let series = TimeSeries {
            id: id.clone(),
            name,
            description: None,
            unit: None,
            data_type,
            points: Vec::new(),
            metadata: HashMap::new(),
        };
        
        self.series.insert(id, series);
        Ok(())
    }

    /// 添加数据点
    pub async fn add_point(&mut self, series_id: &str, point: TimeSeriesPoint) -> Result<(), Box<dyn std::error::Error>> {
        if !self.series.contains_key(series_id) {
            return Err("Time series not found".into());
        }
        
        self.storage.store_point(series_id, point.clone())?;
        
        if let Some(series) = self.series.get_mut(series_id) {
            series.points.push(point);
        }
        
        Ok(())
    }

    /// 查询数据点
    pub async fn query_points(&self, series_id: &str, start_time: DateTime<Utc>, end_time: DateTime<Utc>) -> Result<Vec<TimeSeriesPoint>, Box<dyn std::error::Error>> {
        self.storage.get_points(series_id, start_time, end_time)
    }

    /// 获取最新数据点
    pub async fn get_latest_point(&self, series_id: &str) -> Result<Option<TimeSeriesPoint>, Box<dyn std::error::Error>> {
        self.storage.get_latest_point(series_id)
    }

    /// 聚合查询
    pub async fn aggregate_query(&self, series_id: &str, start_time: DateTime<Utc>, end_time: DateTime<Utc>, aggregation: AggregationType) -> Result<Option<DataValue>, Box<dyn std::error::Error>> {
        let points = self.query_points(series_id, start_time, end_time).await?;
        
        if points.is_empty() {
            return Ok(None);
        }
        
        let values: Vec<f64> = points.iter()
            .filter_map(|point| {
                if let DataValue::Number(n) = point.value {
                    Some(n)
                } else {
                    None
                }
            })
            .collect();
        
        if values.is_empty() {
            return Ok(None);
        }
        
        let result = match aggregation {
            AggregationType::Min => DataValue::Number(values.iter().fold(f64::INFINITY, |a, &b| a.min(b))),
            AggregationType::Max => DataValue::Number(values.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b))),
            AggregationType::Sum => DataValue::Number(values.iter().sum()),
            AggregationType::Average => DataValue::Number(values.iter().sum::<f64>() / values.len() as f64),
            AggregationType::Count => DataValue::Integer(values.len() as i64),
        };
        
        Ok(Some(result))
    }
}

#[derive(Debug, Clone)]
pub enum AggregationType {
    Min,
    Max,
    Sum,
    Average,
    Count,
}
```

### 1.2 内存存储实现

```rust
use std::collections::BTreeMap;

/// 内存时序数据存储
pub struct InMemoryTimeSeriesStorage {
    data: HashMap<String, BTreeMap<DateTime<Utc>, TimeSeriesPoint>>,
}

impl InMemoryTimeSeriesStorage {
    pub fn new() -> Self {
        Self {
            data: HashMap::new(),
        }
    }
}

impl TimeSeriesStorage for InMemoryTimeSeriesStorage {
    fn store_point(&mut self, series_id: &str, point: TimeSeriesPoint) -> Result<(), Box<dyn std::error::Error>> {
        self.data.entry(series_id.to_string())
            .or_insert_with(BTreeMap::new)
            .insert(point.timestamp, point);
        Ok(())
    }

    fn get_points(&self, series_id: &str, start_time: DateTime<Utc>, end_time: DateTime<Utc>) -> Result<Vec<TimeSeriesPoint>, Box<dyn std::error::Error>> {
        if let Some(series_data) = self.data.get(series_id) {
            let points: Vec<TimeSeriesPoint> = series_data.range(start_time..=end_time)
                .map(|(_, point)| point.clone())
                .collect();
            Ok(points)
        } else {
            Ok(Vec::new())
        }
    }

    fn get_latest_point(&self, series_id: &str) -> Result<Option<TimeSeriesPoint>, Box<dyn std::error::Error>> {
        if let Some(series_data) = self.data.get(series_id) {
            Ok(series_data.iter().next_back().map(|(_, point)| point.clone()))
        } else {
            Ok(None)
        }
    }

    fn delete_points(&mut self, series_id: &str, start_time: DateTime<Utc>, end_time: DateTime<Utc>) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(series_data) = self.data.get_mut(series_id) {
            let keys_to_remove: Vec<DateTime<Utc>> = series_data.range(start_time..=end_time)
                .map(|(timestamp, _)| *timestamp)
                .collect();
            
            for key in keys_to_remove {
                series_data.remove(&key);
            }
        }
        Ok(())
    }
}
```

## 2. 图数据模型

### 2.1 图数据结构

```rust
use std::collections::{HashMap, HashSet};

/// 图节点
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphNode {
    pub id: String,
    pub label: String,
    pub node_type: String,
    pub properties: HashMap<String, DataValue>,
    pub metadata: HashMap<String, String>,
}

/// 图边
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphEdge {
    pub id: String,
    pub source_id: String,
    pub target_id: String,
    pub edge_type: String,
    pub properties: HashMap<String, DataValue>,
    pub metadata: HashMap<String, String>,
}

/// 图数据
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Graph {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub nodes: HashMap<String, GraphNode>,
    pub edges: HashMap<String, GraphEdge>,
    pub metadata: HashMap<String, String>,
}

/// 图数据管理器
pub struct GraphManager {
    graphs: HashMap<String, Graph>,
    storage: Box<dyn GraphStorage>,
}

/// 图数据存储接口
pub trait GraphStorage: Send + Sync {
    fn store_node(&mut self, graph_id: &str, node: GraphNode) -> Result<(), Box<dyn std::error::Error>>;
    fn store_edge(&mut self, graph_id: &str, edge: GraphEdge) -> Result<(), Box<dyn std::error::Error>>;
    fn get_node(&self, graph_id: &str, node_id: &str) -> Result<Option<GraphNode>, Box<dyn std::error::Error>>;
    fn get_edge(&self, graph_id: &str, edge_id: &str) -> Result<Option<GraphEdge>, Box<dyn std::error::Error>>;
    fn get_neighbors(&self, graph_id: &str, node_id: &str) -> Result<Vec<GraphNode>, Box<dyn std::error::Error>>;
    fn delete_node(&mut self, graph_id: &str, node_id: &str) -> Result<(), Box<dyn std::error::Error>>;
    fn delete_edge(&mut self, graph_id: &str, edge_id: &str) -> Result<(), Box<dyn std::error::Error>>;
}

impl GraphManager {
    pub fn new(storage: Box<dyn GraphStorage>) -> Self {
        Self {
            graphs: HashMap::new(),
            storage,
        }
    }

    /// 创建图
    pub fn create_graph(&mut self, id: String, name: String) -> Result<(), Box<dyn std::error::Error>> {
        let graph = Graph {
            id: id.clone(),
            name,
            description: None,
            nodes: HashMap::new(),
            edges: HashMap::new(),
            metadata: HashMap::new(),
        };
        
        self.graphs.insert(id, graph);
        Ok(())
    }

    /// 添加节点
    pub async fn add_node(&mut self, graph_id: &str, node: GraphNode) -> Result<(), Box<dyn std::error::Error>> {
        if !self.graphs.contains_key(graph_id) {
            return Err("Graph not found".into());
        }
        
        self.storage.store_node(graph_id, node.clone())?;
        
        if let Some(graph) = self.graphs.get_mut(graph_id) {
            graph.nodes.insert(node.id.clone(), node);
        }
        
        Ok(())
    }

    /// 添加边
    pub async fn add_edge(&mut self, graph_id: &str, edge: GraphEdge) -> Result<(), Box<dyn std::error::Error>> {
        if !self.graphs.contains_key(graph_id) {
            return Err("Graph not found".into());
        }
        
        self.storage.store_edge(graph_id, edge.clone())?;
        
        if let Some(graph) = self.graphs.get_mut(graph_id) {
            graph.edges.insert(edge.id.clone(), edge);
        }
        
        Ok(())
    }

    /// 查询节点
    pub async fn get_node(&self, graph_id: &str, node_id: &str) -> Result<Option<GraphNode>, Box<dyn std::error::Error>> {
        self.storage.get_node(graph_id, node_id)
    }

    /// 查询邻居节点
    pub async fn get_neighbors(&self, graph_id: &str, node_id: &str) -> Result<Vec<GraphNode>, Box<dyn std::error::Error>> {
        self.storage.get_neighbors(graph_id, node_id)
    }

    /// 图遍历
    pub async fn traverse(&self, graph_id: &str, start_node_id: &str, traversal_type: TraversalType) -> Result<Vec<GraphNode>, Box<dyn std::error::Error>> {
        match traversal_type {
            TraversalType::BFS => self.breadth_first_search(graph_id, start_node_id).await,
            TraversalType::DFS => self.depth_first_search(graph_id, start_node_id).await,
        }
    }

    /// 广度优先搜索
    async fn breadth_first_search(&self, graph_id: &str, start_node_id: &str) -> Result<Vec<GraphNode>, Box<dyn std::error::Error>> {
        let mut visited = HashSet::new();
        let mut queue = std::collections::VecDeque::new();
        let mut result = Vec::new();
        
        queue.push_back(start_node_id.to_string());
        visited.insert(start_node_id.to_string());
        
        while let Some(node_id) = queue.pop_front() {
            if let Some(node) = self.get_node(graph_id, &node_id).await? {
                result.push(node.clone());
                
                let neighbors = self.get_neighbors(graph_id, &node_id).await?;
                for neighbor in neighbors {
                    if !visited.contains(&neighbor.id) {
                        visited.insert(neighbor.id.clone());
                        queue.push_back(neighbor.id);
                    }
                }
            }
        }
        
        Ok(result)
    }

    /// 深度优先搜索
    async fn depth_first_search(&self, graph_id: &str, start_node_id: &str) -> Result<Vec<GraphNode>, Box<dyn std::error::Error>> {
        let mut visited = HashSet::new();
        let mut result = Vec::new();
        
        self.dfs_recursive(graph_id, start_node_id, &mut visited, &mut result).await?;
        
        Ok(result)
    }

    /// 递归深度优先搜索
    async fn dfs_recursive(&self, graph_id: &str, node_id: &str, visited: &mut HashSet<String>, result: &mut Vec<GraphNode>) -> Result<(), Box<dyn std::error::Error>> {
        if visited.contains(node_id) {
            return Ok(());
        }
        
        visited.insert(node_id.to_string());
        
        if let Some(node) = self.get_node(graph_id, node_id).await? {
            result.push(node.clone());
            
            let neighbors = self.get_neighbors(graph_id, node_id).await?;
            for neighbor in neighbors {
                self.dfs_recursive(graph_id, &neighbor.id, visited, result).await?;
            }
        }
        
        Ok(())
    }

    /// 路径查找
    pub async fn find_path(&self, graph_id: &str, start_node_id: &str, end_node_id: &str) -> Result<Option<Vec<GraphNode>>, Box<dyn std::error::Error>> {
        let mut visited = HashSet::new();
        let mut queue = std::collections::VecDeque::new();
        let mut parent = HashMap::new();
        
        queue.push_back(start_node_id.to_string());
        visited.insert(start_node_id.to_string());
        
        while let Some(node_id) = queue.pop_front() {
            if node_id == end_node_id {
                // 重建路径
                let mut path = Vec::new();
                let mut current = &node_id;
                
                while let Some(node) = self.get_node(graph_id, current).await? {
                    path.push(node);
                    if let Some(parent_id) = parent.get(current) {
                        current = parent_id;
                    } else {
                        break;
                    }
                }
                
                path.reverse();
                return Ok(Some(path));
            }
            
            let neighbors = self.get_neighbors(graph_id, &node_id).await?;
            for neighbor in neighbors {
                if !visited.contains(&neighbor.id) {
                    visited.insert(neighbor.id.clone());
                    parent.insert(neighbor.id.clone(), node_id.clone());
                    queue.push_back(neighbor.id);
                }
            }
        }
        
        Ok(None)
    }
}

#[derive(Debug, Clone)]
pub enum TraversalType {
    BFS,
    DFS,
}
```

### 2.2 内存图存储实现

```rust
/// 内存图数据存储
pub struct InMemoryGraphStorage {
    graphs: HashMap<String, HashMap<String, GraphNode>>,
    edges: HashMap<String, HashMap<String, GraphEdge>>,
    adjacency: HashMap<String, HashMap<String, Vec<String>>>, // node_id -> neighbor_ids
}

impl InMemoryGraphStorage {
    pub fn new() -> Self {
        Self {
            graphs: HashMap::new(),
            edges: HashMap::new(),
            adjacency: HashMap::new(),
        }
    }
}

impl GraphStorage for InMemoryGraphStorage {
    fn store_node(&mut self, graph_id: &str, node: GraphNode) -> Result<(), Box<dyn std::error::Error>> {
        self.graphs.entry(graph_id.to_string())
            .or_insert_with(HashMap::new)
            .insert(node.id.clone(), node);
        
        self.adjacency.entry(graph_id.to_string())
            .or_insert_with(HashMap::new)
            .insert(node.id.clone(), Vec::new());
        
        Ok(())
    }

    fn store_edge(&mut self, graph_id: &str, edge: GraphEdge) -> Result<(), Box<dyn std::error::Error>> {
        self.edges.entry(graph_id.to_string())
            .or_insert_with(HashMap::new)
            .insert(edge.id.clone(), edge.clone());
        
        // 更新邻接表
        if let Some(adjacency) = self.adjacency.get_mut(graph_id) {
            adjacency.entry(edge.source_id.clone())
                .or_insert_with(Vec::new)
                .push(edge.target_id.clone());
        }
        
        Ok(())
    }

    fn get_node(&self, graph_id: &str, node_id: &str) -> Result<Option<GraphNode>, Box<dyn std::error::Error>> {
        Ok(self.graphs.get(graph_id)
            .and_then(|nodes| nodes.get(node_id))
            .cloned())
    }

    fn get_edge(&self, graph_id: &str, edge_id: &str) -> Result<Option<GraphEdge>, Box<dyn std::error::Error>> {
        Ok(self.edges.get(graph_id)
            .and_then(|edges| edges.get(edge_id))
            .cloned())
    }

    fn get_neighbors(&self, graph_id: &str, node_id: &str) -> Result<Vec<GraphNode>, Box<dyn std::error::Error>> {
        let mut neighbors = Vec::new();
        
        if let Some(adjacency) = self.adjacency.get(graph_id) {
            if let Some(neighbor_ids) = adjacency.get(node_id) {
                for neighbor_id in neighbor_ids {
                    if let Some(node) = self.get_node(graph_id, neighbor_id)? {
                        neighbors.push(node);
                    }
                }
            }
        }
        
        Ok(neighbors)
    }

    fn delete_node(&mut self, graph_id: &str, node_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        // 删除节点
        if let Some(nodes) = self.graphs.get_mut(graph_id) {
            nodes.remove(node_id);
        }
        
        // 删除相关边
        if let Some(edges) = self.edges.get_mut(graph_id) {
            let edge_ids_to_remove: Vec<String> = edges.iter()
                .filter(|(_, edge)| edge.source_id == node_id || edge.target_id == node_id)
                .map(|(id, _)| id.clone())
                .collect();
            
            for edge_id in edge_ids_to_remove {
                edges.remove(&edge_id);
            }
        }
        
        // 更新邻接表
        if let Some(adjacency) = self.adjacency.get_mut(graph_id) {
            adjacency.remove(node_id);
            
            for neighbors in adjacency.values_mut() {
                neighbors.retain(|id| id != node_id);
            }
        }
        
        Ok(())
    }

    fn delete_edge(&mut self, graph_id: &str, edge_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(edges) = self.edges.get_mut(graph_id) {
            if let Some(edge) = edges.remove(edge_id) {
                // 更新邻接表
                if let Some(adjacency) = self.adjacency.get_mut(graph_id) {
                    if let Some(neighbors) = adjacency.get_mut(&edge.source_id) {
                        neighbors.retain(|id| id != &edge.target_id);
                    }
                }
            }
        }
        
        Ok(())
    }
}
```

## 3. 统一数据模型

### 3.1 数据模型管理器

```rust
/// 统一数据模型管理器
pub struct UnifiedDataModel {
    time_series_manager: TimeSeriesManager,
    graph_manager: GraphManager,
    model_mappings: HashMap<String, ModelMapping>,
}

/// 模型映射
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelMapping {
    pub source_model: String,
    pub target_model: String,
    pub mapping_rules: Vec<MappingRule>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MappingRule {
    pub source_field: String,
    pub target_field: String,
    pub transformation: TransformationType,
    pub parameters: HashMap<String, DataValue>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TransformationType {
    Direct,
    Function(String),
    Aggregate(AggregationType),
    Filter(String),
    Transform(String),
}

impl UnifiedDataModel {
    pub fn new(time_series_storage: Box<dyn TimeSeriesStorage>, graph_storage: Box<dyn GraphStorage>) -> Self {
        Self {
            time_series_manager: TimeSeriesManager::new(time_series_storage),
            graph_manager: GraphManager::new(graph_storage),
            model_mappings: HashMap::new(),
        }
    }

    /// 添加模型映射
    pub fn add_model_mapping(&mut self, mapping: ModelMapping) {
        let key = format!("{}->{}", mapping.source_model, mapping.target_model);
        self.model_mappings.insert(key, mapping);
    }

    /// 转换数据模型
    pub async fn transform_data(&self, source_data: DataValue, source_model: &str, target_model: &str) -> Result<DataValue, Box<dyn std::error::Error>> {
        let key = format!("{}->{}", source_model, target_model);
        
        if let Some(mapping) = self.model_mappings.get(&key) {
            self.apply_mapping(source_data, mapping).await
        } else {
            Err("No mapping found".into())
        }
    }

    /// 应用映射规则
    async fn apply_mapping(&self, source_data: DataValue, mapping: &ModelMapping) -> Result<DataValue, Box<dyn std::error::Error>> {
        let mut target_data = DataValue::Object(HashMap::new());
        
        for rule in &mapping.mapping_rules {
            let source_value = self.extract_field_value(&source_data, &rule.source_field)?;
            let transformed_value = self.apply_transformation(source_value, rule).await?;
            self.set_field_value(&mut target_data, &rule.target_field, transformed_value)?;
        }
        
        Ok(target_data)
    }

    /// 提取字段值
    fn extract_field_value(&self, data: &DataValue, field_path: &str) -> Result<DataValue, Box<dyn std::error::Error>> {
        let parts: Vec<&str> = field_path.split('.').collect();
        let mut current = data;
        
        for part in parts {
            match current {
                DataValue::Object(map) => {
                    current = map.get(part).ok_or("Field not found")?;
                }
                DataValue::Array(arr) => {
                    let index: usize = part.parse()?;
                    current = arr.get(index).ok_or("Array index out of bounds")?;
                }
                _ => return Err("Invalid field path".into()),
            }
        }
        
        Ok(current.clone())
    }

    /// 设置字段值
    fn set_field_value(&self, data: &mut DataValue, field_path: &str, value: DataValue) -> Result<(), Box<dyn std::error::Error>> {
        let parts: Vec<&str> = field_path.split('.').collect();
        
        if let DataValue::Object(map) = data {
            if parts.len() == 1 {
                map.insert(parts[0].to_string(), value);
            } else {
                // 处理嵌套字段
                let mut current = map.entry(parts[0].to_string())
                    .or_insert_with(|| DataValue::Object(HashMap::new()));
                
                for part in &parts[1..parts.len()-1] {
                    if let DataValue::Object(nested_map) = current {
                        current = nested_map.entry(part.to_string())
                            .or_insert_with(|| DataValue::Object(HashMap::new()));
                    } else {
                        return Err("Invalid nested field".into());
                    }
                }
                
                if let DataValue::Object(final_map) = current {
                    final_map.insert(parts[parts.len()-1].to_string(), value);
                }
            }
        }
        
        Ok(())
    }

    /// 应用转换
    async fn apply_transformation(&self, value: DataValue, rule: &MappingRule) -> Result<DataValue, Box<dyn std::error::Error>> {
        match &rule.transformation {
            TransformationType::Direct => Ok(value),
            TransformationType::Function(func_name) => {
                self.apply_function(value, func_name, &rule.parameters).await
            }
            TransformationType::Aggregate(agg_type) => {
                self.apply_aggregation(value, agg_type).await
            }
            TransformationType::Filter(filter_expr) => {
                self.apply_filter(value, filter_expr).await
            }
            TransformationType::Transform(transform_expr) => {
                self.apply_transform(value, transform_expr).await
            }
        }
    }

    /// 应用函数
    async fn apply_function(&self, value: DataValue, func_name: &str, parameters: &HashMap<String, DataValue>) -> Result<DataValue, Box<dyn std::error::Error>> {
        match func_name {
            "to_string" => {
                Ok(DataValue::String(value.to_string()))
            }
            "to_number" => {
                if let DataValue::String(s) = value {
                    if let Ok(n) = s.parse::<f64>() {
                        Ok(DataValue::Number(n))
                    } else {
                        Err("Cannot convert to number".into())
                    }
                } else {
                    Err("Invalid input for to_number".into())
                }
            }
            "format_timestamp" => {
                // 实现时间戳格式化
                Ok(value)
            }
            _ => Err(format!("Unknown function: {}", func_name).into()),
        }
    }

    /// 应用聚合
    async fn apply_aggregation(&self, value: DataValue, agg_type: &AggregationType) -> Result<DataValue, Box<dyn std::error::Error>> {
        if let DataValue::Array(arr) = value {
            let numbers: Vec<f64> = arr.iter()
                .filter_map(|v| {
                    if let DataValue::Number(n) = v {
                        Some(*n)
                    } else {
                        None
                    }
                })
                .collect();
            
            if numbers.is_empty() {
                return Ok(DataValue::Null);
            }
            
            let result = match agg_type {
                AggregationType::Min => DataValue::Number(numbers.iter().fold(f64::INFINITY, |a, &b| a.min(b))),
                AggregationType::Max => DataValue::Number(numbers.iter().fold(f64::NEG_INFINITY, |a, &b| a.max(b))),
                AggregationType::Sum => DataValue::Number(numbers.iter().sum()),
                AggregationType::Average => DataValue::Number(numbers.iter().sum::<f64>() / numbers.len() as f64),
                AggregationType::Count => DataValue::Integer(numbers.len() as i64),
            };
            
            Ok(result)
        } else {
            Err("Aggregation requires array input".into())
        }
    }

    /// 应用过滤
    async fn apply_filter(&self, value: DataValue, filter_expr: &str) -> Result<DataValue, Box<dyn std::error::Error>> {
        // 简化的过滤实现
        // 实际实现应该支持复杂的表达式解析
        Ok(value)
    }

    /// 应用转换
    async fn apply_transform(&self, value: DataValue, transform_expr: &str) -> Result<DataValue, Box<dyn std::error::Error>> {
        // 简化的转换实现
        // 实际实现应该支持复杂的表达式解析
        Ok(value)
    }
}
```

## 4. 应用示例

### 4.1 IoT数据统一建模

```rust
use crate::data_model::{UnifiedDataModel, TimeSeriesManager, GraphManager, InMemoryTimeSeriesStorage, InMemoryGraphStorage};

async fn iot_data_unified_modeling() -> Result<(), Box<dyn std::error::Error>> {
    // 创建统一数据模型
    let time_series_storage = Box::new(InMemoryTimeSeriesStorage::new());
    let graph_storage = Box::new(InMemoryGraphStorage::new());
    let mut unified_model = UnifiedDataModel::new(time_series_storage, graph_storage);
    
    // 创建时序数据序列
    let mut time_series_manager = &mut unified_model.time_series_manager;
    time_series_manager.create_series("temp_sensor_001".to_string(), "Temperature Sensor 001".to_string(), DataType::Float)?;
    
    // 添加时序数据点
    let point = TimeSeriesPoint {
        timestamp: Utc::now(),
        value: DataValue::Number(23.5),
        quality: DataQuality::Good,
        metadata: HashMap::new(),
    };
    
    time_series_manager.add_point("temp_sensor_001", point).await?;
    
    // 创建图数据
    let mut graph_manager = &mut unified_model.graph_manager;
    graph_manager.create_graph("iot_network".to_string(), "IoT Device Network".to_string())?;
    
    // 添加设备节点
    let sensor_node = GraphNode {
        id: "sensor_001".to_string(),
        label: "Temperature Sensor".to_string(),
        node_type: "Sensor".to_string(),
        properties: {
            let mut props = HashMap::new();
            props.insert("type".to_string(), DataValue::String("temperature".to_string()));
            props.insert("location".to_string(), DataValue::String("room_101".to_string()));
            props
        },
        metadata: HashMap::new(),
    };
    
    let gateway_node = GraphNode {
        id: "gateway_001".to_string(),
        label: "IoT Gateway".to_string(),
        node_type: "Gateway".to_string(),
        properties: {
            let mut props = HashMap::new();
            props.insert("protocol".to_string(), DataValue::String("MQTT".to_string()));
            props.insert("ip_address".to_string(), DataValue::String("192.168.1.100".to_string()));
            props
        },
        metadata: HashMap::new(),
    };
    
    graph_manager.add_node("iot_network", sensor_node).await?;
    graph_manager.add_node("iot_network", gateway_node).await?;
    
    // 添加连接边
    let connection_edge = GraphEdge {
        id: "conn_001".to_string(),
        source_id: "sensor_001".to_string(),
        target_id: "gateway_001".to_string(),
        edge_type: "connects_to".to_string(),
        properties: {
            let mut props = HashMap::new();
            props.insert("protocol".to_string(), DataValue::String("WiFi".to_string()));
            props.insert("signal_strength".to_string(), DataValue::Number(-45.0));
            props
        },
        metadata: HashMap::new(),
    };
    
    graph_manager.add_edge("iot_network", connection_edge).await?;
    
    // 定义模型映射
    let mapping = ModelMapping {
        source_model: "opcua".to_string(),
        target_model: "wot".to_string(),
        mapping_rules: vec![
            MappingRule {
                source_field: "value".to_string(),
                target_field: "properties.temperature".to_string(),
                transformation: TransformationType::Direct,
                parameters: HashMap::new(),
            },
            MappingRule {
                source_field: "timestamp".to_string(),
                target_field: "properties.timestamp".to_string(),
                transformation: TransformationType::Function("format_timestamp".to_string()),
                parameters: HashMap::new(),
            },
        ],
    };
    
    unified_model.add_model_mapping(mapping);
    
    // 转换数据
    let source_data = DataValue::Object({
        let mut map = HashMap::new();
        map.insert("value".to_string(), DataValue::Number(23.5));
        map.insert("timestamp".to_string(), DataValue::String("2024-01-01T12:00:00Z".to_string()));
        map
    });
    
    let transformed_data = unified_model.transform_data(source_data, "opcua", "wot").await?;
    println!("转换后的数据: {:?}", transformed_data);
    
    // 查询时序数据
    let end_time = Utc::now();
    let start_time = end_time - chrono::Duration::hours(1);
    let points = time_series_manager.query_points("temp_sensor_001", start_time, end_time).await?;
    println!("查询到 {} 个数据点", points.len());
    
    // 图遍历
    let neighbors = graph_manager.get_neighbors("iot_network", "sensor_001").await?;
    println!("传感器001的邻居节点: {:?}", neighbors);
    
    Ok(())
}
```

## 5. 总结

本实现提供了：

1. **时序数据模型** - 完整的时间序列数据管理
2. **图数据模型** - 图结构和图算法支持
3. **统一数据模型** - 不同数据模型间的转换
4. **数据存储接口** - 可扩展的存储后端
5. **实际应用示例** - IoT数据统一建模场景

这个统一数据模型系统为IoT平台提供了强大的数据建模和管理能力，支持时序数据和图数据的统一处理。
