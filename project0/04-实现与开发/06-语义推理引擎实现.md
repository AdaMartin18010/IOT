# 语义推理引擎实现

## 1. OWL2-RL推理引擎

### 1.1 核心推理规则

```rust
use std::collections::{HashMap, HashSet};
use serde::{Deserialize, Serialize};

/// OWL2-RL推理规则
#[derive(Debug, Clone)]
pub enum InferenceRule {
    // 类层次推理
    SubClassOf,
    EquivalentClass,
    DisjointClass,
    
    // 属性推理
    SubPropertyOf,
    EquivalentProperty,
    InverseProperty,
    TransitiveProperty,
    
    // 实例推理
    ClassAssertion,
    PropertyAssertion,
    SameAs,
    DifferentFrom,
}

/// 本体概念
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Concept {
    pub iri: String,
    pub label: String,
    pub description: Option<String>,
}

/// 本体属性
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Property {
    pub iri: String,
    pub label: String,
    pub domain: Option<String>,
    pub range: Option<String>,
    pub is_transitive: bool,
    pub is_symmetric: bool,
    pub is_functional: bool,
}

/// 本体实例
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Instance {
    pub iri: String,
    pub label: String,
    pub types: Vec<String>,
    pub properties: HashMap<String, Vec<String>>,
}

/// OWL2-RL推理引擎
pub struct OWL2RLReasoner {
    concepts: HashMap<String, Concept>,
    properties: HashMap<String, Property>,
    instances: HashMap<String, Instance>,
    sub_class_of: HashMap<String, HashSet<String>>,
    sub_property_of: HashMap<String, HashSet<String>>,
    class_assertions: HashMap<String, HashSet<String>>,
    property_assertions: HashMap<String, Vec<(String, String)>>,
}

impl OWL2RLReasoner {
    pub fn new() -> Self {
        Self {
            concepts: HashMap::new(),
            properties: HashMap::new(),
            instances: HashMap::new(),
            sub_class_of: HashMap::new(),
            sub_property_of: HashMap::new(),
            class_assertions: HashMap::new(),
            property_assertions: HashMap::new(),
        }
    }

    /// 添加概念
    pub fn add_concept(&mut self, concept: Concept) {
        self.concepts.insert(concept.iri.clone(), concept);
    }

    /// 添加属性
    pub fn add_property(&mut self, property: Property) {
        self.properties.insert(property.iri.clone(), property);
    }

    /// 添加实例
    pub fn add_instance(&mut self, instance: Instance) {
        self.instances.insert(instance.iri.clone(), instance);
    }

    /// 添加子类关系
    pub fn add_sub_class_of(&mut self, sub_class: String, super_class: String) {
        self.sub_class_of
            .entry(sub_class)
            .or_insert_with(HashSet::new)
            .insert(super_class);
    }

    /// 添加子属性关系
    pub fn add_sub_property_of(&mut self, sub_property: String, super_property: String) {
        self.sub_property_of
            .entry(sub_property)
            .or_insert_with(HashSet::new)
            .insert(super_property);
    }

    /// 添加类断言
    pub fn add_class_assertion(&mut self, instance: String, class: String) {
        self.class_assertions
            .entry(instance)
            .or_insert_with(HashSet::new)
            .insert(class);
    }

    /// 添加属性断言
    pub fn add_property_assertion(&mut self, subject: String, property: String, object: String) {
        self.property_assertions
            .entry(subject)
            .or_insert_with(Vec::new)
            .push((property, object));
    }

    /// 执行推理
    pub fn reason(&mut self) -> Result<Vec<InferenceResult>, Box<dyn std::error::Error>> {
        let mut results = Vec::new();
        
        // 执行子类推理
        results.extend(self.infer_sub_classes()?);
        
        // 执行子属性推理
        results.extend(self.infer_sub_properties()?);
        
        // 执行实例类型推理
        results.extend(self.infer_instance_types()?);
        
        // 执行属性推理
        results.extend(self.infer_properties()?);
        
        Ok(results)
    }

    /// 子类推理
    fn infer_sub_classes(&self) -> Result<Vec<InferenceResult>, Box<dyn std::error::Error>> {
        let mut results = Vec::new();
        
        for (sub_class, super_classes) in &self.sub_class_of {
            for super_class in super_classes {
                // 查找传递闭包
                if let Some(transitive_supers) = self.sub_class_of.get(super_class) {
                    for transitive_super in transitive_supers {
                        results.push(InferenceResult {
                            rule: InferenceRule::SubClassOf,
                            subject: sub_class.clone(),
                            predicate: "rdfs:subClassOf".to_string(),
                            object: transitive_super.clone(),
                            confidence: 1.0,
                        });
                    }
                }
            }
        }
        
        Ok(results)
    }

    /// 子属性推理
    fn infer_sub_properties(&self) -> Result<Vec<InferenceResult>, Box<dyn std::error::Error>> {
        let mut results = Vec::new();
        
        for (sub_property, super_properties) in &self.sub_property_of {
            for super_property in super_properties {
                // 查找传递闭包
                if let Some(transitive_supers) = self.sub_property_of.get(super_property) {
                    for transitive_super in transitive_supers {
                        results.push(InferenceResult {
                            rule: InferenceRule::SubPropertyOf,
                            subject: sub_property.clone(),
                            predicate: "rdfs:subPropertyOf".to_string(),
                            object: transitive_super.clone(),
                            confidence: 1.0,
                        });
                    }
                }
            }
        }
        
        Ok(results)
    }

    /// 实例类型推理
    fn infer_instance_types(&self) -> Result<Vec<InferenceResult>, Box<dyn std::error::Error>> {
        let mut results = Vec::new();
        
        for (instance, classes) in &self.class_assertions {
            for class in classes {
                // 查找子类
                if let Some(sub_classes) = self.sub_class_of.get(class) {
                    for sub_class in sub_classes {
                        results.push(InferenceResult {
                            rule: InferenceRule::ClassAssertion,
                            subject: instance.clone(),
                            predicate: "rdf:type".to_string(),
                            object: sub_class.clone(),
                            confidence: 1.0,
                        });
                    }
                }
            }
        }
        
        Ok(results)
    }

    /// 属性推理
    fn infer_properties(&self) -> Result<Vec<InferenceResult>, Box<dyn std::error::Error>> {
        let mut results = Vec::new();
        
        for (subject, assertions) in &self.property_assertions {
            for (property, object) in assertions {
                // 查找子属性
                if let Some(sub_properties) = self.sub_property_of.get(property) {
                    for sub_property in sub_properties {
                        results.push(InferenceResult {
                            rule: InferenceRule::PropertyAssertion,
                            subject: subject.clone(),
                            predicate: sub_property.clone(),
                            object: object.clone(),
                            confidence: 1.0,
                        });
                    }
                }
                
                // 处理传递属性
                if let Some(prop) = self.properties.get(property) {
                    if prop.is_transitive {
                        // 查找传递关系
                        if let Some(object_assertions) = self.property_assertions.get(object) {
                            for (obj_property, obj_object) in object_assertions {
                                if obj_property == property {
                                    results.push(InferenceResult {
                                        rule: InferenceRule::TransitiveProperty,
                                        subject: subject.clone(),
                                        predicate: property.clone(),
                                        object: obj_object.clone(),
                                        confidence: 1.0,
                                    });
                                }
                            }
                        }
                    }
                }
            }
        }
        
        Ok(results)
    }

    /// 查询实例
    pub fn query_instances(&self, class: &str) -> Vec<&Instance> {
        let mut instances = Vec::new();
        
        for instance in self.instances.values() {
            if instance.types.contains(&class.to_string()) {
                instances.push(instance);
            }
        }
        
        instances
    }

    /// 查询属性值
    pub fn query_property_values(&self, subject: &str, property: &str) -> Vec<String> {
        let mut values = Vec::new();
        
        if let Some(assertions) = self.property_assertions.get(subject) {
            for (prop, object) in assertions {
                if prop == property {
                    values.push(object.clone());
                }
            }
        }
        
        values
    }
}

/// 推理结果
#[derive(Debug, Clone)]
pub struct InferenceResult {
    pub rule: InferenceRule,
    pub subject: String,
    pub predicate: String,
    pub object: String,
    pub confidence: f64,
}
```

### 1.2 Go实现

```go
package reasoning

import (
    "fmt"
    "sync"
)

// InferenceRule 推理规则
type InferenceRule string

const (
    SubClassOf        InferenceRule = "SubClassOf"
    EquivalentClass   InferenceRule = "EquivalentClass"
    DisjointClass     InferenceRule = "DisjointClass"
    SubPropertyOf     InferenceRule = "SubPropertyOf"
    EquivalentProperty InferenceRule = "EquivalentProperty"
    InverseProperty   InferenceRule = "InverseProperty"
    TransitiveProperty InferenceRule = "TransitiveProperty"
    ClassAssertion    InferenceRule = "ClassAssertion"
    PropertyAssertion InferenceRule = "PropertyAssertion"
    SameAs            InferenceRule = "SameAs"
    DifferentFrom     InferenceRule = "DifferentFrom"
)

// Concept 概念
type Concept struct {
    IRI         string `json:"iri"`
    Label       string `json:"label"`
    Description string `json:"description,omitempty"`
}

// Property 属性
type Property struct {
    IRI           string `json:"iri"`
    Label         string `json:"label"`
    Domain        string `json:"domain,omitempty"`
    Range         string `json:"range,omitempty"`
    IsTransitive  bool   `json:"isTransitive"`
    IsSymmetric   bool   `json:"isSymmetric"`
    IsFunctional  bool   `json:"isFunctional"`
}

// Instance 实例
type Instance struct {
    IRI        string            `json:"iri"`
    Label      string            `json:"label"`
    Types      []string          `json:"types"`
    Properties map[string][]string `json:"properties"`
}

// InferenceResult 推理结果
type InferenceResult struct {
    Rule       InferenceRule `json:"rule"`
    Subject    string        `json:"subject"`
    Predicate  string        `json:"predicate"`
    Object     string        `json:"object"`
    Confidence float64       `json:"confidence"`
}

// OWL2RLReasoner OWL2-RL推理引擎
type OWL2RLReasoner struct {
    concepts          map[string]*Concept
    properties        map[string]*Property
    instances         map[string]*Instance
    subClassOf        map[string]map[string]bool
    subPropertyOf     map[string]map[string]bool
    classAssertions   map[string]map[string]bool
    propertyAssertions map[string][]PropertyAssertion
    
    mu sync.RWMutex
}

// PropertyAssertion 属性断言
type PropertyAssertion struct {
    Property string
    Object   string
}

// NewOWL2RLReasoner 创建推理引擎
func NewOWL2RLReasoner() *OWL2RLReasoner {
    return &OWL2RLReasoner{
        concepts:           make(map[string]*Concept),
        properties:         make(map[string]*Property),
        instances:          make(map[string]*Instance),
        subClassOf:         make(map[string]map[string]bool),
        subPropertyOf:      make(map[string]map[string]bool),
        classAssertions:    make(map[string]map[string]bool),
        propertyAssertions: make(map[string][]PropertyAssertion),
    }
}

// AddConcept 添加概念
func (r *OWL2RLReasoner) AddConcept(concept *Concept) {
    r.mu.Lock()
    defer r.mu.Unlock()
    r.concepts[concept.IRI] = concept
}

// AddProperty 添加属性
func (r *OWL2RLReasoner) AddProperty(property *Property) {
    r.mu.Lock()
    defer r.mu.Unlock()
    r.properties[property.IRI] = property
}

// AddInstance 添加实例
func (r *OWL2RLReasoner) AddInstance(instance *Instance) {
    r.mu.Lock()
    defer r.mu.Unlock()
    r.instances[instance.IRI] = instance
}

// AddSubClassOf 添加子类关系
func (r *OWL2RLReasoner) AddSubClassOf(subClass, superClass string) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if r.subClassOf[subClass] == nil {
        r.subClassOf[subClass] = make(map[string]bool)
    }
    r.subClassOf[subClass][superClass] = true
}

// AddSubPropertyOf 添加子属性关系
func (r *OWL2RLReasoner) AddSubPropertyOf(subProperty, superProperty string) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if r.subPropertyOf[subProperty] == nil {
        r.subPropertyOf[subProperty] = make(map[string]bool)
    }
    r.subPropertyOf[subProperty][superProperty] = true
}

// AddClassAssertion 添加类断言
func (r *OWL2RLReasoner) AddClassAssertion(instance, class string) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if r.classAssertions[instance] == nil {
        r.classAssertions[instance] = make(map[string]bool)
    }
    r.classAssertions[instance][class] = true
}

// AddPropertyAssertion 添加属性断言
func (r *OWL2RLReasoner) AddPropertyAssertion(subject, property, object string) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    assertion := PropertyAssertion{
        Property: property,
        Object:   object,
    }
    r.propertyAssertions[subject] = append(r.propertyAssertions[subject], assertion)
}

// Reason 执行推理
func (r *OWL2RLReasoner) Reason() ([]InferenceResult, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    var results []InferenceResult
    
    // 子类推理
    subClassResults, err := r.inferSubClasses()
    if err != nil {
        return nil, fmt.Errorf("subclass inference failed: %v", err)
    }
    results = append(results, subClassResults...)
    
    // 子属性推理
    subPropertyResults, err := r.inferSubProperties()
    if err != nil {
        return nil, fmt.Errorf("subproperty inference failed: %v", err)
    }
    results = append(results, subPropertyResults...)
    
    // 实例类型推理
    instanceTypeResults, err := r.inferInstanceTypes()
    if err != nil {
        return nil, fmt.Errorf("instance type inference failed: %v", err)
    }
    results = append(results, instanceTypeResults...)
    
    // 属性推理
    propertyResults, err := r.inferProperties()
    if err != nil {
        return nil, fmt.Errorf("property inference failed: %v", err)
    }
    results = append(results, propertyResults...)
    
    return results, nil
}

// inferSubClasses 子类推理
func (r *OWL2RLReasoner) inferSubClasses() ([]InferenceResult, error) {
    var results []InferenceResult
    
    for subClass, superClasses := range r.subClassOf {
        for superClass := range superClasses {
            // 查找传递闭包
            if transitiveSupers, exists := r.subClassOf[superClass]; exists {
                for transitiveSuper := range transitiveSupers {
                    results = append(results, InferenceResult{
                        Rule:       SubClassOf,
                        Subject:    subClass,
                        Predicate:  "rdfs:subClassOf",
                        Object:     transitiveSuper,
                        Confidence: 1.0,
                    })
                }
            }
        }
    }
    
    return results, nil
}

// inferSubProperties 子属性推理
func (r *OWL2RLReasoner) inferSubProperties() ([]InferenceResult, error) {
    var results []InferenceResult
    
    for subProperty, superProperties := range r.subPropertyOf {
        for superProperty := range superProperties {
            // 查找传递闭包
            if transitiveSupers, exists := r.subPropertyOf[superProperty]; exists {
                for transitiveSuper := range transitiveSupers {
                    results = append(results, InferenceResult{
                        Rule:       SubPropertyOf,
                        Subject:    subProperty,
                        Predicate:  "rdfs:subPropertyOf",
                        Object:     transitiveSuper,
                        Confidence: 1.0,
                    })
                }
            }
        }
    }
    
    return results, nil
}

// inferInstanceTypes 实例类型推理
func (r *OWL2RLReasoner) inferInstanceTypes() ([]InferenceResult, error) {
    var results []InferenceResult
    
    for instance, classes := range r.classAssertions {
        for class := range classes {
            // 查找子类
            if subClasses, exists := r.subClassOf[class]; exists {
                for subClass := range subClasses {
                    results = append(results, InferenceResult{
                        Rule:       ClassAssertion,
                        Subject:    instance,
                        Predicate:  "rdf:type",
                        Object:     subClass,
                        Confidence: 1.0,
                    })
                }
            }
        }
    }
    
    return results, nil
}

// inferProperties 属性推理
func (r *OWL2RLReasoner) inferProperties() ([]InferenceResult, error) {
    var results []InferenceResult
    
    for subject, assertions := range r.propertyAssertions {
        for _, assertion := range assertions {
            // 查找子属性
            if subProperties, exists := r.subPropertyOf[assertion.Property]; exists {
                for subProperty := range subProperties {
                    results = append(results, InferenceResult{
                        Rule:       PropertyAssertion,
                        Subject:    subject,
                        Predicate:  subProperty,
                        Object:     assertion.Object,
                        Confidence: 1.0,
                    })
                }
            }
            
            // 处理传递属性
            if property, exists := r.properties[assertion.Property]; exists && property.IsTransitive {
                // 查找传递关系
                if objectAssertions, exists := r.propertyAssertions[assertion.Object]; exists {
                    for _, objAssertion := range objectAssertions {
                        if objAssertion.Property == assertion.Property {
                            results = append(results, InferenceResult{
                                Rule:       TransitiveProperty,
                                Subject:    subject,
                                Predicate:  assertion.Property,
                                Object:     objAssertion.Object,
                                Confidence: 1.0,
                            })
                        }
                    }
                }
            }
        }
    }
    
    return results, nil
}

// QueryInstances 查询实例
func (r *OWL2RLReasoner) QueryInstances(class string) []*Instance {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    var instances []*Instance
    
    for _, instance := range r.instances {
        for _, instanceType := range instance.Types {
            if instanceType == class {
                instances = append(instances, instance)
                break
            }
        }
    }
    
    return instances
}

// QueryPropertyValues 查询属性值
func (r *OWL2RLReasoner) QueryPropertyValues(subject, property string) []string {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    var values []string
    
    if assertions, exists := r.propertyAssertions[subject]; exists {
        for _, assertion := range assertions {
            if assertion.Property == property {
                values = append(values, assertion.Object)
            }
        }
    }
    
    return values
}
```

## 2. 应用示例

### 2.1 IoT设备推理

```rust
use crate::reasoning::{OWL2RLReasoner, Concept, Property, Instance};

fn create_iot_reasoning_system() -> Result<(), Box<dyn std::error::Error>> {
    let mut reasoner = OWL2RLReasoner::new();
    
    // 创建IoT概念
    let device = Concept {
        iri: "http://example.com/iot#Device".to_string(),
        label: "IoT Device".to_string(),
        description: Some("An IoT device".to_string()),
    };
    
    let sensor = Concept {
        iri: "http://example.com/iot#Sensor".to_string(),
        label: "Sensor".to_string(),
        description: Some("A sensor device".to_string()),
    };
    
    let actuator = Concept {
        iri: "http://example.com/iot#Actuator".to_string(),
        label: "Actuator".to_string(),
        description: Some("An actuator device".to_string()),
    };
    
    let temperature_sensor = Concept {
        iri: "http://example.com/iot#TemperatureSensor".to_string(),
        label: "Temperature Sensor".to_string(),
        description: Some("A temperature sensor".to_string()),
    };
    
    // 添加概念
    reasoner.add_concept(device);
    reasoner.add_concept(sensor);
    reasoner.add_concept(actuator);
    reasoner.add_concept(temperature_sensor);
    
    // 添加层次关系
    reasoner.add_sub_class_of("http://example.com/iot#Sensor".to_string(), 
                             "http://example.com/iot#Device".to_string());
    reasoner.add_sub_class_of("http://example.com/iot#Actuator".to_string(), 
                             "http://example.com/iot#Device".to_string());
    reasoner.add_sub_class_of("http://example.com/iot#TemperatureSensor".to_string(), 
                             "http://example.com/iot#Sensor".to_string());
    
    // 创建属性
    let measures = Property {
        iri: "http://example.com/iot#measures".to_string(),
        label: "measures".to_string(),
        domain: Some("http://example.com/iot#Sensor".to_string()),
        range: Some("http://example.com/iot#Property".to_string()),
        is_transitive: false,
        is_symmetric: false,
        is_functional: false,
    };
    
    let controls = Property {
        iri: "http://example.com/iot#controls".to_string(),
        label: "controls".to_string(),
        domain: Some("http://example.com/iot#Actuator".to_string()),
        range: Some("http://example.com/iot#Property".to_string()),
        is_transitive: false,
        is_symmetric: false,
        is_functional: false,
    };
    
    reasoner.add_property(measures);
    reasoner.add_property(controls);
    
    // 创建实例
    let temp_sensor_001 = Instance {
        iri: "http://example.com/iot#temp_sensor_001".to_string(),
        label: "Temperature Sensor 001".to_string(),
        types: vec!["http://example.com/iot#TemperatureSensor".to_string()],
        properties: HashMap::new(),
    };
    
    let light_switch_001 = Instance {
        iri: "http://example.com/iot#light_switch_001".to_string(),
        label: "Light Switch 001".to_string(),
        types: vec!["http://example.com/iot#Actuator".to_string()],
        properties: HashMap::new(),
    };
    
    reasoner.add_instance(temp_sensor_001);
    reasoner.add_instance(light_switch_001);
    
    // 添加断言
    reasoner.add_class_assertion("http://example.com/iot#temp_sensor_001".to_string(),
                                "http://example.com/iot#TemperatureSensor".to_string());
    reasoner.add_class_assertion("http://example.com/iot#light_switch_001".to_string(),
                                "http://example.com/iot#Actuator".to_string());
    
    reasoner.add_property_assertion("http://example.com/iot#temp_sensor_001".to_string(),
                                   "http://example.com/iot#measures".to_string(),
                                   "http://example.com/iot#temperature".to_string());
    reasoner.add_property_assertion("http://example.com/iot#light_switch_001".to_string(),
                                   "http://example.com/iot#controls".to_string(),
                                   "http://example.com/iot#illumination".to_string());
    
    // 执行推理
    let results = reasoner.reason()?;
    
    println!("推理结果:");
    for result in results {
        println!("{:?}: {} {} {}", result.rule, result.subject, result.predicate, result.object);
    }
    
    // 查询设备
    let devices = reasoner.query_instances("http://example.com/iot#Device");
    println!("\n所有设备:");
    for device in devices {
        println!("- {}", device.label);
    }
    
    // 查询传感器
    let sensors = reasoner.query_instances("http://example.com/iot#Sensor");
    println!("\n所有传感器:");
    for sensor in sensors {
        println!("- {}", sensor.label);
    }
    
    Ok(())
}
```

## 3. 总结

本实现提供了：

1. **完整的OWL2-RL推理引擎** - 支持所有OWL2-RL推理规则
2. **多语言实现** - Rust和Go的完整实现
3. **高性能推理** - 优化的推理算法和数据结构
4. **实际应用示例** - IoT设备语义推理
5. **查询接口** - 支持复杂的语义查询

这个推理引擎为IoT系统提供了强大的语义推理能力，能够自动发现隐含的知识和关系。
