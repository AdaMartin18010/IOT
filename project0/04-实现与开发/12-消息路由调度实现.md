# 消息路由调度实现

## 1. 消息路由引擎

### 1.1 路由规则定义

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use tokio::sync::mpsc;
use regex::Regex;

/// 消息类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Message {
    pub id: String,
    pub source: String,
    pub destination: String,
    pub message_type: MessageType,
    pub payload: Vec<u8>,
    pub priority: Priority,
    pub timestamp: u64,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessageType {
    Data,
    Command,
    Status,
    Alert,
    Configuration,
    Discovery,
    Heartbeat,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum Priority {
    Low = 1,
    Normal = 2,
    High = 3,
    Critical = 4,
}

/// 路由规则
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RoutingRule {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub conditions: Vec<Condition>,
    pub actions: Vec<Action>,
    pub priority: u32,
    pub enabled: bool,
}

/// 路由条件
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Condition {
    SourceEquals(String),
    DestinationEquals(String),
    MessageTypeEquals(MessageType),
    PriorityEquals(Priority),
    MetadataContains(String, String),
    PayloadSizeGreaterThan(usize),
    PayloadSizeLessThan(usize),
    RegexMatch(String, String), // field, pattern
    Custom(String), // 自定义条件表达式
}

/// 路由动作
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Action {
    Forward(String), // 转发到指定目标
    Broadcast(Vec<String>), // 广播到多个目标
    Transform(Transformation), // 消息转换
    Delay(u64), // 延迟处理（毫秒）
    Drop, // 丢弃消息
    Log, // 记录日志
    Custom(String), // 自定义动作
}

/// 消息转换
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transformation {
    pub transformation_type: TransformationType,
    pub parameters: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TransformationType {
    ProtocolConvert, // 协议转换
    FormatConvert, // 格式转换
    DataEnrich, // 数据丰富
    DataFilter, // 数据过滤
    DataAggregate, // 数据聚合
}

/// 消息路由器
pub struct MessageRouter {
    rules: Vec<RoutingRule>,
    message_sender: mpsc::Sender<Message>,
    message_receiver: mpsc::Receiver<Message>,
    destinations: HashMap<String, mpsc::Sender<Message>>,
    rule_engine: RuleEngine,
}

impl MessageRouter {
    pub fn new() -> Self {
        let (tx, rx) = mpsc::channel(1000);
        Self {
            rules: Vec::new(),
            message_sender: tx,
            message_receiver: rx,
            destinations: HashMap::new(),
            rule_engine: RuleEngine::new(),
        }
    }

    /// 添加路由规则
    pub fn add_rule(&mut self, rule: RoutingRule) {
        self.rules.push(rule);
        self.rules.sort_by(|a, b| b.priority.cmp(&a.priority));
    }

    /// 注册目标
    pub fn register_destination(&mut self, name: String, sender: mpsc::Sender<Message>) {
        self.destinations.insert(name, sender);
    }

    /// 路由消息
    pub async fn route_message(&mut self, message: Message) -> Result<(), Box<dyn std::error::Error>> {
        // 评估所有规则
        for rule in &self.rules {
            if !rule.enabled {
                continue;
            }

            if self.evaluate_conditions(&message, &rule.conditions).await? {
                self.execute_actions(&message, &rule.actions).await?;
                break; // 第一个匹配的规则
            }
        }

        Ok(())
    }

    /// 评估条件
    async fn evaluate_conditions(&self, message: &Message, conditions: &[Condition]) -> Result<bool, Box<dyn std::error::Error>> {
        for condition in conditions {
            if !self.evaluate_condition(message, condition).await? {
                return Ok(false);
            }
        }
        Ok(true)
    }

    /// 评估单个条件
    async fn evaluate_condition(&self, message: &Message, condition: &Condition) -> Result<bool, Box<dyn std::error::Error>> {
        match condition {
            Condition::SourceEquals(value) => {
                Ok(message.source == *value)
            }
            Condition::DestinationEquals(value) => {
                Ok(message.destination == *value)
            }
            Condition::MessageTypeEquals(msg_type) => {
                Ok(message.message_type == *msg_type)
            }
            Condition::PriorityEquals(priority) => {
                Ok(message.priority == *priority)
            }
            Condition::MetadataContains(key, value) => {
                Ok(message.metadata.get(key).map_or(false, |v| v.contains(value)))
            }
            Condition::PayloadSizeGreaterThan(size) => {
                Ok(message.payload.len() > *size)
            }
            Condition::PayloadSizeLessThan(size) => {
                Ok(message.payload.len() < *size)
            }
            Condition::RegexMatch(field, pattern) => {
                let regex = Regex::new(pattern)?;
                let field_value = match field.as_str() {
                    "source" => &message.source,
                    "destination" => &message.destination,
                    _ => return Ok(false),
                };
                Ok(regex.is_match(field_value))
            }
            Condition::Custom(expression) => {
                self.rule_engine.evaluate_expression(message, expression).await
            }
        }
    }

    /// 执行动作
    async fn execute_actions(&mut self, message: &Message, actions: &[Action]) -> Result<(), Box<dyn std::error::Error>> {
        for action in actions {
            self.execute_action(message, action).await?;
        }
        Ok(())
    }

    /// 执行单个动作
    async fn execute_action(&mut self, message: &Message, action: &Action) -> Result<(), Box<dyn std::error::Error>> {
        match action {
            Action::Forward(destination) => {
                if let Some(sender) = self.destinations.get(destination) {
                    let _ = sender.send(message.clone()).await;
                }
            }
            Action::Broadcast(destinations) => {
                for destination in destinations {
                    if let Some(sender) = self.destinations.get(destination) {
                        let _ = sender.send(message.clone()).await;
                    }
                }
            }
            Action::Transform(transformation) => {
                let transformed_message = self.transform_message(message, transformation).await?;
                self.route_message(transformed_message).await?;
            }
            Action::Delay(delay_ms) => {
                tokio::time::sleep(tokio::time::Duration::from_millis(*delay_ms)).await;
            }
            Action::Drop => {
                // 丢弃消息，不做任何处理
            }
            Action::Log => {
                println!("Message logged: {:?}", message);
            }
            Action::Custom(expression) => {
                self.rule_engine.execute_custom_action(message, expression).await?;
            }
        }
        Ok(())
    }

    /// 转换消息
    async fn transform_message(&self, message: &Message, transformation: &Transformation) -> Result<Message, Box<dyn std::error::Error>> {
        let mut transformed_message = message.clone();
        
        match transformation.transformation_type {
            TransformationType::ProtocolConvert => {
                // 协议转换逻辑
                if let Some(target_protocol) = transformation.parameters.get("target_protocol") {
                    transformed_message.metadata.insert("protocol".to_string(), target_protocol.clone());
                }
            }
            TransformationType::FormatConvert => {
                // 格式转换逻辑
                if let Some(target_format) = transformation.parameters.get("target_format") {
                    transformed_message.payload = self.convert_format(&message.payload, target_format).await?;
                }
            }
            TransformationType::DataEnrich => {
                // 数据丰富逻辑
                for (key, value) in &transformation.parameters {
                    transformed_message.metadata.insert(key.clone(), value.clone());
                }
            }
            TransformationType::DataFilter => {
                // 数据过滤逻辑
                // 这里可以实现数据过滤
            }
            TransformationType::DataAggregate => {
                // 数据聚合逻辑
                // 这里可以实现数据聚合
            }
        }
        
        Ok(transformed_message)
    }

    /// 格式转换
    async fn convert_format(&self, payload: &[u8], target_format: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        // 简化的格式转换实现
        match target_format {
            "json" => {
                // 转换为JSON格式
                let json_string = String::from_utf8_lossy(payload);
                Ok(json_string.as_bytes().to_vec())
            }
            "xml" => {
                // 转换为XML格式
                let xml_string = format!("<data>{}</data>", String::from_utf8_lossy(payload));
                Ok(xml_string.as_bytes().to_vec())
            }
            _ => Ok(payload.to_vec()),
        }
    }
}
```

### 1.2 规则引擎

```rust
/// 规则引擎
pub struct RuleEngine {
    functions: HashMap<String, Box<dyn RuleFunction>>,
}

/// 规则函数接口
#[async_trait::async_trait]
pub trait RuleFunction: Send + Sync {
    async fn evaluate(&self, message: &Message, parameters: &[String]) -> Result<bool, Box<dyn std::error::Error>>;
    async fn execute(&self, message: &Message, parameters: &[String]) -> Result<(), Box<dyn std::error::Error>>;
}

impl RuleEngine {
    pub fn new() -> Self {
        let mut engine = Self {
            functions: HashMap::new(),
        };
        
        // 注册内置函数
        engine.register_function("time_between".to_string(), Box::new(TimeBetweenFunction));
        engine.register_function("value_in_range".to_string(), Box::new(ValueInRangeFunction));
        engine.register_function("rate_limit".to_string(), Box::new(RateLimitFunction));
        
        engine
    }

    /// 注册函数
    pub fn register_function(&mut self, name: String, function: Box<dyn RuleFunction>) {
        self.functions.insert(name, function);
    }

    /// 评估表达式
    pub async fn evaluate_expression(&self, message: &Message, expression: &str) -> Result<bool, Box<dyn std::error::Error>> {
        // 简化的表达式解析
        // 实际实现应该支持复杂的表达式语言
        
        if expression.starts_with("time_between(") {
            let params = self.parse_function_params(expression);
            if let Some(function) = self.functions.get("time_between") {
                return function.evaluate(message, &params).await;
            }
        }
        
        if expression.starts_with("value_in_range(") {
            let params = self.parse_function_params(expression);
            if let Some(function) = self.functions.get("value_in_range") {
                return function.evaluate(message, &params).await;
            }
        }
        
        Ok(false)
    }

    /// 执行自定义动作
    pub async fn execute_custom_action(&self, message: &Message, expression: &str) -> Result<(), Box<dyn std::error::Error>> {
        if expression.starts_with("rate_limit(") {
            let params = self.parse_function_params(expression);
            if let Some(function) = self.functions.get("rate_limit") {
                return function.execute(message, &params).await;
            }
        }
        
        Ok(())
    }

    /// 解析函数参数
    fn parse_function_params(&self, expression: &str) -> Vec<String> {
        let start = expression.find('(').unwrap_or(0) + 1;
        let end = expression.rfind(')').unwrap_or(expression.len());
        let params_str = &expression[start..end];
        
        params_str.split(',')
            .map(|s| s.trim().trim_matches('"').to_string())
            .collect()
    }
}

/// 时间范围函数
pub struct TimeBetweenFunction;

#[async_trait::async_trait]
impl RuleFunction for TimeBetweenFunction {
    async fn evaluate(&self, message: &Message, parameters: &[String]) -> Result<bool, Box<dyn std::error::Error>> {
        if parameters.len() != 2 {
            return Ok(false);
        }
        
        let start_time = parameters[0].parse::<u64>()?;
        let end_time = parameters[1].parse::<u64>()?;
        
        Ok(message.timestamp >= start_time && message.timestamp <= end_time)
    }

    async fn execute(&self, _message: &Message, _parameters: &[String]) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
}

/// 值范围函数
pub struct ValueInRangeFunction;

#[async_trait::async_trait]
impl RuleFunction for ValueInRangeFunction {
    async fn evaluate(&self, message: &Message, parameters: &[String]) -> Result<bool, Box<dyn std::error::Error>> {
        if parameters.len() != 2 {
            return Ok(false);
        }
        
        let min_value = parameters[0].parse::<f64>()?;
        let max_value = parameters[1].parse::<f64>()?;
        
        // 尝试从payload中解析数值
        if let Ok(payload_str) = String::from_utf8(message.payload.clone()) {
            if let Ok(value) = payload_str.parse::<f64>() {
                return Ok(value >= min_value && value <= max_value);
            }
        }
        
        Ok(false)
    }

    async fn execute(&self, _message: &Message, _parameters: &[String]) -> Result<(), Box<dyn std::error::Error>> {
        Ok(())
    }
}

/// 速率限制函数
pub struct RateLimitFunction {
    counters: std::sync::Mutex<HashMap<String, (u64, u32)>>, // (timestamp, count)
}

impl RateLimitFunction {
    pub fn new() -> Self {
        Self {
            counters: std::sync::Mutex::new(HashMap::new()),
        }
    }
}

#[async_trait::async_trait]
impl RuleFunction for RateLimitFunction {
    async fn evaluate(&self, _message: &Message, _parameters: &[String]) -> Result<bool, Box<dyn std::error::Error>> {
        Ok(true)
    }

    async fn execute(&self, message: &Message, parameters: &[String]) -> Result<(), Box<dyn std::error::Error>> {
        if parameters.len() != 2 {
            return Ok(());
        }
        
        let key = format!("{}:{}", message.source, parameters[0]);
        let max_count = parameters[1].parse::<u32>()?;
        let window_ms = parameters[0].parse::<u64>()?;
        
        let current_time = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_millis() as u64;
        
        let mut counters = self.counters.lock().unwrap();
        
        if let Some((timestamp, count)) = counters.get_mut(&key) {
            if current_time - *timestamp > window_ms {
                *timestamp = current_time;
                *count = 1;
            } else if *count >= max_count {
                // 速率限制，丢弃消息
                return Ok(());
            } else {
                *count += 1;
            }
        } else {
            counters.insert(key, (current_time, 1));
        }
        
        Ok(())
    }
}
```

## 2. 消息调度器

### 2.1 优先级调度

```rust
use std::collections::BinaryHeap;
use std::cmp::Ordering;

/// 调度消息
#[derive(Debug, Clone)]
pub struct ScheduledMessage {
    pub message: Message,
    pub scheduled_time: u64,
    pub priority: Priority,
}

impl PartialEq for ScheduledMessage {
    fn eq(&self, other: &Self) -> bool {
        self.scheduled_time == other.scheduled_time && self.priority == other.priority
    }
}

impl Eq for ScheduledMessage {}

impl PartialOrd for ScheduledMessage {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

impl Ord for ScheduledMessage {
    fn cmp(&self, other: &Self) -> Ordering {
        // 首先按优先级排序，然后按调度时间排序
        match self.priority.cmp(&other.priority).reverse() {
            Ordering::Equal => self.scheduled_time.cmp(&other.scheduled_time),
            other => other,
        }
    }
}

/// 消息调度器
pub struct MessageScheduler {
    queue: BinaryHeap<ScheduledMessage>,
    router: MessageRouter,
    max_queue_size: usize,
    processing_interval: std::time::Duration,
}

impl MessageScheduler {
    pub fn new(router: MessageRouter) -> Self {
        Self {
            queue: BinaryHeap::new(),
            router,
            max_queue_size: 10000,
            processing_interval: std::time::Duration::from_millis(100),
        }
    }

    /// 调度消息
    pub fn schedule_message(&mut self, message: Message, delay_ms: u64) -> Result<(), Box<dyn std::error::Error>> {
        if self.queue.len() >= self.max_queue_size {
            return Err("Queue is full".into());
        }
        
        let scheduled_time = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_millis() as u64 + delay_ms;
        
        let scheduled_message = ScheduledMessage {
            message,
            scheduled_time,
            priority: Priority::Normal,
        };
        
        self.queue.push(scheduled_message);
        Ok(())
    }

    /// 调度高优先级消息
    pub fn schedule_priority_message(&mut self, message: Message, priority: Priority, delay_ms: u64) -> Result<(), Box<dyn std::error::Error>> {
        if self.queue.len() >= self.max_queue_size {
            return Err("Queue is full".into());
        }
        
        let scheduled_time = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_millis() as u64 + delay_ms;
        
        let scheduled_message = ScheduledMessage {
            message,
            scheduled_time,
            priority,
        };
        
        self.queue.push(scheduled_message);
        Ok(())
    }

    /// 启动调度器
    pub async fn start(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let mut interval = tokio::time::interval(self.processing_interval);
        
        loop {
            interval.tick().await;
            self.process_scheduled_messages().await?;
        }
    }

    /// 处理调度的消息
    async fn process_scheduled_messages(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        let current_time = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_millis() as u64;
        
        let mut messages_to_process = Vec::new();
        
        // 收集到期的消息
        while let Some(scheduled_message) = self.queue.peek() {
            if scheduled_message.scheduled_time <= current_time {
                if let Some(message) = self.queue.pop() {
                    messages_to_process.push(message.message);
                }
            } else {
                break;
            }
        }
        
        // 处理消息
        for message in messages_to_process {
            self.router.route_message(message).await?;
        }
        
        Ok(())
    }

    /// 获取队列状态
    pub fn get_queue_status(&self) -> QueueStatus {
        QueueStatus {
            current_size: self.queue.len(),
            max_size: self.max_queue_size,
            oldest_message_time: self.queue.peek().map(|msg| msg.scheduled_time),
        }
    }
}

#[derive(Debug, Clone)]
pub struct QueueStatus {
    pub current_size: usize,
    pub max_size: usize,
    pub oldest_message_time: Option<u64>,
}
```

### 2.2 负载均衡调度

```rust
/// 负载均衡器
pub struct LoadBalancer {
    destinations: Vec<Destination>,
    strategy: LoadBalancingStrategy,
    health_checker: HealthChecker,
}

#[derive(Debug, Clone)]
pub struct Destination {
    pub id: String,
    pub name: String,
    pub weight: u32,
    pub current_load: u32,
    pub max_load: u32,
    pub healthy: bool,
    pub response_time: u64, // 毫秒
}

#[derive(Debug, Clone)]
pub enum LoadBalancingStrategy {
    RoundRobin,
    WeightedRoundRobin,
    LeastConnections,
    LeastResponseTime,
    Random,
}

/// 健康检查器
pub struct HealthChecker {
    check_interval: std::time::Duration,
    timeout: std::time::Duration,
}

impl LoadBalancer {
    pub fn new(strategy: LoadBalancingStrategy) -> Self {
        Self {
            destinations: Vec::new(),
            strategy,
            health_checker: HealthChecker {
                check_interval: std::time::Duration::from_secs(30),
                timeout: std::time::Duration::from_secs(5),
            },
        }
    }

    /// 添加目标
    pub fn add_destination(&mut self, destination: Destination) {
        self.destinations.push(destination);
    }

    /// 选择目标
    pub fn select_destination(&mut self) -> Option<&Destination> {
        let healthy_destinations: Vec<&Destination> = self.destinations.iter()
            .filter(|d| d.healthy)
            .collect();
        
        if healthy_destinations.is_empty() {
            return None;
        }
        
        match self.strategy {
            LoadBalancingStrategy::RoundRobin => {
                self.round_robin_select(&healthy_destinations)
            }
            LoadBalancingStrategy::WeightedRoundRobin => {
                self.weighted_round_robin_select(&healthy_destinations)
            }
            LoadBalancingStrategy::LeastConnections => {
                self.least_connections_select(&healthy_destinations)
            }
            LoadBalancingStrategy::LeastResponseTime => {
                self.least_response_time_select(&healthy_destinations)
            }
            LoadBalancingStrategy::Random => {
                self.random_select(&healthy_destinations)
            }
        }
    }

    /// 轮询选择
    fn round_robin_select(&self, destinations: &[&Destination]) -> Option<&Destination> {
        // 简化的轮询实现
        destinations.first().copied()
    }

    /// 加权轮询选择
    fn weighted_round_robin_select(&self, destinations: &[&Destination]) -> Option<&Destination> {
        let total_weight: u32 = destinations.iter().map(|d| d.weight).sum();
        if total_weight == 0 {
            return destinations.first().copied();
        }
        
        // 简化的加权轮询实现
        destinations.iter()
            .max_by_key(|d| d.weight)
            .copied()
    }

    /// 最少连接选择
    fn least_connections_select(&self, destinations: &[&Destination]) -> Option<&Destination> {
        destinations.iter()
            .min_by_key(|d| d.current_load)
            .copied()
    }

    /// 最少响应时间选择
    fn least_response_time_select(&self, destinations: &[&Destination]) -> Option<&Destination> {
        destinations.iter()
            .min_by_key(|d| d.response_time)
            .copied()
    }

    /// 随机选择
    fn random_select(&self, destinations: &[&Destination]) -> Option<&Destination> {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        let index = rng.gen_range(0..destinations.len());
        destinations.get(index).copied()
    }

    /// 更新目标负载
    pub fn update_destination_load(&mut self, destination_id: &str, load: u32) {
        if let Some(destination) = self.destinations.iter_mut().find(|d| d.id == destination_id) {
            destination.current_load = load;
        }
    }

    /// 更新目标响应时间
    pub fn update_destination_response_time(&mut self, destination_id: &str, response_time: u64) {
        if let Some(destination) = self.destinations.iter_mut().find(|d| d.id == destination_id) {
            destination.response_time = response_time;
        }
    }

    /// 设置目标健康状态
    pub fn set_destination_health(&mut self, destination_id: &str, healthy: bool) {
        if let Some(destination) = self.destinations.iter_mut().find(|d| d.id == destination_id) {
            destination.healthy = healthy;
        }
    }
}
```

## 3. 应用示例

### 3.1 IoT消息路由系统

```rust
use crate::routing::{MessageRouter, RoutingRule, Condition, Action, Message, MessageType, Priority};
use crate::scheduling::{MessageScheduler, LoadBalancer, LoadBalancingStrategy};

async fn iot_message_routing_system() -> Result<(), Box<dyn std::error::Error>> {
    // 创建消息路由器
    let mut router = MessageRouter::new();
    
    // 创建负载均衡器
    let mut load_balancer = LoadBalancer::new(LoadBalancingStrategy::LeastConnections);
    
    // 添加目标
    load_balancer.add_destination(Destination {
        id: "processor_1".to_string(),
        name: "Data Processor 1".to_string(),
        weight: 1,
        current_load: 0,
        max_load: 1000,
        healthy: true,
        response_time: 10,
    });
    
    load_balancer.add_destination(Destination {
        id: "processor_2".to_string(),
        name: "Data Processor 2".to_string(),
        weight: 1,
        current_load: 0,
        max_load: 1000,
        healthy: true,
        response_time: 15,
    });
    
    // 创建消息调度器
    let mut scheduler = MessageScheduler::new(router);
    
    // 定义路由规则
    let data_processing_rule = RoutingRule {
        id: "data_processing".to_string(),
        name: "Data Processing Rule".to_string(),
        description: Some("Route data messages to processors".to_string()),
        conditions: vec![
            Condition::MessageTypeEquals(MessageType::Data),
            Condition::PriorityEquals(Priority::Normal),
        ],
        actions: vec![
            Action::Transform(Transformation {
                transformation_type: TransformationType::DataEnrich,
                parameters: {
                    let mut params = HashMap::new();
                    params.insert("processed_by".to_string(), "load_balancer".to_string());
                    params
                },
            }),
            Action::Forward("processor".to_string()),
        ],
        priority: 1,
        enabled: true,
    };
    
    let alert_rule = RoutingRule {
        id: "alert_processing".to_string(),
        name: "Alert Processing Rule".to_string(),
        description: Some("Route alert messages to alert system".to_string()),
        conditions: vec![
            Condition::MessageTypeEquals(MessageType::Alert),
        ],
        actions: vec![
            Action::Forward("alert_system".to_string()),
            Action::Log,
        ],
        priority: 2,
        enabled: true,
    };
    
    let critical_rule = RoutingRule {
        id: "critical_processing".to_string(),
        name: "Critical Processing Rule".to_string(),
        description: Some("Route critical messages with high priority".to_string()),
        conditions: vec![
            Condition::PriorityEquals(Priority::Critical),
        ],
        actions: vec![
            Action::Broadcast(vec!["alert_system".to_string(), "emergency_system".to_string()]),
            Action::Log,
        ],
        priority: 3,
        enabled: true,
    };
    
    // 添加路由规则
    router.add_rule(data_processing_rule);
    router.add_rule(alert_rule);
    router.add_rule(critical_rule);
    
    // 注册目标
    let (processor_tx, mut processor_rx) = mpsc::channel(100);
    let (alert_tx, mut alert_rx) = mpsc::channel(100);
    let (emergency_tx, mut emergency_rx) = mpsc::channel(100);
    
    router.register_destination("processor".to_string(), processor_tx);
    router.register_destination("alert_system".to_string(), alert_tx);
    router.register_destination("emergency_system".to_string(), emergency_tx);
    
    // 启动消息处理
    tokio::spawn(async move {
        while let Some(message) = processor_rx.recv().await {
            println!("Processor received: {:?}", message);
            
            // 更新负载均衡器状态
            load_balancer.update_destination_load("processor_1", 50);
        }
    });
    
    tokio::spawn(async move {
        while let Some(message) = alert_rx.recv().await {
            println!("Alert system received: {:?}", message);
        }
    });
    
    tokio::spawn(async move {
        while let Some(message) = emergency_rx.recv().await {
            println!("Emergency system received: {:?}", message);
        }
    });
    
    // 发送测试消息
    let data_message = Message {
        id: "msg_001".to_string(),
        source: "sensor_001".to_string(),
        destination: "processor".to_string(),
        message_type: MessageType::Data,
        payload: b"temperature: 23.5".to_vec(),
        priority: Priority::Normal,
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_millis() as u64,
        metadata: HashMap::new(),
    };
    
    let alert_message = Message {
        id: "msg_002".to_string(),
        source: "sensor_002".to_string(),
        destination: "alert_system".to_string(),
        message_type: MessageType::Alert,
        payload: b"temperature_high: 35.0".to_vec(),
        priority: Priority::High,
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_millis() as u64,
        metadata: HashMap::new(),
    };
    
    let critical_message = Message {
        id: "msg_003".to_string(),
        source: "sensor_003".to_string(),
        destination: "emergency_system".to_string(),
        message_type: MessageType::Alert,
        payload: b"fire_detected: true".to_vec(),
        priority: Priority::Critical,
        timestamp: std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_millis() as u64,
        metadata: HashMap::new(),
    };
    
    // 路由消息
    router.route_message(data_message).await?;
    router.route_message(alert_message).await?;
    router.route_message(critical_message).await?;
    
    // 等待消息处理
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    
    Ok(())
}
```

## 4. 总结

本实现提供了：

1. **灵活的路由规则** - 支持多种条件和动作
2. **智能消息调度** - 优先级和延迟调度
3. **负载均衡** - 多种负载均衡策略
4. **规则引擎** - 可扩展的规则评估和执行
5. **实际应用示例** - IoT消息路由系统

这个消息路由调度系统为IoT平台提供了强大的消息处理能力，支持复杂的路由逻辑和负载均衡。
