# 监控告警实现

## 1. 监控数据收集

### 1.1 监控指标定义

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

/// 监控指标类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MetricType {
    Counter,    // 计数器
    Gauge,      // 仪表盘
    Histogram,  // 直方图
    Summary,    // 摘要
}

/// 监控指标
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Metric {
    pub name: String,
    pub metric_type: MetricType,
    pub value: f64,
    pub timestamp: DateTime<Utc>,
    pub labels: HashMap<String, String>,
    pub description: Option<String>,
    pub unit: Option<String>,
}

/// 监控数据点
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MetricPoint {
    pub metric_name: String,
    pub value: f64,
    pub timestamp: DateTime<Utc>,
    pub labels: HashMap<String, String>,
}

/// 监控数据收集器
pub struct MetricCollector {
    metrics: HashMap<String, Metric>,
    collectors: HashMap<String, Box<dyn MetricCollectorTrait>>,
    storage: Box<dyn MetricStorage>,
}

/// 指标收集器接口
#[async_trait::async_trait]
pub trait MetricCollectorTrait: Send + Sync {
    async fn collect(&self) -> Result<Vec<MetricPoint>, Box<dyn std::error::Error>>;
    fn get_interval(&self) -> std::time::Duration;
}

impl MetricCollector {
    pub fn new(storage: Box<dyn MetricStorage>) -> Self {
        Self {
            metrics: HashMap::new(),
            collectors: HashMap::new(),
            storage,
        }
    }

    /// 注册指标
    pub fn register_metric(&mut self, metric: Metric) {
        self.metrics.insert(metric.name.clone(), metric);
    }

    /// 注册收集器
    pub fn register_collector(&mut self, name: String, collector: Box<dyn MetricCollectorTrait>) {
        self.collectors.insert(name, collector);
    }

    /// 记录指标
    pub async fn record_metric(&mut self, metric_point: MetricPoint) -> Result<(), Box<dyn std::error::Error>> {
        self.storage.store_metric(metric_point).await
    }

    /// 启动收集
    pub async fn start_collection(&self) -> Result<(), Box<dyn std::error::Error>> {
        for (name, collector) in &self.collectors {
            let collector_name = name.clone();
            let collector = collector.clone();
            let storage = self.storage.clone();
            
            tokio::spawn(async move {
                let mut interval = tokio::time::interval(collector.get_interval());
                
                loop {
                    interval.tick().await;
                    
                    match collector.collect().await {
                        Ok(metrics) => {
                            for metric in metrics {
                                if let Err(e) = storage.store_metric(metric).await {
                                    eprintln!("Failed to store metric from {}: {}", collector_name, e);
                                }
                            }
                        }
                        Err(e) => {
                            eprintln!("Failed to collect metrics from {}: {}", collector_name, e);
                        }
                    }
                }
            });
        }
        
        Ok(())
    }

    /// 查询指标
    pub async fn query_metrics(&self, metric_name: &str, start_time: DateTime<Utc>, end_time: DateTime<Utc>) -> Result<Vec<MetricPoint>, Box<dyn std::error::Error>> {
        self.storage.query_metrics(metric_name, start_time, end_time).await
    }

    /// 获取最新指标值
    pub async fn get_latest_metric(&self, metric_name: &str) -> Result<Option<MetricPoint>, Box<dyn std::error::Error>> {
        self.storage.get_latest_metric(metric_name).await
    }
}
```

### 1.2 系统监控收集器

```rust
use std::time::Duration;
use sysinfo::{System, SystemExt, CpuExt, DiskExt, NetworkExt};

/// 系统监控收集器
pub struct SystemMetricCollector {
    system: System,
    interval: Duration,
}

impl SystemMetricCollector {
    pub fn new(interval: Duration) -> Self {
        Self {
            system: System::new_all(),
            interval,
        }
    }
}

#[async_trait::async_trait]
impl MetricCollectorTrait for SystemMetricCollector {
    async fn collect(&self) -> Result<Vec<MetricPoint>, Box<dyn std::error::Error>> {
        let mut system = System::new_all();
        system.refresh_all();
        
        let mut metrics = Vec::new();
        
        // CPU使用率
        let cpu_usage = system.global_cpu_info().cpu_usage();
        metrics.push(MetricPoint {
            metric_name: "cpu_usage_percent".to_string(),
            value: cpu_usage as f64,
            timestamp: Utc::now(),
            labels: HashMap::new(),
        });
        
        // 内存使用率
        let total_memory = system.total_memory();
        let used_memory = system.used_memory();
        let memory_usage = (used_memory as f64 / total_memory as f64) * 100.0;
        metrics.push(MetricPoint {
            metric_name: "memory_usage_percent".to_string(),
            value: memory_usage,
            timestamp: Utc::now(),
            labels: HashMap::new(),
        });
        
        // 磁盘使用率
        for disk in system.disks() {
            let disk_usage = (disk.usage() as f64 / disk.total_space() as f64) * 100.0;
            let mut labels = HashMap::new();
            labels.insert("device".to_string(), disk.name().to_string_lossy().to_string());
            
            metrics.push(MetricPoint {
                metric_name: "disk_usage_percent".to_string(),
                value: disk_usage,
                timestamp: Utc::now(),
                labels,
            });
        }
        
        // 网络流量
        for (interface_name, network) in system.networks() {
            let mut labels = HashMap::new();
            labels.insert("interface".to_string(), interface_name.clone());
            
            metrics.push(MetricPoint {
                metric_name: "network_rx_bytes".to_string(),
                value: network.received() as f64,
                timestamp: Utc::now(),
                labels: labels.clone(),
            });
            
            metrics.push(MetricPoint {
                metric_name: "network_tx_bytes".to_string(),
                value: network.transmitted() as f64,
                timestamp: Utc::now(),
                labels,
            });
        }
        
        Ok(metrics)
    }

    fn get_interval(&self) -> Duration {
        self.interval
    }
}
```

### 1.3 应用监控收集器

```rust
/// 应用监控收集器
pub struct ApplicationMetricCollector {
    interval: Duration,
    application_name: String,
}

impl ApplicationMetricCollector {
    pub fn new(application_name: String, interval: Duration) -> Self {
        Self {
            interval,
            application_name,
        }
    }
}

#[async_trait::async_trait]
impl MetricCollectorTrait for ApplicationMetricCollector {
    async fn collect(&self) -> Result<Vec<MetricPoint>, Box<dyn std::error::Error>> {
        let mut metrics = Vec::new();
        
        // 应用运行时间
        let uptime = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_secs() as f64;
        
        let mut labels = HashMap::new();
        labels.insert("application".to_string(), self.application_name.clone());
        
        metrics.push(MetricPoint {
            metric_name: "application_uptime_seconds".to_string(),
            value: uptime,
            timestamp: Utc::now(),
            labels: labels.clone(),
        });
        
        // 线程数
        let thread_count = std::thread::available_parallelism()
            .map(|n| n.get() as f64)
            .unwrap_or(0.0);
        
        metrics.push(MetricPoint {
            metric_name: "application_thread_count".to_string(),
            value: thread_count,
            timestamp: Utc::now(),
            labels: labels.clone(),
        });
        
        // 内存使用
        if let Ok(memory_info) = sysinfo::get_memory_info() {
            metrics.push(MetricPoint {
                metric_name: "application_memory_bytes".to_string(),
                value: memory_info.resident as f64,
                timestamp: Utc::now(),
                labels,
            });
        }
        
        Ok(metrics)
    }

    fn get_interval(&self) -> Duration {
        self.interval
    }
}
```

## 2. 告警规则引擎

### 2.1 告警规则定义

```rust
/// 告警规则
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertRule {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub metric_name: String,
    pub condition: AlertCondition,
    pub severity: AlertSeverity,
    pub enabled: bool,
    pub evaluation_interval: Duration,
    pub labels: HashMap<String, String>,
    pub annotations: HashMap<String, String>,
}

/// 告警条件
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AlertCondition {
    GreaterThan(f64),
    LessThan(f64),
    Equal(f64),
    NotEqual(f64),
    GreaterThanOrEqual(f64),
    LessThanOrEqual(f64),
    Between(f64, f64),
    NotBetween(f64, f64),
    ChangeRate(f64), // 变化率
    Custom(String), // 自定义条件
}

/// 告警严重程度
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum AlertSeverity {
    Info = 1,
    Warning = 2,
    Error = 3,
    Critical = 4,
}

/// 告警状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AlertStatus {
    Firing,
    Resolved,
    Pending,
}

/// 告警实例
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Alert {
    pub id: String,
    pub rule_id: String,
    pub status: AlertStatus,
    pub severity: AlertSeverity,
    pub metric_value: f64,
    pub threshold: f64,
    pub timestamp: DateTime<Utc>,
    pub labels: HashMap<String, String>,
    pub annotations: HashMap<String, String>,
    pub resolved_at: Option<DateTime<Utc>>,
}

/// 告警管理器
pub struct AlertManager {
    rules: HashMap<String, AlertRule>,
    alerts: HashMap<String, Alert>,
    storage: Box<dyn AlertStorage>,
    notifiers: Vec<Box<dyn AlertNotifier>>,
}

impl AlertManager {
    pub fn new(storage: Box<dyn AlertStorage>) -> Self {
        Self {
            rules: HashMap::new(),
            alerts: HashMap::new(),
            storage,
            notifiers: Vec::new(),
        }
    }

    /// 添加告警规则
    pub fn add_rule(&mut self, rule: AlertRule) {
        self.rules.insert(rule.id.clone(), rule);
    }

    /// 注册通知器
    pub fn register_notifier(&mut self, notifier: Box<dyn AlertNotifier>) {
        self.notifiers.push(notifier);
    }

    /// 评估告警
    pub async fn evaluate_alerts(&mut self, metric_points: &[MetricPoint]) -> Result<(), Box<dyn std::error::Error>> {
        for rule in self.rules.values() {
            if !rule.enabled {
                continue;
            }
            
            // 查找匹配的指标点
            let matching_points: Vec<&MetricPoint> = metric_points.iter()
                .filter(|point| point.metric_name == rule.metric_name)
                .collect();
            
            if matching_points.is_empty() {
                continue;
            }
            
            // 评估条件
            for point in matching_points {
                if self.evaluate_condition(point, &rule.condition).await? {
                    // 触发告警
                    self.trigger_alert(rule, point).await?;
                } else {
                    // 检查是否需要解决告警
                    self.resolve_alert(rule, point).await?;
                }
            }
        }
        
        Ok(())
    }

    /// 评估条件
    async fn evaluate_condition(&self, point: &MetricPoint, condition: &AlertCondition) -> Result<bool, Box<dyn std::error::Error>> {
        match condition {
            AlertCondition::GreaterThan(threshold) => {
                Ok(point.value > *threshold)
            }
            AlertCondition::LessThan(threshold) => {
                Ok(point.value < *threshold)
            }
            AlertCondition::Equal(value) => {
                Ok(point.value == *value)
            }
            AlertCondition::NotEqual(value) => {
                Ok(point.value != *value)
            }
            AlertCondition::GreaterThanOrEqual(threshold) => {
                Ok(point.value >= *threshold)
            }
            AlertCondition::LessThanOrEqual(threshold) => {
                Ok(point.value <= *threshold)
            }
            AlertCondition::Between(min, max) => {
                Ok(point.value >= *min && point.value <= *max)
            }
            AlertCondition::NotBetween(min, max) => {
                Ok(point.value < *min || point.value > *max)
            }
            AlertCondition::ChangeRate(rate) => {
                // 计算变化率
                // 这里需要历史数据来计算变化率
                Ok(false)
            }
            AlertCondition::Custom(expression) => {
                // 自定义条件评估
                self.evaluate_custom_condition(point, expression).await
            }
        }
    }

    /// 评估自定义条件
    async fn evaluate_custom_condition(&self, point: &MetricPoint, expression: &str) -> Result<bool, Box<dyn std::error::Error>> {
        // 简化的自定义条件评估
        // 实际实现应该支持复杂的表达式解析
        Ok(false)
    }

    /// 触发告警
    async fn trigger_alert(&mut self, rule: &AlertRule, point: &MetricPoint) -> Result<(), Box<dyn std::error::Error>> {
        let alert_id = format!("{}_{}", rule.id, point.timestamp.timestamp());
        
        // 检查是否已存在相同告警
        if self.alerts.contains_key(&alert_id) {
            return Ok(());
        }
        
        let alert = Alert {
            id: alert_id.clone(),
            rule_id: rule.id.clone(),
            status: AlertStatus::Firing,
            severity: rule.severity.clone(),
            metric_value: point.value,
            threshold: self.get_threshold_value(&rule.condition),
            timestamp: point.timestamp,
            labels: rule.labels.clone(),
            annotations: rule.annotations.clone(),
            resolved_at: None,
        };
        
        // 存储告警
        self.storage.store_alert(alert.clone()).await?;
        self.alerts.insert(alert_id, alert.clone());
        
        // 发送通知
        for notifier in &self.notifiers {
            if let Err(e) = notifier.send_alert(&alert).await {
                eprintln!("Failed to send alert notification: {}", e);
            }
        }
        
        Ok(())
    }

    /// 解决告警
    async fn resolve_alert(&mut self, rule: &AlertRule, point: &MetricPoint) -> Result<(), Box<dyn std::error::Error>> {
        let alert_id = format!("{}_{}", rule.id, point.timestamp.timestamp());
        
        if let Some(alert) = self.alerts.get_mut(&alert_id) {
            if alert.status == AlertStatus::Firing {
                alert.status = AlertStatus::Resolved;
                alert.resolved_at = Some(Utc::now());
                
                // 更新存储
                self.storage.update_alert(alert.clone()).await?;
                
                // 发送解决通知
                for notifier in &self.notifiers {
                    if let Err(e) = notifier.send_resolution(&alert).await {
                        eprintln!("Failed to send resolution notification: {}", e);
                    }
                }
            }
        }
        
        Ok(())
    }

    /// 获取阈值值
    fn get_threshold_value(&self, condition: &AlertCondition) -> f64 {
        match condition {
            AlertCondition::GreaterThan(threshold) => *threshold,
            AlertCondition::LessThan(threshold) => *threshold,
            AlertCondition::Equal(value) => *value,
            AlertCondition::NotEqual(value) => *value,
            AlertCondition::GreaterThanOrEqual(threshold) => *threshold,
            AlertCondition::LessThanOrEqual(threshold) => *threshold,
            AlertCondition::Between(min, _) => *min,
            AlertCondition::NotBetween(min, _) => *min,
            AlertCondition::ChangeRate(rate) => *rate,
            AlertCondition::Custom(_) => 0.0,
        }
    }

    /// 获取活跃告警
    pub async fn get_active_alerts(&self) -> Result<Vec<Alert>, Box<dyn std::error::Error>> {
        self.storage.get_active_alerts().await
    }

    /// 获取告警历史
    pub async fn get_alert_history(&self, start_time: DateTime<Utc>, end_time: DateTime<Utc>) -> Result<Vec<Alert>, Box<dyn std::error::Error>> {
        self.storage.get_alert_history(start_time, end_time).await
    }
}
```

### 2.2 告警通知器

```rust
/// 告警通知器接口
#[async_trait::async_trait]
pub trait AlertNotifier: Send + Sync {
    async fn send_alert(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>>;
    async fn send_resolution(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>>;
}

/// 邮件通知器
pub struct EmailNotifier {
    smtp_server: String,
    smtp_port: u16,
    username: String,
    password: String,
    from_email: String,
    to_emails: Vec<String>,
}

impl EmailNotifier {
    pub fn new(smtp_server: String, smtp_port: u16, username: String, password: String, from_email: String, to_emails: Vec<String>) -> Self {
        Self {
            smtp_server,
            smtp_port,
            username,
            password,
            from_email,
            to_emails,
        }
    }
}

#[async_trait::async_trait]
impl AlertNotifier for EmailNotifier {
    async fn send_alert(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>> {
        let subject = format!("[{}] Alert: {}", alert.severity, alert.id);
        let body = format!(
            "Alert Details:\n\
             ID: {}\n\
             Severity: {:?}\n\
             Metric Value: {}\n\
             Threshold: {}\n\
             Timestamp: {}\n\
             Labels: {:?}",
            alert.id, alert.severity, alert.metric_value, alert.threshold, alert.timestamp, alert.labels
        );
        
        // 这里应该实现实际的邮件发送逻辑
        println!("Sending email alert: {} - {}", subject, body);
        
        Ok(())
    }

    async fn send_resolution(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>> {
        let subject = format!("[RESOLVED] Alert: {}", alert.id);
        let body = format!(
            "Alert Resolved:\n\
             ID: {}\n\
             Resolved at: {}\n\
             Duration: {}",
            alert.id,
            alert.resolved_at.unwrap_or(Utc::now()),
            alert.resolved_at.unwrap_or(Utc::now()) - alert.timestamp
        );
        
        println!("Sending email resolution: {} - {}", subject, body);
        
        Ok(())
    }
}

/// Webhook通知器
pub struct WebhookNotifier {
    webhook_url: String,
    headers: HashMap<String, String>,
}

impl WebhookNotifier {
    pub fn new(webhook_url: String) -> Self {
        Self {
            webhook_url,
            headers: HashMap::new(),
        }
    }

    pub fn add_header(&mut self, key: String, value: String) {
        self.headers.insert(key, value);
    }
}

#[async_trait::async_trait]
impl AlertNotifier for WebhookNotifier {
    async fn send_alert(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>> {
        let payload = serde_json::json!({
            "type": "alert",
            "alert": {
                "id": alert.id,
                "severity": format!("{:?}", alert.severity),
                "metric_value": alert.metric_value,
                "threshold": alert.threshold,
                "timestamp": alert.timestamp.to_rfc3339(),
                "labels": alert.labels,
                "annotations": alert.annotations
            }
        });
        
        // 这里应该实现实际的HTTP请求逻辑
        println!("Sending webhook alert to {}: {}", self.webhook_url, payload);
        
        Ok(())
    }

    async fn send_resolution(&self, alert: &Alert) -> Result<(), Box<dyn std::error::Error>> {
        let payload = serde_json::json!({
            "type": "resolution",
            "alert": {
                "id": alert.id,
                "resolved_at": alert.resolved_at.unwrap_or(Utc::now()).to_rfc3339(),
                "duration": (alert.resolved_at.unwrap_or(Utc::now()) - alert.timestamp).num_seconds()
            }
        });
        
        println!("Sending webhook resolution to {}: {}", self.webhook_url, payload);
        
        Ok(())
    }
}
```

## 3. 监控存储接口

### 3.1 指标存储接口

```rust
/// 指标存储接口
#[async_trait::async_trait]
pub trait MetricStorage: Send + Sync {
    async fn store_metric(&self, metric: MetricPoint) -> Result<(), Box<dyn std::error::Error>>;
    async fn query_metrics(&self, metric_name: &str, start_time: DateTime<Utc>, end_time: DateTime<Utc>) -> Result<Vec<MetricPoint>, Box<dyn std::error::Error>>;
    async fn get_latest_metric(&self, metric_name: &str) -> Result<Option<MetricPoint>, Box<dyn std::error::Error>>;
    async fn delete_metrics(&self, metric_name: &str, before_time: DateTime<Utc>) -> Result<(), Box<dyn std::error::Error>>;
}

/// 告警存储接口
#[async_trait::async_trait]
pub trait AlertStorage: Send + Sync {
    async fn store_alert(&self, alert: Alert) -> Result<(), Box<dyn std::error::Error>>;
    async fn update_alert(&self, alert: Alert) -> Result<(), Box<dyn std::error::Error>>;
    async fn get_active_alerts(&self) -> Result<Vec<Alert>, Box<dyn std::error::Error>>;
    async fn get_alert_history(&self, start_time: DateTime<Utc>, end_time: DateTime<Utc>) -> Result<Vec<Alert>, Box<dyn std::error::Error>>;
    async fn delete_alerts(&self, before_time: DateTime<Utc>) -> Result<(), Box<dyn std::error::Error>>;
}
```

## 4. 应用示例

### 4.1 IoT系统监控告警

```rust
use crate::monitoring::{MetricCollector, AlertManager, AlertRule, AlertCondition, AlertSeverity};
use crate::notifiers::{EmailNotifier, WebhookNotifier};

async fn iot_monitoring_alert_system() -> Result<(), Box<dyn std::error::Error>> {
    // 创建指标收集器
    let storage = Box::new(InMemoryMetricStorage::new());
    let mut collector = MetricCollector::new(storage);
    
    // 注册系统监控收集器
    let system_collector = Box::new(SystemMetricCollector::new(Duration::from_secs(30)));
    collector.register_collector("system".to_string(), system_collector);
    
    // 注册应用监控收集器
    let app_collector = Box::new(ApplicationMetricCollector::new("iot_platform".to_string(), Duration::from_secs(60)));
    collector.register_collector("application".to_string(), app_collector);
    
    // 创建告警管理器
    let alert_storage = Box::new(InMemoryAlertStorage::new());
    let mut alert_manager = AlertManager::new(alert_storage);
    
    // 定义告警规则
    let cpu_alert_rule = AlertRule {
        id: "high_cpu_usage".to_string(),
        name: "High CPU Usage".to_string(),
        description: Some("CPU usage is above 80%".to_string()),
        metric_name: "cpu_usage_percent".to_string(),
        condition: AlertCondition::GreaterThan(80.0),
        severity: AlertSeverity::Warning,
        enabled: true,
        evaluation_interval: Duration::from_secs(60),
        labels: {
            let mut labels = HashMap::new();
            labels.insert("component".to_string(), "system".to_string());
            labels
        },
        annotations: {
            let mut annotations = HashMap::new();
            annotations.insert("summary".to_string(), "High CPU usage detected".to_string());
            annotations.insert("description".to_string(), "CPU usage has exceeded 80% threshold".to_string());
            annotations
        },
    };
    
    let memory_alert_rule = AlertRule {
        id: "high_memory_usage".to_string(),
        name: "High Memory Usage".to_string(),
        description: Some("Memory usage is above 90%".to_string()),
        metric_name: "memory_usage_percent".to_string(),
        condition: AlertCondition::GreaterThan(90.0),
        severity: AlertSeverity::Critical,
        enabled: true,
        evaluation_interval: Duration::from_secs(60),
        labels: {
            let mut labels = HashMap::new();
            labels.insert("component".to_string(), "system".to_string());
            labels
        },
        annotations: {
            let mut annotations = HashMap::new();
            annotations.insert("summary".to_string(), "Critical memory usage".to_string());
            annotations.insert("description".to_string(), "Memory usage has exceeded 90% threshold".to_string());
            annotations
        },
    };
    
    let disk_alert_rule = AlertRule {
        id: "high_disk_usage".to_string(),
        name: "High Disk Usage".to_string(),
        description: Some("Disk usage is above 85%".to_string()),
        metric_name: "disk_usage_percent".to_string(),
        condition: AlertCondition::GreaterThan(85.0),
        severity: AlertSeverity::Warning,
        enabled: true,
        evaluation_interval: Duration::from_secs(300), // 5分钟
        labels: {
            let mut labels = HashMap::new();
            labels.insert("component".to_string(), "storage".to_string());
            labels
        },
        annotations: {
            let mut annotations = HashMap::new();
            annotations.insert("summary".to_string(), "High disk usage".to_string());
            annotations.insert("description".to_string(), "Disk usage has exceeded 85% threshold".to_string());
            annotations
        },
    };
    
    // 添加告警规则
    alert_manager.add_rule(cpu_alert_rule);
    alert_manager.add_rule(memory_alert_rule);
    alert_manager.add_rule(disk_alert_rule);
    
    // 注册通知器
    let email_notifier = Box::new(EmailNotifier::new(
        "smtp.gmail.com".to_string(),
        587,
        "alerts@company.com".to_string(),
        "password".to_string(),
        "alerts@company.com".to_string(),
        vec!["admin@company.com".to_string(), "ops@company.com".to_string()],
    ));
    
    let webhook_notifier = Box::new(WebhookNotifier::new(
        "https://hooks.slack.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX".to_string(),
    ));
    
    alert_manager.register_notifier(email_notifier);
    alert_manager.register_notifier(webhook_notifier);
    
    // 启动监控收集
    collector.start_collection().await?;
    
    // 启动告警评估循环
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(60));
        
        loop {
            interval.tick().await;
            
            // 获取最新的指标数据
            let end_time = Utc::now();
            let start_time = end_time - chrono::Duration::minutes(5);
            
            let cpu_metrics = collector.query_metrics("cpu_usage_percent", start_time, end_time).await.unwrap_or_default();
            let memory_metrics = collector.query_metrics("memory_usage_percent", start_time, end_time).await.unwrap_or_default();
            let disk_metrics = collector.query_metrics("disk_usage_percent", start_time, end_time).await.unwrap_or_default();
            
            let mut all_metrics = Vec::new();
            all_metrics.extend(cpu_metrics);
            all_metrics.extend(memory_metrics);
            all_metrics.extend(disk_metrics);
            
            // 评估告警
            if let Err(e) = alert_manager.evaluate_alerts(&all_metrics).await {
                eprintln!("Failed to evaluate alerts: {}", e);
            }
        }
    });
    
    // 监控循环
    loop {
        // 获取活跃告警
        let active_alerts = alert_manager.get_active_alerts().await?;
        println!("Active alerts: {}", active_alerts.len());
        
        for alert in active_alerts {
            println!("Alert: {} - {:?} - {}", alert.id, alert.severity, alert.metric_value);
        }
        
        tokio::time::sleep(Duration::from_secs(30)).await;
    }
}
```

## 5. 总结

本实现提供了：

1. **完整的监控数据收集** - 系统和应用指标收集
2. **灵活的告警规则引擎** - 支持多种告警条件
3. **多种通知方式** - 邮件和Webhook通知
4. **可扩展的存储接口** - 支持不同的存储后端
5. **实际应用示例** - IoT系统监控告警

这个监控告警系统为IoT平台提供了强大的监控和告警能力，支持实时监控和智能告警。
