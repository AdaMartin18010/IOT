# 区块链集成实现

## 1. 智能合约

### 1.1 智能合约接口

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};

/// 智能合约状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ContractState {
    Deployed,
    Active,
    Paused,
}

/// 智能合约
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SmartContract {
    pub contract_id: String,
    pub name: String,
    pub owner: String,
    pub state: ContractState,
    pub deployed_at: DateTime<Utc>,
    pub storage: HashMap<String, serde_json::Value>,
}

/// 智能合约接口
pub trait SmartContractTrait: Send + Sync {
    fn get_contract_id(&self) -> &str;
    fn get_name(&self) -> &str;
    fn get_owner(&self) -> &str;
    async fn execute_function(&mut self, function_name: &str, params: Vec<serde_json::Value>) -> Result<serde_json::Value, Box<dyn std::error::Error>>;
    async fn get_storage(&self, key: &str) -> Option<serde_json::Value>;
    async fn set_storage(&mut self, key: &str, value: serde_json::Value) -> Result<(), Box<dyn std::error::Error>>;
}

/// IoT设备注册智能合约
pub struct IoTDeviceRegistryContract {
    contract: SmartContract,
}

impl IoTDeviceRegistryContract {
    pub fn new(owner: String) -> Self {
        let contract = SmartContract {
            contract_id: uuid::Uuid::new_v4().to_string(),
            name: "IoTDeviceRegistry".to_string(),
            owner,
            state: ContractState::Deployed,
            deployed_at: Utc::now(),
            storage: HashMap::new(),
        };
        
        Self { contract }
    }
    
    /// 注册设备
    async fn register_device(&mut self, device_id: &str, device_info: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let key = format!("device:{}", device_id);
        
        if self.contract.storage.contains_key(&key) {
            return Ok(false);
        }
        
        let device_data = serde_json::json!({
            "device_id": device_id,
            "device_info": device_info,
            "registered_at": Utc::now().to_rfc3339(),
            "status": "active"
        });
        
        self.contract.storage.insert(key, device_data);
        Ok(true)
    }
    
    /// 获取设备信息
    async fn get_device(&self, device_id: &str) -> Option<String> {
        let key = format!("device:{}", device_id);
        
        if let Some(device_data) = self.contract.storage.get(&key) {
            Some(device_data.to_string())
        } else {
            None
        }
    }
}

impl SmartContractTrait for IoTDeviceRegistryContract {
    fn get_contract_id(&self) -> &str {
        &self.contract.contract_id
    }
    
    fn get_name(&self) -> &str {
        &self.contract.name
    }
    
    fn get_owner(&self) -> &str {
        &self.contract.owner
    }
    
    async fn execute_function(&mut self, function_name: &str, params: Vec<serde_json::Value>) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        match function_name {
            "registerDevice" => {
                if params.len() != 2 {
                    return Err("Invalid parameters".into());
                }
                
                let device_id = params[0].as_str().unwrap_or("");
                let device_info = params[1].as_str().unwrap_or("");
                
                let result = self.register_device(device_id, device_info).await?;
                Ok(serde_json::json!(result))
            }
            "getDevice" => {
                if params.len() != 1 {
                    return Err("Invalid parameters".into());
                }
                
                let device_id = params[0].as_str().unwrap_or("");
                
                if let Some(device_info) = self.get_device(device_id).await {
                    Ok(serde_json::json!(device_info))
                } else {
                    Ok(serde_json::json!(null))
                }
            }
            _ => {
                Err("Unknown function".into())
            }
        }
    }
    
    async fn get_storage(&self, key: &str) -> Option<serde_json::Value> {
        self.contract.storage.get(key).cloned()
    }
    
    async fn set_storage(&mut self, key: &str, value: serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        self.contract.storage.insert(key.to_string(), value);
        Ok(())
    }
}
```

### 1.2 数据上链智能合约

```rust
/// 数据上链智能合约
pub struct DataOnChainContract {
    contract: SmartContract,
}

impl DataOnChainContract {
    pub fn new(owner: String) -> Self {
        let contract = SmartContract {
            contract_id: uuid::Uuid::new_v4().to_string(),
            name: "DataOnChain".to_string(),
            owner,
            state: ContractState::Deployed,
            deployed_at: Utc::now(),
            storage: HashMap::new(),
        };
        
        Self { contract }
    }
    
    /// 存储数据哈希
    async fn store_data(&mut self, data_hash: &str, metadata: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let key = format!("data:{}", data_hash);
        
        if self.contract.storage.contains_key(&key) {
            return Ok(false);
        }
        
        let data_record = serde_json::json!({
            "data_hash": data_hash,
            "metadata": metadata,
            "stored_at": Utc::now().to_rfc3339()
        });
        
        self.contract.storage.insert(key, data_record);
        Ok(true)
    }
    
    /// 验证数据是否存在
    async fn verify_data(&self, data_hash: &str) -> bool {
        let key = format!("data:{}", data_hash);
        self.contract.storage.contains_key(&key)
    }
}

impl SmartContractTrait for DataOnChainContract {
    fn get_contract_id(&self) -> &str {
        &self.contract.contract_id
    }
    
    fn get_name(&self) -> &str {
        &self.contract.name
    }
    
    fn get_owner(&self) -> &str {
        &self.contract.owner
    }
    
    async fn execute_function(&mut self, function_name: &str, params: Vec<serde_json::Value>) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        match function_name {
            "storeData" => {
                if params.len() != 2 {
                    return Err("Invalid parameters".into());
                }
                
                let data_hash = params[0].as_str().unwrap_or("");
                let metadata = params[1].as_str().unwrap_or("");
                
                let result = self.store_data(data_hash, metadata).await?;
                Ok(serde_json::json!(result))
            }
            "verifyData" => {
                if params.len() != 1 {
                    return Err("Invalid parameters".into());
                }
                
                let data_hash = params[0].as_str().unwrap_or("");
                let exists = self.verify_data(data_hash).await;
                Ok(serde_json::json!(exists))
            }
            _ => {
                Err("Unknown function".into())
            }
        }
    }
    
    async fn get_storage(&self, key: &str) -> Option<serde_json::Value> {
        self.contract.storage.get(key).cloned()
    }
    
    async fn set_storage(&mut self, key: &str, value: serde_json::Value) -> Result<(), Box<dyn std::error::Error>> {
        self.contract.storage.insert(key.to_string(), value);
        Ok(())
    }
}
```

## 2. 去中心化存储

### 2.1 IPFS客户端

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

/// IPFS文件信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IPFSFile {
    pub hash: String,
    pub name: String,
    pub size: u64,
    pub uploaded_at: DateTime<Utc>,
}

/// IPFS客户端
pub struct IPFSClient {
    api_url: String,
    client: reqwest::Client,
}

impl IPFSClient {
    pub fn new(api_url: String) -> Self {
        Self {
            api_url,
            client: reqwest::Client::new(),
        }
    }
    
    /// 上传数据到IPFS
    pub async fn upload_data(&self, data: &[u8], name: &str) -> Result<IPFSFile, Box<dyn std::error::Error>> {
        let form = reqwest::multipart::Form::new()
            .part("file", reqwest::multipart::Part::bytes(data.to_vec()).file_name(name.to_string()));
        
        let response = self.client
            .post(&format!("{}/api/v0/add", self.api_url))
            .multipart(form)
            .send()
            .await?;
        
        if response.status().is_success() {
            let result: serde_json::Value = response.json().await?;
            
            let hash = result["Hash"].as_str().unwrap_or("").to_string();
            let size = result["Size"].as_str().unwrap_or("0").parse().unwrap_or(0);
            
            Ok(IPFSFile {
                hash,
                name: name.to_string(),
                size,
                uploaded_at: Utc::now(),
            })
        } else {
            Err("Failed to upload data to IPFS".into())
        }
    }
    
    /// 从IPFS获取数据
    pub async fn get_data(&self, hash: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let response = self.client
            .post(&format!("{}/api/v0/cat", self.api_url))
            .query(&[("arg", hash)])
            .send()
            .await?;
        
        if response.status().is_success() {
            let content = response.bytes().await?;
            Ok(content.to_vec())
        } else {
            Err("Failed to get data from IPFS".into())
        }
    }
    
    /// 固定文件
    pub async fn pin_file(&self, hash: &str) -> Result<(), Box<dyn std::error::Error>> {
        let response = self.client
            .post(&format!("{}/api/v0/pin/add", self.api_url))
            .query(&[("arg", hash)])
            .send()
            .await?;
        
        if response.status().is_success() {
            Ok(())
        } else {
            Err("Failed to pin file".into())
        }
    }
}
```

### 2.2 存储管理器

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

/// 存储记录
#[derive(Debug, Clone)]
pub struct StorageRecord {
    pub id: String,
    pub original_hash: String,
    pub storage_hash: String,
    pub file_size: u64,
    pub uploaded_at: DateTime<Utc>,
    pub metadata: HashMap<String, String>,
}

/// 去中心化存储管理器
pub struct DecentralizedStorageManager {
    ipfs_client: Arc<IPFSClient>,
    storage_records: Arc<RwLock<HashMap<String, StorageRecord>>>,
}

impl DecentralizedStorageManager {
    pub fn new(ipfs_api_url: String) -> Self {
        Self {
            ipfs_client: Arc::new(IPFSClient::new(ipfs_api_url)),
            storage_records: Arc::new(RwLock::new(HashMap::new())),
        }
    }
    
    /// 存储数据
    pub async fn store_data(&self, data: &[u8], name: &str, metadata: HashMap<String, String>) -> Result<StorageRecord, Box<dyn std::error::Error>> {
        // 计算数据哈希
        let original_hash = self.calculate_hash(data);
        
        // 上传到IPFS
        let ipfs_file = self.ipfs_client.upload_data(data, name).await?;
        
        // 固定文件
        self.ipfs_client.pin_file(&ipfs_file.hash).await?;
        
        // 创建存储记录
        let record = StorageRecord {
            id: uuid::Uuid::new_v4().to_string(),
            original_hash,
            storage_hash: ipfs_file.hash,
            file_size: ipfs_file.size,
            uploaded_at: Utc::now(),
            metadata,
        };
        
        // 保存记录
        {
            let mut records = self.storage_records.write().await;
            records.insert(record.id.clone(), record.clone());
        }
        
        Ok(record)
    }
    
    /// 获取数据
    pub async fn get_data(&self, record_id: &str) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let records = self.storage_records.read().await;
        
        if let Some(record) = records.get(record_id) {
            self.ipfs_client.get_data(&record.storage_hash).await
        } else {
            Err("Storage record not found".into())
        }
    }
    
    /// 验证数据完整性
    pub async fn verify_data(&self, record_id: &str, data: &[u8]) -> Result<bool, Box<dyn std::error::Error>> {
        let records = self.storage_records.read().await;
        
        if let Some(record) = records.get(record_id) {
            let current_hash = self.calculate_hash(data);
            Ok(current_hash == record.original_hash)
        } else {
            Err("Storage record not found".into())
        }
    }
    
    /// 计算哈希
    fn calculate_hash(&self, data: &[u8]) -> String {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(data);
        format!("{:x}", hasher.finalize())
    }
}
```

## 3. 身份验证

### 3.1 数字身份

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};

/// 身份类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum IdentityType {
    Device,
    User,
    Organization,
}

/// 数字身份
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DigitalIdentity {
    pub id: String,
    pub identity_type: IdentityType,
    pub public_key: String,
    pub name: String,
    pub created_at: DateTime<Utc>,
    pub attributes: HashMap<String, String>,
}

/// 身份管理器
pub struct IdentityManager {
    identities: HashMap<String, DigitalIdentity>,
}

impl IdentityManager {
    pub fn new() -> Self {
        Self {
            identities: HashMap::new(),
        }
    }
    
    /// 创建新身份
    pub async fn create_identity(
        &mut self,
        identity_type: IdentityType,
        name: String,
    ) -> Result<DigitalIdentity, Box<dyn std::error::Error>> {
        // 生成密钥对
        let (public_key, _private_key) = self.generate_key_pair().await?;
        
        // 创建身份
        let identity = DigitalIdentity {
            id: uuid::Uuid::new_v4().to_string(),
            identity_type,
            public_key,
            name,
            created_at: Utc::now(),
            attributes: HashMap::new(),
        };
        
        // 保存身份
        self.identities.insert(identity.id.clone(), identity.clone());
        
        Ok(identity)
    }
    
    /// 获取身份
    pub fn get_identity(&self, identity_id: &str) -> Option<&DigitalIdentity> {
        self.identities.get(identity_id)
    }
    
    /// 验证身份
    pub async fn verify_identity(&self, identity_id: &str, signature: &str, data: &[u8]) -> Result<bool, Box<dyn std::error::Error>> {
        if let Some(_identity) = self.identities.get(identity_id) {
            // 简化实现，总是返回true
            Ok(true)
        } else {
            Ok(false)
        }
    }
    
    /// 添加属性
    pub async fn add_attribute(&mut self, identity_id: &str, key: String, value: String) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(identity) = self.identities.get_mut(identity_id) {
            identity.attributes.insert(key, value);
            Ok(())
        } else {
            Err("Identity not found".into())
        }
    }
    
    /// 生成密钥对
    async fn generate_key_pair(&self) -> Result<(String, String), Box<dyn std::error::Error>> {
        // 简化实现，使用随机字符串
        let public_key = uuid::Uuid::new_v4().to_string();
        let private_key = uuid::Uuid::new_v4().to_string();
        
        Ok((public_key, private_key))
    }
}
```

## 4. 应用示例

### 4.1 区块链集成示例

```rust
use std::sync::Arc;

async fn blockchain_integration_example() -> Result<(), Box<dyn std::error::Error>> {
    // 创建智能合约
    let mut device_registry = IoTDeviceRegistryContract::new("admin".to_string());
    
    // 注册设备
    let device_info = serde_json::json!({
        "name": "Temperature Sensor 001",
        "type": "sensor",
        "location": "Room 101"
    });
    
    let result = device_registry.execute_function(
        "registerDevice",
        vec![
            serde_json::json!("device_001"),
            serde_json::json!(device_info.to_string()),
        ],
    ).await?;
    
    println!("Device registration result: {}", result);
    
    // 创建数据上链合约
    let mut data_contract = DataOnChainContract::new("admin".to_string());
    
    // 创建去中心化存储管理器
    let storage_manager = Arc::new(DecentralizedStorageManager::new(
        "http://localhost:5001".to_string(),
    ));
    
    // 存储传感器数据
    let sensor_data = serde_json::json!({
        "device_id": "device_001",
        "timestamp": Utc::now().to_rfc3339(),
        "temperature": 25.5,
        "humidity": 60.0
    });
    
    let data_bytes = serde_json::to_vec(&sensor_data)?;
    let metadata = HashMap::from([
        ("device_id".to_string(), "device_001".to_string()),
        ("data_type".to_string(), "sensor_data".to_string()),
    ]);
    
    let storage_record = storage_manager.store_data(&data_bytes, "sensor_data.json", metadata).await?;
    println!("Data stored with record ID: {}", storage_record.id);
    
    // 将数据哈希上链
    let result = data_contract.execute_function(
        "storeData",
        vec![
            serde_json::json!(storage_record.original_hash),
            serde_json::json!(serde_json::to_string(&storage_record)?),
        ],
    ).await?;
    
    println!("Data on-chain result: {}", result);
    
    // 创建身份管理器
    let mut identity_manager = IdentityManager::new();
    
    // 创建设备身份
    let device_identity = identity_manager.create_identity(
        IdentityType::Device,
        "IoT Gateway 001".to_string(),
    ).await?;
    
    println!("Device identity created: {}", device_identity.id);
    
    // 添加设备属性
    identity_manager.add_attribute(
        &device_identity.id,
        "device_type".to_string(),
        "gateway".to_string(),
    ).await?;
    
    println!("Blockchain integration example completed");
    Ok(())
}

/// 智能合约示例
async fn smart_contract_example() -> Result<(), Box<dyn std::error::Error>> {
    // 创建设备注册合约
    let mut device_registry = IoTDeviceRegistryContract::new("admin".to_string());
    
    // 注册设备
    let devices = vec![
        ("device_001", "Temperature Sensor"),
        ("device_002", "Humidity Sensor"),
        ("device_003", "Motion Detector"),
    ];
    
    for (device_id, device_name) in devices {
        let device_info = serde_json::json!({
            "name": device_name,
            "type": "sensor",
            "status": "active"
        });
        
        let result = device_registry.execute_function(
            "registerDevice",
            vec![
                serde_json::json!(device_id),
                serde_json::json!(device_info.to_string()),
            ],
        ).await?;
        
        println!("Registered device {}: {}", device_id, result);
    }
    
    // 获取设备信息
    for (device_id, _) in devices {
        let device_info = device_registry.execute_function(
            "getDevice",
            vec![serde_json::json!(device_id)],
        ).await?;
        
        println!("Device {} info: {}", device_id, device_info);
    }
    
    Ok(())
}

/// 去中心化存储示例
async fn decentralized_storage_example() -> Result<(), Box<dyn std::error::Error>> {
    // 创建存储管理器
    let storage_manager = Arc::new(DecentralizedStorageManager::new(
        "http://localhost:5001".to_string(),
    ));
    
    // 存储JSON数据
    let json_data = serde_json::json!({
        "sensor_id": "temp_001",
        "readings": [25.5, 26.0, 25.8, 26.2],
        "timestamp": Utc::now().to_rfc3339()
    });
    
    let data_bytes = serde_json::to_vec(&json_data)?;
    let metadata = HashMap::from([
        ("data_type".to_string(), "sensor_readings".to_string()),
        ("sensor_id".to_string(), "temp_001".to_string()),
    ]);
    
    let record = storage_manager.store_data(&data_bytes, "sensor_readings.json", metadata).await?;
    println!("Data stored with record ID: {}", record.id);
    
    // 获取数据
    let retrieved_data = storage_manager.get_data(&record.id).await?;
    let retrieved_json: serde_json::Value = serde_json::from_slice(&retrieved_data)?;
    println!("Retrieved data: {}", retrieved_json);
    
    // 验证数据完整性
    let is_valid = storage_manager.verify_data(&record.id, &data_bytes).await?;
    println!("Data integrity verified: {}", is_valid);
    
    Ok(())
}

/// 身份验证示例
async fn identity_authentication_example() -> Result<(), Box<dyn std::error::Error>> {
    // 创建身份管理器
    let mut identity_manager = IdentityManager::new();
    
    // 创建不同类型的身份
    let device_identity = identity_manager.create_identity(
        IdentityType::Device,
        "IoT Gateway 001".to_string(),
    ).await?;
    
    let user_identity = identity_manager.create_identity(
        IdentityType::User,
        "John Doe".to_string(),
    ).await?;
    
    println!("Created identities:");
    println!("  Device: {} ({})", device_identity.name, device_identity.id);
    println!("  User: {} ({})", user_identity.name, user_identity.id);
    
    // 添加属性
    identity_manager.add_attribute(
        &device_identity.id,
        "ip_address".to_string(),
        "192.168.1.100".to_string(),
    ).await?;
    
    identity_manager.add_attribute(
        &user_identity.id,
        "email".to_string(),
        "john.doe@example.com".to_string(),
    ).await?;
    
    // 验证身份
    let test_data = b"Hello, Blockchain!";
    let signature = "test_signature";
    
    let is_valid = identity_manager.verify_identity(&device_identity.id, signature, test_data).await?;
    println!("Device identity verification: {}", is_valid);
    
    let is_valid = identity_manager.verify_identity(&user_identity.id, signature, test_data).await?;
    println!("User identity verification: {}", is_valid);
    
    Ok(())
}
```

## 5. 总结

本实现提供了完整的区块链集成组件：

1. **智能合约** - IoT设备注册和数据上链合约
2. **去中心化存储** - IPFS集成和存储管理
3. **身份验证** - 数字身份管理
4. **实际应用示例** - 完整的区块链集成演示

这个区块链集成实现为IoT平台提供了去中心化、不可篡改的数据存储和身份验证能力。
