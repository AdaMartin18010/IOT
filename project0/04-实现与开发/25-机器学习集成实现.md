# 机器学习集成实现

## 1. 特征工程

### 1.1 特征提取器

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};

/// 特征类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum FeatureType {
    Numerical,
    Categorical,
    Temporal,
}

/// 特征
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Feature {
    pub name: String,
    pub value: f64,
    pub feature_type: FeatureType,
}

/// 特征提取器
pub trait FeatureExtractor: Send + Sync {
    fn extract_features(&self, data: &serde_json::Value) -> Result<Vec<Feature>, Box<dyn std::error::Error>>;
}

/// IoT传感器特征提取器
pub struct IoTSensorFeatureExtractor;

impl IoTSensorFeatureExtractor {
    pub fn new() -> Self {
        Self
    }
    
    /// 提取时间特征
    fn extract_time_features(&self, timestamp: &DateTime<Utc>) -> Vec<Feature> {
        vec![
            Feature {
                name: "hour_of_day".to_string(),
                value: timestamp.hour() as f64,
                feature_type: FeatureType::Numerical,
            },
            Feature {
                name: "day_of_week".to_string(),
                value: timestamp.weekday().num_days_from_monday() as f64,
                feature_type: FeatureType::Numerical,
            },
            Feature {
                name: "month".to_string(),
                value: timestamp.month() as f64,
                feature_type: FeatureType::Numerical,
            },
        ]
    }
}

impl FeatureExtractor for IoTSensorFeatureExtractor {
    fn extract_features(&self, data: &serde_json::Value) -> Result<Vec<Feature>, Box<dyn std::error::Error>> {
        let mut features = Vec::new();
        
        // 提取传感器值
        if let Some(value) = data.get("value").and_then(|v| v.as_f64()) {
            features.push(Feature {
                name: "sensor_value".to_string(),
                value,
                feature_type: FeatureType::Numerical,
            });
        }
        
        // 提取时间特征
        if let Some(timestamp_str) = data.get("timestamp").and_then(|t| t.as_str()) {
            if let Ok(timestamp) = DateTime::parse_from_rfc3339(timestamp_str) {
                let time_features = self.extract_time_features(&timestamp.with_timezone(&Utc));
                features.extend(time_features);
            }
        }
        
        Ok(features)
    }
}
```

## 2. 模型训练

### 2.1 模型接口

```rust
use async_trait::async_trait;
use serde::{Deserialize, Serialize};

/// 模型类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ModelType {
    LinearRegression,
    RandomForest,
    AnomalyDetection,
}

/// 模型状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ModelStatus {
    Training,
    Trained,
    Failed,
}

/// 模型元数据
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ModelMetadata {
    pub model_id: String,
    pub model_type: ModelType,
    pub version: String,
    pub created_at: DateTime<Utc>,
    pub status: ModelStatus,
    pub metrics: HashMap<String, f64>,
    pub feature_names: Vec<String>,
}

/// 训练样本
#[derive(Debug, Clone)]
pub struct TrainingExample {
    pub features: Vec<Feature>,
    pub target: f64,
}

/// 预测结果
#[derive(Debug, Clone)]
pub struct Prediction {
    pub value: f64,
    pub confidence: f64,
}

/// 模型接口
#[async_trait]
pub trait Model: Send + Sync {
    async fn train(&mut self, training_data: &[TrainingExample]) -> Result<ModelMetadata, Box<dyn std::error::Error>>;
    async fn predict(&self, features: &[Feature]) -> Result<Prediction, Box<dyn std::error::Error>>;
    async fn save(&self, path: &str) -> Result<(), Box<dyn std::error::Error>>;
    async fn load(path: &str) -> Result<Self, Box<dyn std::error::Error>> where Self: Sized;
    fn get_metadata(&self) -> &ModelMetadata;
}
```

### 2.2 线性回归模型

```rust
use nalgebra::{DMatrix, DVector};

/// 线性回归模型
pub struct LinearRegressionModel {
    metadata: ModelMetadata,
    coefficients: Option<DVector<f64>>,
    intercept: Option<f64>,
}

impl LinearRegressionModel {
    pub fn new() -> Self {
        Self {
            metadata: ModelMetadata {
                model_id: uuid::Uuid::new_v4().to_string(),
                model_type: ModelType::LinearRegression,
                version: "1.0.0".to_string(),
                created_at: Utc::now(),
                status: ModelStatus::Training,
                metrics: HashMap::new(),
                feature_names: Vec::new(),
            },
            coefficients: None,
            intercept: None,
        }
    }
    
    /// 特征向量化
    fn vectorize_features(&self, features: &[Feature]) -> Result<DVector<f64>, Box<dyn std::error::Error>> {
        let feature_vector: Vec<f64> = features.iter().map(|f| f.value).collect();
        Ok(DVector::from_vec(feature_vector))
    }
    
    /// 训练数据矩阵化
    fn matrixize_training_data(&self, training_data: &[TrainingExample]) -> Result<(DMatrix<f64>, DVector<f64>), Box<dyn std::error::Error>> {
        if training_data.is_empty() {
            return Err("Training data is empty".into());
        }
        
        let num_features = training_data[0].features.len();
        let num_samples = training_data.len();
        
        let mut feature_matrix = DMatrix::zeros(num_samples, num_features);
        let mut target_vector = DVector::zeros(num_samples);
        
        for (i, example) in training_data.iter().enumerate() {
            for (j, feature) in example.features.iter().enumerate() {
                feature_matrix[(i, j)] = feature.value;
            }
            target_vector[i] = example.target;
        }
        
        Ok((feature_matrix, target_vector))
    }
    
    /// 最小二乘法训练
    fn train_least_squares(&mut self, feature_matrix: &DMatrix<f64>, target_vector: &DVector<f64>) -> Result<(), Box<dyn std::error::Error>> {
        // 添加偏置项
        let mut augmented_matrix = feature_matrix.clone();
        augmented_matrix = augmented_matrix.insert_column(0, 1.0);
        
        // 计算伪逆
        let pseudo_inverse = augmented_matrix.pseudo_inverse(1e-10)?;
        
        // 计算系数
        let coefficients = pseudo_inverse * target_vector;
        
        // 分离截距和系数
        self.intercept = Some(coefficients[0]);
        self.coefficients = Some(coefficients.rows(1, coefficients.len() - 1).into());
        
        Ok(())
    }
}

#[async_trait]
impl Model for LinearRegressionModel {
    async fn train(&mut self, training_data: &[TrainingExample]) -> Result<ModelMetadata, Box<dyn std::error::Error>> {
        self.metadata.status = ModelStatus::Training;
        
        // 提取特征名称
        if !training_data.is_empty() {
            self.metadata.feature_names = training_data[0].features.iter().map(|f| f.name.clone()).collect();
        }
        
        // 矩阵化训练数据
        let (feature_matrix, target_vector) = self.matrixize_training_data(training_data)?;
        
        // 训练模型
        self.train_least_squares(&feature_matrix, &target_vector)?;
        
        // 计算训练指标
        let predictions: Vec<f64> = training_data.iter()
            .map(|example| {
                let features = self.vectorize_features(&example.features).unwrap();
                self.predict_single(&features).unwrap()
            })
            .collect();
        
        let targets: Vec<f64> = training_data.iter().map(|example| example.target).collect();
        
        // 计算R²分数
        let r2_score = self.calculate_r2_score(&targets, &predictions);
        self.metadata.metrics.insert("r2_score".to_string(), r2_score);
        
        // 计算MSE
        let mse = self.calculate_mse(&targets, &predictions);
        self.metadata.metrics.insert("mse".to_string(), mse);
        
        self.metadata.status = ModelStatus::Trained;
        
        Ok(self.metadata.clone())
    }
    
    async fn predict(&self, features: &[Feature]) -> Result<Prediction, Box<dyn std::error::Error>> {
        if self.coefficients.is_none() || self.intercept.is_none() {
            return Err("Model not trained".into());
        }
        
        let feature_vector = self.vectorize_features(features)?;
        let prediction_value = self.predict_single(&feature_vector)?;
        
        Ok(Prediction {
            value: prediction_value,
            confidence: 1.0,
        })
    }
    
    async fn save(&self, path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let model_data = ModelData {
            metadata: self.metadata.clone(),
            coefficients: self.coefficients.clone(),
            intercept: self.intercept,
        };
        
        let json = serde_json::to_string(&model_data)?;
        std::fs::write(path, json)?;
        
        Ok(())
    }
    
    async fn load(path: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let json = std::fs::read_to_string(path)?;
        let model_data: ModelData = serde_json::from_str(&json)?;
        
        Ok(Self {
            metadata: model_data.metadata,
            coefficients: model_data.coefficients,
            intercept: model_data.intercept,
        })
    }
    
    fn get_metadata(&self) -> &ModelMetadata {
        &self.metadata
    }
}

impl LinearRegressionModel {
    /// 单个预测
    fn predict_single(&self, features: &DVector<f64>) -> Result<f64, Box<dyn std::error::Error>> {
        if let (Some(coefficients), Some(intercept)) = (&self.coefficients, self.intercept) {
            let prediction = intercept + coefficients.dot(features);
            Ok(prediction)
        } else {
            Err("Model not trained".into())
        }
    }
    
    /// 计算MSE
    fn calculate_mse(&self, targets: &[f64], predictions: &[f64]) -> f64 {
        targets.iter()
            .zip(predictions.iter())
            .map(|(target, pred)| (target - pred).powi(2))
            .sum::<f64>() / targets.len() as f64
    }
    
    /// 计算R²分数
    fn calculate_r2_score(&self, targets: &[f64], predictions: &[f64]) -> f64 {
        let mean_target = targets.iter().sum::<f64>() / targets.len() as f64;
        
        let ss_res: f64 = targets.iter()
            .zip(predictions.iter())
            .map(|(target, pred)| (target - pred).powi(2))
            .sum();
        
        let ss_tot: f64 = targets.iter()
            .map(|target| (target - mean_target).powi(2))
            .sum();
        
        if ss_tot == 0.0 {
            1.0
        } else {
            1.0 - (ss_res / ss_tot)
        }
    }
}

/// 模型数据（用于序列化）
#[derive(Debug, Serialize, Deserialize)]
struct ModelData {
    metadata: ModelMetadata,
    coefficients: Option<DVector<f64>>,
    intercept: Option<f64>,
}
```

## 3. 推理服务

### 3.1 推理引擎

```rust
use std::sync::Arc;
use tokio::sync::RwLock;

/// 推理引擎
pub struct InferenceEngine {
    models: Arc<RwLock<HashMap<String, Box<dyn Model>>>>,
    feature_extractor: Arc<dyn FeatureExtractor>,
}

impl InferenceEngine {
    pub fn new(feature_extractor: Arc<dyn FeatureExtractor>) -> Self {
        Self {
            models: Arc::new(RwLock::new(HashMap::new())),
            feature_extractor,
        }
    }
    
    /// 注册模型
    pub async fn register_model(&self, model_id: String, model: Box<dyn Model>) {
        let mut models = self.models.write().await;
        models.insert(model_id, model);
    }
    
    /// 执行推理
    pub async fn predict(&self, model_id: &str, data: &serde_json::Value) -> Result<Prediction, Box<dyn std::error::Error>> {
        // 提取特征
        let features = self.feature_extractor.extract_features(data)?;
        
        // 获取模型
        let models = self.models.read().await;
        let model = models.get(model_id)
            .ok_or("Model not found")?;
        
        // 执行预测
        let prediction = model.predict(&features).await?;
        
        Ok(prediction)
    }
    
    /// 获取模型列表
    pub async fn list_models(&self) -> Vec<ModelMetadata> {
        let models = self.models.read().await;
        models.values().map(|model| model.get_metadata().clone()).collect()
    }
}
```

### 3.2 推理API

```rust
use axum::{
    routing::{get, post},
    http::StatusCode,
    response::Json,
    extract::State,
    Router,
};
use serde::{Deserialize, Serialize};

/// 推理请求
#[derive(Debug, Deserialize)]
pub struct InferenceRequest {
    pub data: serde_json::Value,
    pub model_id: Option<String>,
}

/// 推理响应
#[derive(Debug, Serialize)]
pub struct InferenceResponse {
    pub prediction: Prediction,
    pub model_id: String,
    pub inference_time_ms: u64,
}

/// 推理API服务
pub struct InferenceApiService {
    inference_engine: Arc<InferenceEngine>,
}

impl InferenceApiService {
    pub fn new(inference_engine: Arc<InferenceEngine>) -> Self {
        Self { inference_engine }
    }
    
    /// 创建API路由
    pub fn create_routes(self: Arc<Self>) -> Router {
        Router::new()
            .route("/predict", post(self.clone().predict))
            .route("/models", get(self.clone().list_models))
            .with_state(self)
    }
    
    /// 预测
    async fn predict(
        self: Arc<Self>,
        State(service): State<Arc<Self>>,
        Json(request): Json<InferenceRequest>,
    ) -> Result<Json<InferenceResponse>, StatusCode> {
        let start_time = std::time::Instant::now();
        
        let model_id = request.model_id.unwrap_or_else(|| "default".to_string());
        
        let prediction = service.inference_engine.predict(&model_id, &request.data).await
            .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
        
        let inference_time = start_time.elapsed().as_millis() as u64;
        
        Ok(Json(InferenceResponse {
            prediction,
            model_id,
            inference_time_ms: inference_time,
        }))
    }
    
    /// 列出模型
    async fn list_models(
        self: Arc<Self>,
        State(service): State<Arc<Self>>,
    ) -> Result<Json<Vec<ModelMetadata>>, StatusCode> {
        let models = service.inference_engine.list_models().await;
        Ok(Json(models))
    }
}

impl Clone for InferenceApiService {
    fn clone(&self) -> Self {
        Self {
            inference_engine: self.inference_engine.clone(),
        }
    }
}
```

## 4. 应用示例

### 4.1 机器学习集成示例

```rust
use std::sync::Arc;

async fn machine_learning_integration_example() -> Result<(), Box<dyn std::error::Error>> {
    // 创建特征提取器
    let feature_extractor = Arc::new(IoTSensorFeatureExtractor::new());
    
    // 创建推理引擎
    let inference_engine = Arc::new(InferenceEngine::new(feature_extractor.clone()));
    
    // 创建训练数据
    let training_data = create_training_data().await?;
    
    // 训练线性回归模型
    let mut model = LinearRegressionModel::new();
    let metadata = model.train(&training_data).await?;
    
    println!("Model trained successfully:");
    println!("  Model ID: {}", metadata.model_id);
    println!("  R² Score: {:.4}", metadata.metrics.get("r2_score").unwrap_or(&0.0));
    println!("  MSE: {:.4}", metadata.metrics.get("mse").unwrap_or(&0.0));
    
    // 注册模型到推理引擎
    inference_engine.register_model(metadata.model_id.clone(), Box::new(model)).await;
    
    // 创建推理API服务
    let api_service = Arc::new(InferenceApiService::new(inference_engine.clone()));
    
    // 创建API路由
    let app = api_service.create_routes();
    
    // 启动服务器
    let addr = std::net::SocketAddr::from(([127, 0, 0, 1], 3000));
    println!("ML Inference API server starting on {}", addr);
    
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await?;
    
    Ok(())
}

/// 创建训练数据
async fn create_training_data() -> Result<Vec<TrainingExample>, Box<dyn std::error::Error>> {
    let mut training_data = Vec::new();
    
    // 生成模拟传感器数据
    for i in 0..1000 {
        let timestamp = Utc::now() + chrono::Duration::minutes(i as i64);
        
        // 模拟温度和湿度的关系
        let temperature = 20.0 + 10.0 * (i as f64 / 100.0).sin() + rand::random::<f64>() * 2.0;
        let humidity = 50.0 - 0.5 * temperature + rand::random::<f64>() * 5.0;
        
        // 创建传感器数据
        let sensor_data = serde_json::json!({
            "device_id": "sensor_001",
            "timestamp": timestamp.to_rfc3339(),
            "value": temperature,
            "sensor_type": "temperature"
        });
        
        // 提取特征
        let features = feature_extractor.extract_features(&sensor_data)?;
        
        // 创建训练样本（预测湿度）
        training_data.push(TrainingExample {
            features,
            target: humidity,
        });
    }
    
    Ok(training_data)
}

/// 模型训练示例
async fn model_training_example() -> Result<(), Box<dyn std::error::Error>> {
    // 创建特征提取器
    let feature_extractor = IoTSensorFeatureExtractor::new();
    
    // 创建训练数据
    let training_data = create_training_data().await?;
    
    // 分割训练和测试数据
    let split_index = (training_data.len() * 8) / 10;
    let (train_data, test_data) = training_data.split_at(split_index);
    
    // 训练模型
    let mut model = LinearRegressionModel::new();
    let metadata = model.train(train_data).await?;
    
    println!("Training completed:");
    println!("  Model ID: {}", metadata.model_id);
    println!("  Training samples: {}", train_data.len());
    println!("  Test samples: {}", test_data.len());
    
    // 保存模型
    model.save("models/linear_regression_model.json").await?;
    println!("Model saved to models/linear_regression_model.json");
    
    Ok(())
}

/// 模型推理示例
async fn model_inference_example() -> Result<(), Box<dyn std::error::Error>> {
    // 加载模型
    let model = LinearRegressionModel::load("models/linear_regression_model.json").await?;
    
    // 创建推理引擎
    let feature_extractor = Arc::new(IoTSensorFeatureExtractor::new());
    let inference_engine = Arc::new(InferenceEngine::new(feature_extractor));
    
    // 注册模型
    let model_id = model.get_metadata().model_id.clone();
    inference_engine.register_model(model_id.clone(), Box::new(model)).await;
    
    // 创建测试数据
    let test_data = serde_json::json!({
        "device_id": "sensor_001",
        "timestamp": Utc::now().to_rfc3339(),
        "value": 25.5,
        "sensor_type": "temperature"
    });
    
    // 执行推理
    let prediction = inference_engine.predict(&model_id, &test_data).await?;
    
    println!("Inference result:");
    println!("  Predicted humidity: {:.2}%", prediction.value);
    println!("  Confidence: {:.2}", prediction.confidence);
    
    Ok(())
}
```

## 5. 总结

本实现提供了完整的机器学习集成组件：

1. **特征工程** - 特征提取和变换
2. **模型训练** - 线性回归模型实现
3. **推理服务** - 推理引擎和API服务
4. **实际应用示例** - 完整的ML集成演示

这个机器学习集成实现为IoT平台提供了智能化的数据分析和预测能力。
