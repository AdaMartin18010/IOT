# 缓存系统实现

## 1. 缓存核心架构

### 1.1 缓存接口和基础结构

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use std::time::{Duration, Instant};

/// 缓存项
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CacheItem<T> {
    pub key: String,
    pub value: T,
    pub created_at: DateTime<Utc>,
    pub expires_at: Option<DateTime<Utc>>,
    pub access_count: u64,
    pub last_accessed: DateTime<Utc>,
    pub tags: Vec<String>,
}

/// 缓存策略
#[derive(Debug, Clone)]
pub enum EvictionPolicy {
    LRU,    // 最近最少使用
    LFU,    // 最少使用频率
    FIFO,   // 先进先出
    TTL,    // 基于过期时间
}

/// 缓存统计
#[derive(Debug, Clone)]
pub struct CacheStats {
    pub hits: u64,
    pub misses: u64,
    pub evictions: u64,
    pub size: usize,
    pub max_size: usize,
}

/// 缓存接口
#[async_trait::async_trait]
pub trait Cache: Send + Sync {
    type Value: Clone + Send + Sync + 'static;
    
    async fn get(&self, key: &str) -> Result<Option<Self::Value>, Box<dyn std::error::Error>>;
    async fn set(&self, key: &str, value: Self::Value, ttl: Option<Duration>) -> Result<(), Box<dyn std::error::Error>>;
    async fn delete(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>>;
    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>>;
    async fn clear(&self) -> Result<(), Box<dyn std::error::Error>>;
    async fn get_stats(&self) -> Result<CacheStats, Box<dyn std::error::Error>>;
}
```

### 1.2 内存缓存实现

```rust
/// 内存缓存
pub struct MemoryCache<T> {
    data: Arc<RwLock<HashMap<String, CacheItem<T>>>>,
    max_size: usize,
    eviction_policy: EvictionPolicy,
    stats: Arc<RwLock<CacheStats>>,
}

impl<T> MemoryCache<T>
where
    T: Clone + Send + Sync + 'static,
{
    pub fn new(max_size: usize, eviction_policy: EvictionPolicy) -> Self {
        Self {
            data: Arc::new(RwLock::new(HashMap::new())),
            max_size,
            eviction_policy,
            stats: Arc::new(RwLock::new(CacheStats {
                hits: 0,
                misses: 0,
                evictions: 0,
                size: 0,
                max_size,
            })),
        }
    }

    /// 清理过期项
    async fn cleanup_expired(&self) {
        let mut data = self.data.write().await;
        let now = Utc::now();
        
        let expired_keys: Vec<String> = data.iter()
            .filter(|(_, item)| {
                if let Some(expires_at) = item.expires_at {
                    now > expires_at
                } else {
                    false
                }
            })
            .map(|(key, _)| key.clone())
            .collect();
        
        for key in expired_keys {
            data.remove(&key);
        }
    }

    /// 执行淘汰策略
    async fn evict_if_needed(&self) {
        let mut data = self.data.write().await;
        
        if data.len() <= self.max_size {
            return;
        }
        
        let keys_to_remove = match self.eviction_policy {
            EvictionPolicy::LRU => {
                let mut items: Vec<_> = data.iter().collect();
                items.sort_by(|a, b| a.1.last_accessed.cmp(&b.1.last_accessed));
                items.into_iter().take(data.len() - self.max_size).map(|(k, _)| k.clone()).collect()
            }
            EvictionPolicy::LFU => {
                let mut items: Vec<_> = data.iter().collect();
                items.sort_by(|a, b| a.1.access_count.cmp(&b.1.access_count));
                items.into_iter().take(data.len() - self.max_size).map(|(k, _)| k.clone()).collect()
            }
            EvictionPolicy::FIFO => {
                let mut items: Vec<_> = data.iter().collect();
                items.sort_by(|a, b| a.1.created_at.cmp(&b.1.created_at));
                items.into_iter().take(data.len() - self.max_size).map(|(k, _)| k.clone()).collect()
            }
            EvictionPolicy::TTL => {
                let mut items: Vec<_> = data.iter().collect();
                items.sort_by(|a, b| {
                    let a_expiry = a.1.expires_at.unwrap_or(DateTime::MAX);
                    let b_expiry = b.1.expires_at.unwrap_or(DateTime::MAX);
                    a_expiry.cmp(&b_expiry)
                });
                items.into_iter().take(data.len() - self.max_size).map(|(k, _)| k.clone()).collect()
            }
        };
        
        for key in keys_to_remove {
            data.remove(&key);
        }
        
        // 更新统计
        let mut stats = self.stats.write().await;
        stats.evictions += keys_to_remove.len() as u64;
        stats.size = data.len();
    }
}

#[async_trait::async_trait]
impl<T> Cache for MemoryCache<T>
where
    T: Clone + Send + Sync + 'static,
{
    type Value = T;

    async fn get(&self, key: &str) -> Result<Option<Self::Value>, Box<dyn std::error::Error>> {
        self.cleanup_expired().await;
        
        let mut data = self.data.write().await;
        let mut stats = self.stats.write().await;
        
        if let Some(item) = data.get_mut(key) {
            // 检查是否过期
            if let Some(expires_at) = item.expires_at {
                if Utc::now() > expires_at {
                    data.remove(key);
                    stats.misses += 1;
                    stats.size = data.len();
                    return Ok(None);
                }
            }
            
            // 更新访问统计
            item.access_count += 1;
            item.last_accessed = Utc::now();
            stats.hits += 1;
            
            Ok(Some(item.value.clone()))
        } else {
            stats.misses += 1;
            Ok(None)
        }
    }

    async fn set(&self, key: &str, value: Self::Value, ttl: Option<Duration>) -> Result<(), Box<dyn std::error::Error>> {
        let expires_at = ttl.map(|duration| Utc::now() + chrono::Duration::from_std(duration).unwrap());
        
        let item = CacheItem {
            key: key.to_string(),
            value,
            created_at: Utc::now(),
            expires_at,
            access_count: 0,
            last_accessed: Utc::now(),
            tags: Vec::new(),
        };
        
        let mut data = self.data.write().await;
        data.insert(key.to_string(), item);
        
        // 检查是否需要淘汰
        if data.len() > self.max_size {
            drop(data);
            self.evict_if_needed().await;
        } else {
            let mut stats = self.stats.write().await;
            stats.size = data.len();
        }
        
        Ok(())
    }

    async fn delete(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let mut data = self.data.write().await;
        let removed = data.remove(key).is_some();
        
        let mut stats = self.stats.write().await;
        stats.size = data.len();
        
        Ok(removed)
    }

    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>> {
        self.cleanup_expired().await;
        
        let data = self.data.read().await;
        Ok(data.contains_key(key))
    }

    async fn clear(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut data = self.data.write().await;
        data.clear();
        
        let mut stats = self.stats.write().await;
        stats.size = 0;
        
        Ok(())
    }

    async fn get_stats(&self) -> Result<CacheStats, Box<dyn std::error::Error>> {
        let stats = self.stats.read().await;
        Ok(stats.clone())
    }
}
```

## 2. 分布式缓存

### 2.1 Redis缓存实现

```rust
use redis::{Client, Connection, Commands, RedisResult};

/// Redis缓存
pub struct RedisCache {
    client: Client,
    prefix: String,
}

impl RedisCache {
    pub fn new(redis_url: &str, prefix: String) -> Result<Self, Box<dyn std::error::Error>> {
        let client = Client::open(redis_url)?;
        Ok(Self {
            client,
            prefix,
        })
    }

    fn get_key(&self, key: &str) -> String {
        format!("{}:{}", self.prefix, key)
    }

    async fn get_connection(&self) -> Result<Connection, Box<dyn std::error::Error>> {
        self.client.get_connection().map_err(|e| e.into())
    }
}

#[async_trait::async_trait]
impl Cache for RedisCache {
    type Value = String;

    async fn get(&self, key: &str) -> Result<Option<Self::Value>, Box<dyn std::error::Error>> {
        let mut conn = self.get_connection().await?;
        let redis_key = self.get_key(key);
        
        let result: RedisResult<Option<String>> = conn.get(&redis_key);
        match result {
            Ok(value) => Ok(value),
            Err(e) => Err(e.into()),
        }
    }

    async fn set(&self, key: &str, value: Self::Value, ttl: Option<Duration>) -> Result<(), Box<dyn std::error::Error>> {
        let mut conn = self.get_connection().await?;
        let redis_key = self.get_key(key);
        
        match ttl {
            Some(duration) => {
                let ttl_seconds = duration.as_secs() as usize;
                let result: RedisResult<()> = conn.set_ex(&redis_key, value, ttl_seconds);
                result.map_err(|e| e.into())
            }
            None => {
                let result: RedisResult<()> = conn.set(&redis_key, value);
                result.map_err(|e| e.into())
            }
        }
    }

    async fn delete(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let mut conn = self.get_connection().await?;
        let redis_key = self.get_key(key);
        
        let result: RedisResult<i32> = conn.del(&redis_key);
        match result {
            Ok(count) => Ok(count > 0),
            Err(e) => Err(e.into()),
        }
    }

    async fn exists(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let mut conn = self.get_connection().await?;
        let redis_key = self.get_key(key);
        
        let result: RedisResult<bool> = conn.exists(&redis_key);
        result.map_err(|e| e.into())
    }

    async fn clear(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut conn = self.get_connection().await?;
        let pattern = format!("{}:*", self.prefix);
        
        let keys: RedisResult<Vec<String>> = conn.keys(&pattern);
        match keys {
            Ok(keys) => {
                if !keys.is_empty() {
                    let result: RedisResult<()> = conn.del(keys);
                    result.map_err(|e| e.into())
                } else {
                    Ok(())
                }
            }
            Err(e) => Err(e.into()),
        }
    }

    async fn get_stats(&self) -> Result<CacheStats, Box<dyn std::error::Error>> {
        // Redis不提供详细的统计信息，返回基本统计
        Ok(CacheStats {
            hits: 0,
            misses: 0,
            evictions: 0,
            size: 0,
            max_size: 0,
        })
    }
}
```

## 3. 缓存管理器

### 3.1 多级缓存

```rust
/// 缓存级别
#[derive(Debug, Clone)]
pub enum CacheLevel {
    L1, // 内存缓存
    L2, // Redis缓存
}

/// 多级缓存管理器
pub struct MultiLevelCache {
    l1_cache: Arc<MemoryCache<String>>,
    l2_cache: Arc<RedisCache>,
}

impl MultiLevelCache {
    pub fn new(l1_size: usize, redis_url: &str) -> Result<Self, Box<dyn std::error::Error>> {
        let l1_cache = Arc::new(MemoryCache::new(l1_size, EvictionPolicy::LRU));
        let l2_cache = Arc::new(RedisCache::new(redis_url, "iot".to_string())?);
        
        Ok(Self {
            l1_cache,
            l2_cache,
        })
    }

    /// 获取值（先查L1，再查L2）
    pub async fn get(&self, key: &str) -> Result<Option<String>, Box<dyn std::error::Error>> {
        // 先查L1缓存
        if let Some(value) = self.l1_cache.get(key).await? {
            return Ok(Some(value));
        }
        
        // L1未命中，查L2缓存
        if let Some(value) = self.l2_cache.get(key).await? {
            // 回填L1缓存
            self.l1_cache.set(key, value.clone(), Some(Duration::from_secs(300))).await?;
            return Ok(Some(value));
        }
        
        Ok(None)
    }

    /// 设置值（同时写入L1和L2）
    pub async fn set(&self, key: &str, value: String, ttl: Option<Duration>) -> Result<(), Box<dyn std::error::Error>> {
        // 写入L2缓存
        self.l2_cache.set(key, value.clone(), ttl).await?;
        
        // 写入L1缓存（较短的TTL）
        let l1_ttl = ttl.map(|d| std::cmp::min(d, Duration::from_secs(300)));
        self.l1_cache.set(key, value, l1_ttl).await?;
        
        Ok(())
    }

    /// 删除值（同时删除L1和L2）
    pub async fn delete(&self, key: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let l1_deleted = self.l1_cache.delete(key).await?;
        let l2_deleted = self.l2_cache.delete(key).await?;
        
        Ok(l1_deleted || l2_deleted)
    }

    /// 获取缓存统计
    pub async fn get_stats(&self) -> Result<HashMap<String, CacheStats>, Box<dyn std::error::Error>> {
        let mut stats = HashMap::new();
        stats.insert("L1".to_string(), self.l1_cache.get_stats().await?);
        stats.insert("L2".to_string(), self.l2_cache.get_stats().await?);
        
        Ok(stats)
    }
}
```

## 4. 应用示例

### 4.1 IoT系统缓存

```rust
use crate::cache::{MultiLevelCache, MemoryCache, Cache, EvictionPolicy};

async fn iot_caching_system() -> Result<(), Box<dyn std::error::Error>> {
    // 创建多级缓存
    let cache = MultiLevelCache::new(1000, "redis://localhost:6379")?;
    
    // 缓存设备信息
    let device_info = serde_json::json!({
        "id": "sensor-001",
        "type": "temperature",
        "location": "building-a",
        "status": "online",
        "last_seen": Utc::now().to_rfc3339()
    });
    
    cache.set("device:sensor-001", device_info.to_string(), Some(Duration::from_secs(3600))).await?;
    
    // 缓存传感器数据
    let sensor_data = serde_json::json!({
        "temperature": 25.5,
        "humidity": 60.0,
        "timestamp": Utc::now().to_rfc3339()
    });
    
    cache.set("data:sensor-001", sensor_data.to_string(), Some(Duration::from_secs(300))).await?;
    
    // 缓存用户会话
    let session_data = serde_json::json!({
        "user_id": "user-123",
        "permissions": ["read", "write"],
        "expires_at": (Utc::now() + chrono::Duration::hours(1)).to_rfc3339()
    });
    
    cache.set("session:user-123", session_data.to_string(), Some(Duration::from_secs(3600))).await?;
    
    // 读取缓存数据
    if let Some(device_info) = cache.get("device:sensor-001").await? {
        println!("Device info: {}", device_info);
    }
    
    if let Some(sensor_data) = cache.get("data:sensor-001").await? {
        println!("Sensor data: {}", sensor_data);
    }
    
    // 创建内存缓存用于临时数据
    let temp_cache = MemoryCache::new(100, EvictionPolicy::LRU);
    
    // 缓存计算结果
    temp_cache.set("calc:avg_temp", "23.5".to_string(), Some(Duration::from_secs(60))).await?;
    temp_cache.set("calc:device_count", "42".to_string(), Some(Duration::from_secs(300))).await?;
    
    // 读取临时缓存
    if let Some(avg_temp) = temp_cache.get("calc:avg_temp").await? {
        println!("Average temperature: {}", avg_temp);
    }
    
    // 获取缓存统计
    let stats = cache.get_stats().await?;
    for (level, stat) in stats {
        println!("{} Cache - Hits: {}, Misses: {}, Size: {}", 
                level, stat.hits, stat.misses, stat.size);
    }
    
    // 模拟缓存命中
    for _ in 0..100 {
        cache.get("device:sensor-001").await?;
    }
    
    // 再次获取统计
    let updated_stats = cache.get_stats().await?;
    for (level, stat) in updated_stats {
        println!("Updated {} Cache - Hits: {}, Misses: {}, Size: {}", 
                level, stat.hits, stat.misses, stat.size);
    }
    
    Ok(())
}
```

## 5. 总结

本实现提供了：

1. **内存缓存** - 高性能本地缓存，支持多种淘汰策略
2. **Redis缓存** - 分布式缓存，支持持久化
3. **多级缓存** - L1+L2缓存架构，提高性能
4. **缓存统计** - 命中率、淘汰次数等统计信息
5. **TTL支持** - 自动过期机制
6. **实际应用示例** - IoT系统缓存管理

这个缓存系统为IoT平台提供了高性能的数据缓存能力，支持本地和分布式缓存场景。
