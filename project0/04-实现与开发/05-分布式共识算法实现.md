# 分布式共识算法实现

## 1. Raft共识算法实现

### 1.1 Rust实现

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};
use tokio::sync::{mpsc, RwLock};
use serde::{Deserialize, Serialize};

/// Raft节点状态
#[derive(Debug, Clone, PartialEq)]
pub enum RaftState {
    Follower,
    Candidate,
    Leader,
}

/// Raft日志条目
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogEntry {
    pub term: u64,
    pub index: u64,
    pub command: String,
    pub data: Vec<u8>,
}

/// Raft节点配置
#[derive(Debug, Clone)]
pub struct RaftConfig {
    pub id: String,
    pub peers: Vec<String>,
    pub election_timeout_min: Duration,
    pub election_timeout_max: Duration,
    pub heartbeat_interval: Duration,
}

/// Raft节点
pub struct RaftNode {
    config: RaftConfig,
    state: RwLock<RaftState>,
    current_term: RwLock<u64>,
    voted_for: RwLock<Option<String>>,
    log: RwLock<Vec<LogEntry>>,
    commit_index: RwLock<u64>,
    last_applied: RwLock<u64>,
    next_index: RwLock<HashMap<String, u64>>,
    match_index: RwLock<HashMap<String, u64>>,
    last_heartbeat: RwLock<Instant>,
    election_timer: RwLock<Instant>,
}

impl RaftNode {
    pub fn new(config: RaftConfig) -> Self {
        let now = Instant::now();
        Self {
            config,
            state: RwLock::new(RaftState::Follower),
            current_term: RwLock::new(0),
            voted_for: RwLock::new(None),
            log: RwLock::new(vec![LogEntry {
                term: 0,
                index: 0,
                command: "init".to_string(),
                data: vec![],
            }]),
            commit_index: RwLock::new(0),
            last_applied: RwLock::new(0),
            next_index: RwLock::new(HashMap::new()),
            match_index: RwLock::new(HashMap::new()),
            last_heartbeat: RwLock::new(now),
            election_timer: RwLock::new(now),
        }
    }

    /// 启动Raft节点
    pub async fn start(&self) -> Result<(), Box<dyn std::error::Error>> {
        let (tx, mut rx) = mpsc::channel(100);
        
        // 启动选举定时器
        let election_timer = self.election_timer.clone();
        let config = self.config.clone();
        tokio::spawn(async move {
            loop {
                let timeout = rand::thread_rng().gen_range(
                    config.election_timeout_min.as_millis()..=config.election_timeout_max.as_millis()
                );
                tokio::time::sleep(Duration::from_millis(timeout as u64)).await;
                
                if let Err(_) = tx.send(()).await {
                    break;
                }
            }
        });

        // 主事件循环
        loop {
            tokio::select! {
                _ = rx.recv() => {
                    self.handle_election_timeout().await?;
                }
                // 处理其他事件...
            }
        }
    }

    /// 处理选举超时
    async fn handle_election_timeout(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut state = self.state.write().await;
        let mut current_term = self.current_term.write().await;
        
        match *state {
            RaftState::Follower => {
                // 转换为候选人
                *state = RaftState::Candidate;
                *current_term += 1;
                self.start_election().await?;
            }
            RaftState::Candidate => {
                // 重新开始选举
                *current_term += 1;
                self.start_election().await?;
            }
            RaftState::Leader => {
                // 领导者不需要处理选举超时
            }
        }
        Ok(())
    }

    /// 开始选举
    async fn start_election(&self) -> Result<(), Box<dyn std::error::Error>> {
        let current_term = *self.current_term.read().await;
        let mut voted_for = self.voted_for.write().await;
        
        // 投票给自己
        *voted_for = Some(self.config.id.clone());
        
        // 发送投票请求给其他节点
        let mut votes_received = 1;
        let mut votes = Vec::new();
        
        for peer in &self.config.peers {
            if peer != &self.config.id {
                if let Ok(vote) = self.request_vote(peer, current_term).await {
                    votes.push(vote);
                    if vote {
                        votes_received += 1;
                    }
                }
            }
        }
        
        // 检查是否获得多数票
        if votes_received > self.config.peers.len() / 2 {
            self.become_leader().await?;
        }
        
        Ok(())
    }

    /// 请求投票
    async fn request_vote(&self, peer: &str, term: u64) -> Result<bool, Box<dyn std::error::Error>> {
        // 实现RPC调用
        // 这里简化实现，实际应该使用网络通信
        Ok(true)
    }

    /// 成为领导者
    async fn become_leader(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut state = self.state.write().await;
        *state = RaftState::Leader;
        
        // 初始化领导者状态
        let mut next_index = self.next_index.write().await;
        let mut match_index = self.match_index.write().await;
        let log = self.log.read().await;
        
        for peer in &self.config.peers {
            if peer != &self.config.id {
                next_index.insert(peer.clone(), log.len() as u64);
                match_index.insert(peer.clone(), 0);
            }
        }
        
        // 开始发送心跳
        self.start_heartbeat().await?;
        
        Ok(())
    }

    /// 开始发送心跳
    async fn start_heartbeat(&self) -> Result<(), Box<dyn std::error::Error>> {
        let config = self.config.clone();
        let heartbeat_interval = config.election_timeout_min / 10;
        
        tokio::spawn(async move {
            loop {
                tokio::time::sleep(heartbeat_interval).await;
                
                for peer in &config.peers {
                    if peer != &config.id {
                        // 发送心跳
                        if let Err(e) = Self::send_heartbeat(peer).await {
                            eprintln!("Failed to send heartbeat to {}: {}", peer, e);
                        }
                    }
                }
            }
        });
        
        Ok(())
    }

    /// 发送心跳
    async fn send_heartbeat(peer: &str) -> Result<(), Box<dyn std::error::Error>> {
        // 实现心跳RPC
        Ok(())
    }

    /// 提交日志条目
    pub async fn append_entries(&self, command: String, data: Vec<u8>) -> Result<u64, Box<dyn std::error::Error>> {
        let state = self.state.read().await;
        if *state != RaftState::Leader {
            return Err("Not leader".into());
        }
        
        let mut log = self.log.write().await;
        let current_term = *self.current_term.read().await;
        
        let entry = LogEntry {
            term: current_term,
            index: log.len() as u64,
            command,
            data,
        };
        
        log.push(entry);
        let index = log.len() as u64 - 1;
        
        // 复制到其他节点
        self.replicate_log(index).await?;
        
        Ok(index)
    }

    /// 复制日志到其他节点
    async fn replicate_log(&self, index: u64) -> Result<(), Box<dyn std::error::Error>> {
        let log = self.log.read().await;
        let entry = &log[index as usize];
        
        for peer in &self.config.peers {
            if peer != &self.config.id {
                if let Err(e) = self.send_append_entries(peer, entry).await {
                    eprintln!("Failed to replicate log to {}: {}", peer, e);
                }
            }
        }
        
        Ok(())
    }

    /// 发送追加条目请求
    async fn send_append_entries(&self, peer: &str, entry: &LogEntry) -> Result<(), Box<dyn std::error::Error>> {
        // 实现追加条目RPC
        Ok(())
    }
}
```

### 1.2 Go实现

```go
package raft

import (
    "context"
    "fmt"
    "log"
    "math/rand"
    "sync"
    "time"
)

// RaftState 节点状态
type RaftState int

const (
    Follower RaftState = iota
    Candidate
    Leader
)

// LogEntry 日志条目
type LogEntry struct {
    Term    uint64 `json:"term"`
    Index   uint64 `json:"index"`
    Command string `json:"command"`
    Data    []byte `json:"data"`
}

// RaftConfig 配置
type RaftConfig struct {
    ID                   string
    Peers                []string
    ElectionTimeoutMin   time.Duration
    ElectionTimeoutMax   time.Duration
    HeartbeatInterval    time.Duration
}

// RaftNode Raft节点
type RaftNode struct {
    config         *RaftConfig
    state          RaftState
    currentTerm    uint64
    votedFor       *string
    log            []LogEntry
    commitIndex    uint64
    lastApplied    uint64
    nextIndex      map[string]uint64
    matchIndex     map[string]uint64
    lastHeartbeat  time.Time
    electionTimer  time.Time
    
    mu             sync.RWMutex
    stopCh         chan struct{}
}

// NewRaftNode 创建新的Raft节点
func NewRaftNode(config *RaftConfig) *RaftNode {
    now := time.Now()
    return &RaftNode{
        config:        config,
        state:         Follower,
        currentTerm:   0,
        votedFor:      nil,
        log:           []LogEntry{{Term: 0, Index: 0, Command: "init"}},
        commitIndex:   0,
        lastApplied:   0,
        nextIndex:     make(map[string]uint64),
        matchIndex:    make(map[string]uint64),
        lastHeartbeat: now,
        electionTimer: now,
        stopCh:        make(chan struct{}),
    }
}

// Start 启动节点
func (n *RaftNode) Start(ctx context.Context) error {
    // 启动选举定时器
    go n.runElectionTimer(ctx)
    
    // 启动心跳定时器
    go n.runHeartbeatTimer(ctx)
    
    // 主事件循环
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        case <-n.stopCh:
            return nil
        }
    }
}

// runElectionTimer 运行选举定时器
func (n *RaftNode) runElectionTimer(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            return
        case <-n.stopCh:
            return
        default:
            timeout := n.getElectionTimeout()
            timer := time.NewTimer(timeout)
            
            select {
            case <-timer.C:
                n.handleElectionTimeout()
            case <-ctx.Done():
                timer.Stop()
                return
            case <-n.stopCh:
                timer.Stop()
                return
            }
        }
    }
}

// getElectionTimeout 获取选举超时时间
func (n *RaftNode) getElectionTimeout() time.Duration {
    min := n.config.ElectionTimeoutMin.Milliseconds()
    max := n.config.ElectionTimeoutMax.Milliseconds()
    timeout := rand.Int63n(max-min) + min
    return time.Duration(timeout) * time.Millisecond
}

// handleElectionTimeout 处理选举超时
func (n *RaftNode) handleElectionTimeout() {
    n.mu.Lock()
    defer n.mu.Unlock()
    
    switch n.state {
    case Follower:
        n.state = Candidate
        n.currentTerm++
        n.startElection()
    case Candidate:
        n.currentTerm++
        n.startElection()
    case Leader:
        // 领导者不需要处理选举超时
    }
}

// startElection 开始选举
func (n *RaftNode) startElection() {
    n.votedFor = &n.config.ID
    votesReceived := 1
    
    // 发送投票请求
    for _, peer := range n.config.Peers {
        if peer != n.config.ID {
            go func(peerID string) {
                if n.requestVote(peerID) {
                    n.mu.Lock()
                    defer n.mu.Unlock()
                    votesReceived++
                    
                    if votesReceived > len(n.config.Peers)/2 {
                        n.becomeLeader()
                    }
                }
            }(peer)
        }
    }
}

// requestVote 请求投票
func (n *RaftNode) requestVote(peer string) bool {
    // 实现RPC调用
    // 这里简化实现
    return true
}

// becomeLeader 成为领导者
func (n *RaftNode) becomeLeader() {
    n.state = Leader
    
    // 初始化领导者状态
    for _, peer := range n.config.Peers {
        if peer != n.config.ID {
            n.nextIndex[peer] = uint64(len(n.log))
            n.matchIndex[peer] = 0
        }
    }
    
    log.Printf("Node %s became leader for term %d", n.config.ID, n.currentTerm)
}

// runHeartbeatTimer 运行心跳定时器
func (n *RaftNode) runHeartbeatTimer(ctx context.Context) {
    ticker := time.NewTicker(n.config.HeartbeatInterval)
    defer ticker.Stop()
    
    for {
        select {
        case <-ticker.C:
            n.sendHeartbeats()
        case <-ctx.Done():
            return
        case <-n.stopCh:
            return
        }
    }
}

// sendHeartbeats 发送心跳
func (n *RaftNode) sendHeartbeats() {
    n.mu.RLock()
    if n.state != Leader {
        n.mu.RUnlock()
        return
    }
    n.mu.RUnlock()
    
    for _, peer := range n.config.Peers {
        if peer != n.config.ID {
            go func(peerID string) {
                if err := n.sendHeartbeat(peerID); err != nil {
                    log.Printf("Failed to send heartbeat to %s: %v", peerID, err)
                }
            }(peer)
        }
    }
}

// sendHeartbeat 发送心跳
func (n *RaftNode) sendHeartbeat(peer string) error {
    // 实现心跳RPC
    return nil
}

// AppendEntries 追加日志条目
func (n *RaftNode) AppendEntries(command string, data []byte) (uint64, error) {
    n.mu.Lock()
    defer n.mu.Unlock()
    
    if n.state != Leader {
        return 0, fmt.Errorf("not leader")
    }
    
    entry := LogEntry{
        Term:    n.currentTerm,
        Index:   uint64(len(n.log)),
        Command: command,
        Data:    data,
    }
    
    n.log = append(n.log, entry)
    index := uint64(len(n.log) - 1)
    
    // 复制到其他节点
    go n.replicateLog(index)
    
    return index, nil
}

// replicateLog 复制日志
func (n *RaftNode) replicateLog(index uint64) {
    entry := n.log[index]
    
    for _, peer := range n.config.Peers {
        if peer != n.config.ID {
            go func(peerID string) {
                if err := n.sendAppendEntries(peerID, &entry); err != nil {
                    log.Printf("Failed to replicate log to %s: %v", peerID, err)
                }
            }(peer)
        }
    }
}

// sendAppendEntries 发送追加条目请求
func (n *RaftNode) sendAppendEntries(peer string, entry *LogEntry) error {
    // 实现追加条目RPC
    return nil
}

// Stop 停止节点
func (n *RaftNode) Stop() {
    close(n.stopCh)
}
```

## 2. PBFT共识算法实现

### 2.1 Rust实现

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use tokio::sync::RwLock;

/// PBFT消息类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PBFTMessage {
    Request {
        client_id: String,
        timestamp: u64,
        operation: String,
    },
    PrePrepare {
        view: u64,
        sequence: u64,
        digest: String,
        request: PBFTMessage,
    },
    Prepare {
        view: u64,
        sequence: u64,
        digest: String,
        node_id: String,
    },
    Commit {
        view: u64,
        sequence: u64,
        digest: String,
        node_id: String,
    },
    Reply {
        view: u64,
        timestamp: u64,
        client_id: String,
        node_id: String,
        result: String,
    },
}

/// PBFT节点状态
#[derive(Debug, Clone)]
pub struct PBFTState {
    pub view: u64,
    pub sequence: u64,
    pub primary: String,
    pub nodes: Vec<String>,
    pub checkpoint_interval: u64,
}

/// PBFT节点
pub struct PBFTNode {
    id: String,
    state: RwLock<PBFTState>,
    requests: RwLock<HashMap<String, PBFTMessage>>,
    prepares: RwLock<HashMap<String, Vec<String>>>,
    commits: RwLock<HashMap<String, Vec<String>>>,
    executed: RwLock<Vec<String>>,
}

impl PBFTNode {
    pub fn new(id: String, nodes: Vec<String>) -> Self {
        let primary = nodes[0].clone();
        let state = PBFTState {
            view: 0,
            sequence: 0,
            primary,
            nodes,
            checkpoint_interval: 100,
        };
        
        Self {
            id,
            state: RwLock::new(state),
            requests: RwLock::new(HashMap::new()),
            prepares: RwLock::new(HashMap::new()),
            commits: RwLock::new(HashMap::new()),
            executed: RwLock::new(Vec::new()),
        }
    }

    /// 处理客户端请求
    pub async fn handle_request(&self, message: PBFTMessage) -> Result<(), Box<dyn std::error::Error>> {
        let state = self.state.read().await;
        
        if self.id == state.primary {
            // 主节点创建PrePrepare消息
            self.create_pre_prepare(message).await?;
        } else {
            // 非主节点转发给主节点
            self.forward_to_primary(message).await?;
        }
        
        Ok(())
    }

    /// 创建PrePrepare消息
    async fn create_pre_prepare(&self, request: PBFTMessage) -> Result<(), Box<dyn std::error::Error>> {
        let mut state = self.state.write().await;
        state.sequence += 1;
        
        let digest = self.compute_digest(&request);
        let pre_prepare = PBFTMessage::PrePrepare {
            view: state.view,
            sequence: state.sequence,
            digest: digest.clone(),
            request,
        };
        
        // 广播PrePrepare消息
        self.broadcast(pre_prepare).await?;
        
        // 自己处理PrePrepare
        self.handle_pre_prepare(&digest).await?;
        
        Ok(())
    }

    /// 处理PrePrepare消息
    async fn handle_pre_prepare(&self, digest: &str) -> Result<(), Box<dyn std::error::Error>> {
        // 验证消息
        if !self.verify_pre_prepare(digest).await? {
            return Err("Invalid PrePrepare message".into());
        }
        
        // 创建Prepare消息
        let state = self.state.read().await;
        let prepare = PBFTMessage::Prepare {
            view: state.view,
            sequence: state.sequence,
            digest: digest.to_string(),
            node_id: self.id.clone(),
        };
        
        // 广播Prepare消息
        self.broadcast(prepare).await?;
        
        // 自己处理Prepare
        self.handle_prepare(digest).await?;
        
        Ok(())
    }

    /// 处理Prepare消息
    async fn handle_prepare(&self, digest: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut prepares = self.prepares.write().await;
        let state = self.state.read().await;
        
        // 收集Prepare消息
        if !prepares.contains_key(digest) {
            prepares.insert(digest.to_string(), Vec::new());
        }
        
        let prepare_list = prepares.get_mut(digest).unwrap();
        prepare_list.push(self.id.clone());
        
        // 检查是否达到2f+1个Prepare
        if prepare_list.len() >= (2 * self.get_faulty_nodes() + 1) {
            // 创建Commit消息
            let commit = PBFTMessage::Commit {
                view: state.view,
                sequence: state.sequence,
                digest: digest.to_string(),
                node_id: self.id.clone(),
            };
            
            // 广播Commit消息
            self.broadcast(commit).await?;
            
            // 自己处理Commit
            self.handle_commit(digest).await?;
        }
        
        Ok(())
    }

    /// 处理Commit消息
    async fn handle_commit(&self, digest: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut commits = self.commits.write().await;
        
        // 收集Commit消息
        if !commits.contains_key(digest) {
            commits.insert(digest.to_string(), Vec::new());
        }
        
        let commit_list = commits.get_mut(digest).unwrap();
        commit_list.push(self.id.clone());
        
        // 检查是否达到2f+1个Commit
        if commit_list.len() >= (2 * self.get_faulty_nodes() + 1) {
            // 执行请求
            self.execute_request(digest).await?;
        }
        
        Ok(())
    }

    /// 执行请求
    async fn execute_request(&self, digest: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut executed = self.executed.write().await;
        
        if executed.contains(&digest.to_string()) {
            return Ok(());
        }
        
        // 执行操作
        let requests = self.requests.read().await;
        if let Some(request) = requests.get(digest) {
            match request {
                PBFTMessage::Request { client_id, operation, .. } => {
                    let result = self.execute_operation(operation).await?;
                    
                    // 发送Reply给客户端
                    let reply = PBFTMessage::Reply {
                        view: self.state.read().await.view,
                        timestamp: chrono::Utc::now().timestamp() as u64,
                        client_id: client_id.clone(),
                        node_id: self.id.clone(),
                        result,
                    };
                    
                    self.send_reply(reply).await?;
                }
                _ => return Err("Invalid request type".into()),
            }
        }
        
        executed.push(digest.to_string());
        Ok(())
    }

    /// 执行操作
    async fn execute_operation(&self, operation: &str) -> Result<String, Box<dyn std::error::Error>> {
        // 实现具体的操作执行逻辑
        Ok(format!("Executed: {}", operation))
    }

    /// 计算消息摘要
    fn compute_digest(&self, message: &PBFTMessage) -> String {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(format!("{:?}", message).as_bytes());
        format!("{:x}", hasher.finalize())
    }

    /// 获取故障节点数量
    fn get_faulty_nodes(&self) -> usize {
        let state = self.state.blocking_read();
        (state.nodes.len() - 1) / 3
    }

    /// 广播消息
    async fn broadcast(&self, message: PBFTMessage) -> Result<(), Box<dyn std::error::Error>> {
        // 实现网络广播
        Ok(())
    }

    /// 转发给主节点
    async fn forward_to_primary(&self, message: PBFTMessage) -> Result<(), Box<dyn std::error::Error>> {
        // 实现转发逻辑
        Ok(())
    }

    /// 验证PrePrepare消息
    async fn verify_pre_prepare(&self, digest: &str) -> Result<bool, Box<dyn std::error::Error>> {
        // 实现验证逻辑
        Ok(true)
    }

    /// 发送Reply
    async fn send_reply(&self, reply: PBFTMessage) -> Result<(), Box<dyn std::error::Error>> {
        // 实现发送逻辑
        Ok(())
    }
}
```

## 3. PoS共识算法实现

### 3.1 Rust实现

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use sha2::{Sha256, Digest};

/// 权益证明节点
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoSNode {
    pub id: String,
    pub stake: u64,
    pub address: String,
    pub public_key: String,
}

/// PoS区块
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PoSBlock {
    pub height: u64,
    pub timestamp: u64,
    pub previous_hash: String,
    pub validator: String,
    pub transactions: Vec<Transaction>,
    pub signature: String,
    pub hash: String,
}

/// 交易
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Transaction {
    pub from: String,
    pub to: String,
    pub amount: u64,
    pub fee: u64,
    pub signature: String,
}

/// PoS网络
pub struct PoSNetwork {
    nodes: HashMap<String, PoSNode>,
    total_stake: u64,
    current_validator: String,
    block_height: u64,
    difficulty: u64,
}

impl PoSNetwork {
    pub fn new() -> Self {
        Self {
            nodes: HashMap::new(),
            total_stake: 0,
            current_validator: String::new(),
            block_height: 0,
            difficulty: 1000,
        }
    }

    /// 添加节点
    pub fn add_node(&mut self, node: PoSNode) {
        self.total_stake += node.stake;
        self.nodes.insert(node.id.clone(), node);
    }

    /// 选择验证者
    pub fn select_validator(&self) -> Option<String> {
        if self.nodes.is_empty() {
            return None;
        }

        let mut rng = rand::thread_rng();
        let random_stake = rng.gen_range(0..self.total_stake);
        
        let mut cumulative_stake = 0;
        for (id, node) in &self.nodes {
            cumulative_stake += node.stake;
            if cumulative_stake > random_stake {
                return Some(id.clone());
            }
        }
        
        None
    }

    /// 创建新区块
    pub fn create_block(&mut self, transactions: Vec<Transaction>) -> Result<PoSBlock, Box<dyn std::error::Error>> {
        let validator = self.select_validator()
            .ok_or("No validator available")?;
        
        let previous_hash = if self.block_height == 0 {
            "0000000000000000000000000000000000000000000000000000000000000000".to_string()
        } else {
            // 获取前一个区块的哈希
            "previous_block_hash".to_string()
        };
        
        let block = PoSBlock {
            height: self.block_height + 1,
            timestamp: chrono::Utc::now().timestamp() as u64,
            previous_hash,
            validator: validator.clone(),
            transactions,
            signature: String::new(),
            hash: String::new(),
        };
        
        // 计算区块哈希
        let hash = self.compute_block_hash(&block);
        let mut final_block = block;
        final_block.hash = hash;
        
        // 验证者签名
        final_block.signature = self.sign_block(&final_block, &validator)?;
        
        self.block_height += 1;
        self.current_validator = validator;
        
        Ok(final_block)
    }

    /// 计算区块哈希
    fn compute_block_hash(&self, block: &PoSBlock) -> String {
        let mut hasher = Sha256::new();
        hasher.update(format!("{}{}{}{}", 
            block.height, 
            block.timestamp, 
            block.previous_hash, 
            block.validator
        ).as_bytes());
        
        for tx in &block.transactions {
            hasher.update(format!("{}{}{}", tx.from, tx.to, tx.amount).as_bytes());
        }
        
        format!("{:x}", hasher.finalize())
    }

    /// 签名区块
    fn sign_block(&self, block: &PoSBlock, validator: &str) -> Result<String, Box<dyn std::error::Error>> {
        // 实现数字签名
        let signature_data = format!("{}{}{}", block.height, block.timestamp, block.hash);
        let mut hasher = Sha256::new();
        hasher.update(signature_data.as_bytes());
        Ok(format!("{:x}", hasher.finalize()))
    }

    /// 验证区块
    pub fn verify_block(&self, block: &PoSBlock) -> Result<bool, Box<dyn std::error::Error>> {
        // 验证哈希
        let computed_hash = self.compute_block_hash(block);
        if computed_hash != block.hash {
            return Ok(false);
        }
        
        // 验证签名
        let expected_signature = self.sign_block(block, &block.validator)?;
        if expected_signature != block.signature {
            return Ok(false);
        }
        
        // 验证验证者
        if !self.nodes.contains_key(&block.validator) {
            return Ok(false);
        }
        
        Ok(true)
    }

    /// 处理交易
    pub fn process_transaction(&mut self, transaction: Transaction) -> Result<bool, Box<dyn std::error::Error>> {
        // 验证交易
        if !self.verify_transaction(&transaction)? {
            return Ok(false);
        }
        
        // 更新余额
        self.update_balances(&transaction)?;
        
        Ok(true)
    }

    /// 验证交易
    fn verify_transaction(&self, transaction: &Transaction) -> Result<bool, Box<dyn std::error::Error>> {
        // 实现交易验证逻辑
        Ok(true)
    }

    /// 更新余额
    fn update_balances(&mut self, transaction: &Transaction) -> Result<(), Box<dyn std::error::Error>> {
        // 实现余额更新逻辑
        Ok(())
    }
}
```

## 4. 共识算法比较

### 4.1 性能对比

| 算法 | 容错能力 | 性能 | 复杂度 | 适用场景 |
|------|----------|------|--------|----------|
| Raft | f < n/2 | 中等 | 简单 | 一般分布式系统 |
| PBFT | f < n/3 | 高 | 复杂 | 拜占庭容错系统 |
| PoS | 基于权益 | 高 | 中等 | 区块链系统 |

### 4.2 实现示例

```rust
// 共识算法工厂
pub struct ConsensusFactory;

impl ConsensusFactory {
    pub fn create_consensus(algorithm: &str, config: ConsensusConfig) -> Box<dyn Consensus> {
        match algorithm {
            "raft" => Box::new(RaftNode::new(config.into())),
            "pbft" => Box::new(PBFTNode::new(config.id, config.nodes)),
            "pos" => Box::new(PoSNetwork::new()),
            _ => panic!("Unsupported consensus algorithm: {}", algorithm),
        }
    }
}

// 共识算法接口
pub trait Consensus {
    fn start(&mut self) -> Result<(), Box<dyn std::error::Error>>;
    fn stop(&mut self) -> Result<(), Box<dyn std::error::Error>>;
    fn propose(&mut self, data: Vec<u8>) -> Result<u64, Box<dyn std::error::Error>>;
    fn get_consensus(&self) -> Result<Vec<u8>, Box<dyn std::error::Error>>;
}
```

## 5. 总结

本实现提供了：

1. **完整的Raft算法实现** - 包含选举、日志复制、安全性保证
2. **PBFT算法实现** - 拜占庭容错，适用于恶意节点环境
3. **PoS算法实现** - 权益证明，适用于区块链系统
4. **性能对比分析** - 帮助选择合适的共识算法
5. **统一接口设计** - 便于系统集成和算法切换

这些实现为IoT系统提供了可靠的分布式共识基础，确保系统的一致性和可用性。
