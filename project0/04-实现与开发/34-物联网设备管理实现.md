# 物联网设备管理实现

## 概述

物联网设备管理系统提供设备注册、状态监控、固件管理、设备分组和远程控制等核心功能。

## 核心架构

### 1. 设备定义

```rust
// 设备核心结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Device {
    pub id: String,
    pub name: String,
    pub device_type: DeviceType,
    pub status: DeviceStatus,
    pub capabilities: Vec<DeviceCapability>,
    pub properties: HashMap<String, DeviceProperty>,
    pub location: Option<Location>,
    pub metadata: DeviceMetadata,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub last_seen: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DeviceType {
    Sensor,
    Actuator,
    Gateway,
    Controller,
    Camera,
    Display,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceStatus {
    pub online: bool,
    pub health_score: f64,
    pub battery_level: Option<f64>,
    pub signal_strength: Option<f64>,
    pub error_count: u32,
    pub warning_count: u32,
    pub last_error: Option<String>,
    pub maintenance_mode: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceCapability {
    pub name: String,
    pub capability_type: CapabilityType,
    pub parameters: HashMap<String, String>,
    pub supported_operations: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum CapabilityType {
    Read,
    Write,
    Execute,
    Monitor,
    Control,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceProperty {
    pub name: String,
    pub value: PropertyValue,
    pub data_type: DataType,
    pub unit: Option<String>,
    pub writable: bool,
    pub description: Option<String>,
    pub last_updated: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PropertyValue {
    String(String),
    Number(f64),
    Boolean(bool),
    Array(Vec<PropertyValue>),
    Object(HashMap<String, PropertyValue>),
    Null,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceMetadata {
    pub manufacturer: String,
    pub model: String,
    pub serial_number: String,
    pub firmware_version: String,
    pub hardware_version: String,
    pub tags: Vec<String>,
    pub description: Option<String>,
}
```

### 2. 设备管理器

```rust
pub struct DeviceManager {
    devices: Arc<RwLock<HashMap<String, Device>>>,
    groups: Arc<RwLock<HashMap<String, DeviceGroup>>>,
    firmware_manager: Arc<FirmwareManager>,
    event_sender: mpsc::Sender<DeviceEvent>,
    health_checker: Arc<DeviceHealthChecker>,
}

impl DeviceManager {
    pub fn new() -> Self {
        let (event_sender, event_receiver) = mpsc::channel();
        
        Self {
            devices: Arc::new(RwLock::new(HashMap::new())),
            groups: Arc::new(RwLock::new(HashMap::new())),
            firmware_manager: Arc::new(FirmwareManager::new()),
            event_sender,
            health_checker: Arc::new(DeviceHealthChecker::new()),
        }
    }

    // 注册设备
    pub async fn register_device(&self, device: Device) -> Result<(), DeviceError> {
        let mut devices = self.devices.write().await;
        
        if devices.contains_key(&device.id) {
            return Err(DeviceError::DeviceAlreadyExists);
        }
        
        devices.insert(device.id.clone(), device.clone());
        
        self.event_sender.send(DeviceEvent::Registered(device.id.clone())).await?;
        Ok(())
    }

    // 更新设备状态
    pub async fn update_device_status(&self, device_id: &str, status: DeviceStatus) -> Result<(), DeviceError> {
        let mut devices = self.devices.write().await;
        
        if let Some(device) = devices.get_mut(device_id) {
            device.status = status;
            device.updated_at = Utc::now();
            device.last_seen = Utc::now();
            
            self.event_sender.send(DeviceEvent::StatusUpdated(device_id.to_string())).await?;
        }
        
        Ok(())
    }

    // 获取设备信息
    pub async fn get_device(&self, device_id: &str) -> Option<Device> {
        let devices = self.devices.read().await;
        devices.get(device_id).cloned()
    }

    // 列出所有设备
    pub async fn list_devices(&self, filter: Option<DeviceFilter>) -> Vec<Device> {
        let devices = self.devices.read().await;
        
        if let Some(filter) = filter {
            devices.values()
                .filter(|device| filter.matches(device))
                .cloned()
                .collect()
        } else {
            devices.values().cloned().collect()
        }
    }

    // 删除设备
    pub async fn delete_device(&self, device_id: &str) -> Result<(), DeviceError> {
        let mut devices = self.devices.write().await;
        
        if devices.remove(device_id).is_some() {
            self.event_sender.send(DeviceEvent::Deleted(device_id.to_string())).await?;
            Ok(())
        } else {
            Err(DeviceError::DeviceNotFound)
        }
    }

    // 设备健康检查
    pub async fn check_device_health(&self, device_id: &str) -> Result<DeviceHealth, DeviceError> {
        let device = self.get_device(device_id).await
            .ok_or(DeviceError::DeviceNotFound)?;
        
        let health = self.health_checker.check_health(&device).await;
        Ok(health)
    }
}

#[derive(Debug, Clone)]
pub struct DeviceFilter {
    pub device_type: Option<DeviceType>,
    pub online_only: bool,
    pub tags: Vec<String>,
    pub location: Option<Location>,
}

impl DeviceFilter {
    pub fn matches(&self, device: &Device) -> bool {
        if let Some(ref device_type) = self.device_type {
            if device.device_type != *device_type {
                return false;
            }
        }
        
        if self.online_only && !device.status.online {
            return false;
        }
        
        if !self.tags.is_empty() {
            let device_tags: HashSet<_> = device.metadata.tags.iter().collect();
            let filter_tags: HashSet<_> = self.tags.iter().collect();
            if device_tags.intersection(&filter_tags).count() == 0 {
                return false;
            }
        }
        
        if let Some(ref location) = self.location {
            if let Some(ref device_location) = device.location {
                if !self.is_location_match(device_location, location) {
                    return false;
                }
            }
        }
        
        true
    }
    
    fn is_location_match(&self, device_loc: &Location, filter_loc: &Location) -> bool {
        // 简化的位置匹配逻辑
        let distance = ((device_loc.latitude - filter_loc.latitude).powi(2) + 
                       (device_loc.longitude - filter_loc.longitude).powi(2)).sqrt();
        distance < 0.01 // 约1km范围内
    }
}
```

### 3. 设备分组管理

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceGroup {
    pub id: String,
    pub name: String,
    pub description: String,
    pub device_ids: Vec<String>,
    pub group_type: GroupType,
    pub rules: Vec<GroupRule>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GroupType {
    Manual,
    Automatic,
    Dynamic,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GroupRule {
    pub field: String,
    pub operator: RuleOperator,
    pub value: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum RuleOperator {
    Equals,
    NotEquals,
    Contains,
    GreaterThan,
    LessThan,
    In,
    NotIn,
}

impl DeviceManager {
    // 创建设备分组
    pub async fn create_group(&self, group: DeviceGroup) -> Result<(), DeviceError> {
        let mut groups = self.groups.write().await;
        
        if groups.contains_key(&group.id) {
            return Err(DeviceError::GroupAlreadyExists);
        }
        
        groups.insert(group.id.clone(), group);
        Ok(())
    }

    // 添加设备到分组
    pub async fn add_device_to_group(&self, group_id: &str, device_id: &str) -> Result<(), DeviceError> {
        let mut groups = self.groups.write().await;
        
        if let Some(group) = groups.get_mut(group_id) {
            if !group.device_ids.contains(&device_id.to_string()) {
                group.device_ids.push(device_id.to_string());
                group.updated_at = Utc::now();
            }
        }
        
        Ok(())
    }

    // 从分组移除设备
    pub async fn remove_device_from_group(&self, group_id: &str, device_id: &str) -> Result<(), DeviceError> {
        let mut groups = self.groups.write().await;
        
        if let Some(group) = groups.get_mut(group_id) {
            group.device_ids.retain(|id| id != device_id);
            group.updated_at = Utc::now();
        }
        
        Ok(())
    }

    // 获取分组设备
    pub async fn get_group_devices(&self, group_id: &str) -> Result<Vec<Device>, DeviceError> {
        let groups = self.groups.read().await;
        let devices = self.devices.read().await;
        
        if let Some(group) = groups.get(group_id) {
            let group_devices: Vec<Device> = group.device_ids
                .iter()
                .filter_map(|id| devices.get(id).cloned())
                .collect();
            Ok(group_devices)
        } else {
            Err(DeviceError::GroupNotFound)
        }
    }
}
```

### 4. 固件管理

```rust
pub struct FirmwareManager {
    firmware_store: Arc<RwLock<HashMap<String, Firmware>>>,
    update_queue: Arc<RwLock<Vec<FirmwareUpdate>>>,
    update_sender: mpsc::Sender<FirmwareUpdate>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Firmware {
    pub id: String,
    pub name: String,
    pub version: String,
    pub device_type: DeviceType,
    pub file_size: u64,
    pub checksum: String,
    pub download_url: String,
    pub release_notes: String,
    pub compatible_versions: Vec<String>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FirmwareUpdate {
    pub id: String,
    pub device_id: String,
    pub firmware_id: String,
    pub status: UpdateStatus,
    pub progress: f64,
    pub started_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
    pub error_message: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UpdateStatus {
    Pending,
    Downloading,
    Installing,
    Completed,
    Failed,
    RolledBack,
}

impl FirmwareManager {
    pub fn new() -> Self {
        let (update_sender, update_receiver) = mpsc::channel();
        
        Self {
            firmware_store: Arc::new(RwLock::new(HashMap::new())),
            update_queue: Arc::new(RwLock::new(Vec::new())),
            update_sender,
        }
    }

    // 上传固件
    pub async fn upload_firmware(&self, firmware: Firmware) -> Result<(), FirmwareError> {
        let mut store = self.firmware_store.write().await;
        
        if store.contains_key(&firmware.id) {
            return Err(FirmwareError::FirmwareAlreadyExists);
        }
        
        store.insert(firmware.id.clone(), firmware);
        Ok(())
    }

    // 检查设备固件更新
    pub async fn check_for_updates(&self, device: &Device) -> Result<Vec<Firmware>, FirmwareError> {
        let store = self.firmware_store.read().await;
        
        let compatible_firmware: Vec<Firmware> = store.values()
            .filter(|firmware| {
                firmware.device_type == device.device_type &&
                firmware.compatible_versions.contains(&device.metadata.firmware_version)
            })
            .cloned()
            .collect();
        
        Ok(compatible_firmware)
    }

    // 开始固件更新
    pub async fn start_firmware_update(&self, device_id: &str, firmware_id: &str) -> Result<(), FirmwareError> {
        let update = FirmwareUpdate {
            id: Uuid::new_v4().to_string(),
            device_id: device_id.to_string(),
            firmware_id: firmware_id.to_string(),
            status: UpdateStatus::Pending,
            progress: 0.0,
            started_at: Utc::now(),
            completed_at: None,
            error_message: None,
        };
        
        let mut queue = self.update_queue.write().await;
        queue.push(update.clone());
        
        self.update_sender.send(update).await
            .map_err(|_| FirmwareError::UpdateFailed)?;
        
        Ok(())
    }

    // 获取更新状态
    pub async fn get_update_status(&self, update_id: &str) -> Option<FirmwareUpdate> {
        let queue = self.update_queue.read().await;
        queue.iter().find(|update| update.id == update_id).cloned()
    }
}
```

### 5. 设备健康检查

```rust
pub struct DeviceHealthChecker {
    health_rules: Vec<HealthRule>,
    alert_sender: mpsc::Sender<HealthAlert>,
}

#[derive(Debug, Clone)]
pub struct HealthRule {
    pub name: String,
    pub condition: HealthCondition,
    pub severity: AlertSeverity,
    pub action: HealthAction,
}

#[derive(Debug, Clone)]
pub enum HealthCondition {
    OfflineFor(Duration),
    BatteryBelow(f64),
    ErrorCountAbove(u32),
    HealthScoreBelow(f64),
    SignalStrengthBelow(f64),
}

#[derive(Debug, Clone)]
pub enum HealthAction {
    SendAlert,
    RestartDevice,
    EnterMaintenanceMode,
    UpdateFirmware,
    Custom(String),
}

#[derive(Debug, Clone)]
pub struct DeviceHealth {
    pub device_id: String,
    pub overall_score: f64,
    pub checks: Vec<HealthCheck>,
    pub recommendations: Vec<String>,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone)]
pub struct HealthCheck {
    pub name: String,
    pub status: HealthStatus,
    pub score: f64,
    pub message: String,
}

#[derive(Debug, Clone)]
pub enum HealthStatus {
    Healthy,
    Warning,
    Critical,
    Unknown,
}

impl DeviceHealthChecker {
    pub fn new() -> Self {
        let (alert_sender, _alert_receiver) = mpsc::channel();
        
        Self {
            health_rules: vec![
                HealthRule {
                    name: "设备离线检查".to_string(),
                    condition: HealthCondition::OfflineFor(Duration::from_minutes(5)),
                    severity: AlertSeverity::Warning,
                    action: HealthAction::SendAlert,
                },
                HealthRule {
                    name: "电池电量检查".to_string(),
                    condition: HealthCondition::BatteryBelow(20.0),
                    severity: AlertSeverity::Warning,
                    action: HealthAction::SendAlert,
                },
                HealthRule {
                    name: "错误计数检查".to_string(),
                    condition: HealthCondition::ErrorCountAbove(10),
                    severity: AlertSeverity::Critical,
                    action: HealthAction::EnterMaintenanceMode,
                },
            ],
            alert_sender,
        }
    }

    pub async fn check_health(&self, device: &Device) -> DeviceHealth {
        let mut checks = Vec::new();
        let mut recommendations = Vec::new();
        
        // 在线状态检查
        let online_check = self.check_online_status(device).await;
        checks.push(online_check.clone());
        
        // 电池状态检查
        if let Some(battery_level) = device.status.battery_level {
            let battery_check = self.check_battery_status(battery_level).await;
            checks.push(battery_check.clone());
        }
        
        // 错误计数检查
        let error_check = self.check_error_count(device.status.error_count).await;
        checks.push(error_check.clone());
        
        // 信号强度检查
        if let Some(signal_strength) = device.status.signal_strength {
            let signal_check = self.check_signal_strength(signal_strength).await;
            checks.push(signal_check.clone());
        }
        
        // 计算总体健康分数
        let overall_score = checks.iter().map(|check| check.score).sum::<f64>() / checks.len() as f64;
        
        // 生成建议
        if online_check.status == HealthStatus::Critical {
            recommendations.push("设备离线，请检查网络连接".to_string());
        }
        
        if let Some(battery_level) = device.status.battery_level {
            if battery_level < 20.0 {
                recommendations.push("电池电量低，请及时充电".to_string());
            }
        }
        
        if device.status.error_count > 10 {
            recommendations.push("错误次数过多，建议重启设备".to_string());
        }
        
        DeviceHealth {
            device_id: device.id.clone(),
            overall_score,
            checks,
            recommendations,
            timestamp: Utc::now(),
        }
    }
    
    async fn check_online_status(&self, device: &Device) -> HealthCheck {
        let status = if device.status.online {
            HealthStatus::Healthy
        } else {
            HealthStatus::Critical
        };
        
        let score = if device.status.online { 100.0 } else { 0.0 };
        
        HealthCheck {
            name: "在线状态".to_string(),
            status,
            score,
            message: if device.status.online { "设备在线".to_string() } else { "设备离线".to_string() },
        }
    }
    
    async fn check_battery_status(&self, battery_level: f64) -> HealthCheck {
        let (status, score, message) = if battery_level > 50.0 {
            (HealthStatus::Healthy, 100.0, "电池电量充足".to_string())
        } else if battery_level > 20.0 {
            (HealthStatus::Warning, 60.0, "电池电量较低".to_string())
        } else {
            (HealthStatus::Critical, 20.0, "电池电量严重不足".to_string())
        };
        
        HealthCheck {
            name: "电池状态".to_string(),
            status,
            score,
            message,
        }
    }
    
    async fn check_error_count(&self, error_count: u32) -> HealthCheck {
        let (status, score, message) = if error_count == 0 {
            (HealthStatus::Healthy, 100.0, "无错误".to_string())
        } else if error_count < 5 {
            (HealthStatus::Warning, 80.0, format!("轻微错误: {}", error_count))
        } else {
            (HealthStatus::Critical, 40.0, format!("严重错误: {}", error_count))
        };
        
        HealthCheck {
            name: "错误计数".to_string(),
            status,
            score,
            message,
        }
    }
    
    async fn check_signal_strength(&self, signal_strength: f64) -> HealthCheck {
        let (status, score, message) = if signal_strength > -60.0 {
            (HealthStatus::Healthy, 100.0, "信号强度良好".to_string())
        } else if signal_strength > -80.0 {
            (HealthStatus::Warning, 70.0, "信号强度一般".to_string())
        } else {
            (HealthStatus::Critical, 30.0, "信号强度较弱".to_string())
        };
        
        HealthCheck {
            name: "信号强度".to_string(),
            status,
            score,
            message,
        }
    }
}
```

### 6. 设备管理API

```rust
#[derive(Deserialize)]
pub struct RegisterDeviceRequest {
    pub name: String,
    pub device_type: DeviceType,
    pub capabilities: Vec<DeviceCapability>,
    pub properties: HashMap<String, DeviceProperty>,
    pub location: Option<Location>,
    pub metadata: DeviceMetadata,
}

#[derive(Serialize)]
pub struct DeviceResponse {
    pub device: Device,
    pub health: Option<DeviceHealth>,
}

// 设备管理API路由
pub fn device_routes() -> Router {
    Router::new()
        .route("/devices", post(register_device))
        .route("/devices", get(list_devices))
        .route("/devices/:id", get(get_device))
        .route("/devices/:id", put(update_device))
        .route("/devices/:id", delete(delete_device))
        .route("/devices/:id/status", put(update_device_status))
        .route("/devices/:id/health", get(check_device_health))
        .route("/devices/:id/control", post(control_device))
        .route("/groups", post(create_group))
        .route("/groups/:id", get(get_group))
        .route("/groups/:id/devices", get(get_group_devices))
        .route("/groups/:id/devices", post(add_device_to_group))
        .route("/firmware", post(upload_firmware))
        .route("/firmware/updates", post(start_firmware_update))
        .route("/firmware/updates/:id", get(get_update_status))
}

async fn register_device(
    Json(request): Json<RegisterDeviceRequest>,
    State(device_manager): State<Arc<DeviceManager>>,
) -> Result<Json<DeviceResponse>, StatusCode> {
    let device = Device {
        id: Uuid::new_v4().to_string(),
        name: request.name,
        device_type: request.device_type,
        status: DeviceStatus {
            online: true,
            health_score: 100.0,
            battery_level: None,
            signal_strength: None,
            error_count: 0,
            warning_count: 0,
            last_error: None,
            maintenance_mode: false,
        },
        capabilities: request.capabilities,
        properties: request.properties,
        location: request.location,
        metadata: request.metadata,
        created_at: Utc::now(),
        updated_at: Utc::now(),
        last_seen: Utc::now(),
    };

    device_manager.register_device(device.clone()).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    let health = device_manager.check_device_health(&device.id).await.ok();

    Ok(Json(DeviceResponse {
        device,
        health,
    }))
}

async fn get_device(
    Path(device_id): Path<String>,
    State(device_manager): State<Arc<DeviceManager>>,
) -> Result<Json<DeviceResponse>, StatusCode> {
    let device = device_manager.get_device(&device_id).await
        .ok_or(StatusCode::NOT_FOUND)?;

    let health = device_manager.check_device_health(&device_id).await.ok();

    Ok(Json(DeviceResponse {
        device,
        health,
    }))
}

async fn list_devices(
    Query(filter): Query<DeviceFilter>,
    State(device_manager): State<Arc<DeviceManager>>,
) -> Result<Json<Vec<Device>>, StatusCode> {
    let devices = device_manager.list_devices(Some(filter)).await;
    Ok(Json(devices))
}
```

## 使用示例

### 1. 注册传感器设备

```rust
#[tokio::main]
async fn main() {
    let device_manager = Arc::new(DeviceManager::new());
    
    // 注册温度传感器
    let sensor_device = Device {
        id: "sensor-001".to_string(),
        name: "温度传感器".to_string(),
        device_type: DeviceType::Sensor,
        status: DeviceStatus {
            online: true,
            health_score: 95.0,
            battery_level: Some(85.0),
            signal_strength: Some(-65.0),
            error_count: 0,
            warning_count: 0,
            last_error: None,
            maintenance_mode: false,
        },
        capabilities: vec![
            DeviceCapability {
                name: "温度读取".to_string(),
                capability_type: CapabilityType::Read,
                parameters: HashMap::from([
                    ("unit".to_string(), "celsius".to_string()),
                    ("range".to_string(), "-40,125".to_string()),
                ]),
                supported_operations: vec!["read".to_string()],
            },
        ],
        properties: HashMap::from([
            ("temperature".to_string(), DeviceProperty {
                name: "temperature".to_string(),
                value: PropertyValue::Number(25.5),
                data_type: DataType::Float,
                unit: Some("°C".to_string()),
                writable: false,
                description: Some("当前温度".to_string()),
                last_updated: Utc::now(),
            }),
        ]),
        location: Some(Location {
            latitude: 39.9042,
            longitude: 116.4074,
            altitude: 50.0,
        }),
        metadata: DeviceMetadata {
            manufacturer: "Adafruit".to_string(),
            model: "DHT22".to_string(),
            serial_number: "SN001234".to_string(),
            firmware_version: "1.2.0".to_string(),
            hardware_version: "v2.1".to_string(),
            tags: vec!["sensor".to_string(), "temperature".to_string()],
            description: Some("高精度温湿度传感器".to_string()),
        },
        created_at: Utc::now(),
        updated_at: Utc::now(),
        last_seen: Utc::now(),
    };

    device_manager.register_device(sensor_device).await.unwrap();
    println!("传感器设备注册成功");
}
```

### 2. 设备分组管理

```rust
// 创建设备分组
async fn create_device_groups(device_manager: Arc<DeviceManager>) {
    let sensor_group = DeviceGroup {
        id: "sensor-group".to_string(),
        name: "传感器组".to_string(),
        description: "所有传感器设备".to_string(),
        device_ids: vec!["sensor-001".to_string(), "sensor-002".to_string()],
        group_type: GroupType::Manual,
        rules: vec![
            GroupRule {
                field: "device_type".to_string(),
                operator: RuleOperator::Equals,
                value: "Sensor".to_string(),
            },
        ],
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };

    device_manager.create_group(sensor_group).await.unwrap();
    println!("传感器分组创建成功");
}
```

### 3. 固件更新

```rust
// 固件更新流程
async fn firmware_update_process(device_manager: Arc<DeviceManager>) {
    let firmware = Firmware {
        id: "fw-001".to_string(),
        name: "DHT22固件".to_string(),
        version: "1.3.0".to_string(),
        device_type: DeviceType::Sensor,
        file_size: 1024 * 50, // 50KB
        checksum: "sha256:abc123...".to_string(),
        download_url: "https://example.com/firmware/dht22-v1.3.0.bin".to_string(),
        release_notes: "修复温度读取精度问题".to_string(),
        compatible_versions: vec!["1.2.0".to_string(), "1.2.1".to_string()],
        created_at: Utc::now(),
    };

    device_manager.firmware_manager.upload_firmware(firmware).await.unwrap();
    
    // 开始更新
    device_manager.firmware_manager.start_firmware_update("sensor-001", "fw-001").await.unwrap();
    println!("固件更新已启动");
}
```

## 核心特性

1. **设备注册**: 支持多种设备类型、自动生成设备ID
2. **状态监控**: 实时监控设备在线状态、健康度、电池电量
3. **设备分组**: 支持手动和自动分组、动态规则
4. **固件管理**: 固件上传、版本检查、远程更新
5. **健康检查**: 多维度健康评估、自动告警
6. **远程控制**: 设备属性读写、命令执行
7. **位置管理**: GPS定位、地理围栏
8. **API接口**: 完整的RESTful API支持

这个物联网设备管理实现提供了完整的设备生命周期管理功能，支持设备注册、监控、分组和固件更新。
