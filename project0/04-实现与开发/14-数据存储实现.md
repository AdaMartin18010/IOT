# 数据存储实现

## 概述

数据存储系统负责IoT数据的持久化存储，支持多种存储后端（关系型数据库、时序数据库、对象存储等）。

## 核心组件

### 1. 数据存储管理器

#### Rust实现

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use tokio::sync::mpsc;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use async_trait::async_trait;

/// 存储类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StorageType {
    PostgreSQL,
    InfluxDB,
    Redis,
    MongoDB,
    S3,
    Local,
}

/// 数据记录
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataRecord {
    pub id: String,
    pub device_id: String,
    pub timestamp: DateTime<Utc>,
    pub data_type: String,
    pub value: serde_json::Value,
    pub metadata: HashMap<String, serde_json::Value>,
    pub tags: HashMap<String, String>,
}

/// 查询条件
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QueryCondition {
    pub device_id: Option<String>,
    pub data_type: Option<String>,
    pub start_time: Option<DateTime<Utc>>,
    pub end_time: Option<DateTime<Utc>>,
    pub tags: HashMap<String, String>,
    pub limit: Option<usize>,
    pub offset: Option<usize>,
}

/// 存储配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StorageConfig {
    pub storage_type: StorageType,
    pub connection_string: String,
    pub database_name: String,
    pub username: Option<String>,
    pub password: Option<String>,
    pub max_connections: usize,
    pub timeout: std::time::Duration,
    pub retry_count: usize,
}

/// 存储接口
#[async_trait]
pub trait DataStorage: Send + Sync {
    async fn initialize(&mut self, config: StorageConfig) -> Result<(), Box<dyn std::error::Error>>;
    async fn store_data(&self, record: DataRecord) -> Result<(), Box<dyn std::error::Error>>;
    async fn query_data(&self, condition: QueryCondition) -> Result<Vec<DataRecord>, Box<dyn std::error::Error>>;
    async fn delete_data(&self, condition: QueryCondition) -> Result<usize, Box<dyn std::error::Error>>;
    async fn health_check(&self) -> Result<bool, Box<dyn std::error::Error>>;
}

/// PostgreSQL存储实现
pub struct PostgreSQLStorage {
    pool: Option<sqlx::PgPool>,
    config: StorageConfig,
}

impl PostgreSQLStorage {
    pub fn new(config: StorageConfig) -> Self {
        Self {
            pool: None,
            config,
        }
    }
}

#[async_trait]
impl DataStorage for PostgreSQLStorage {
    async fn initialize(&mut self, config: StorageConfig) -> Result<(), Box<dyn std::error::Error>> {
        self.config = config;
        
        let pool = sqlx::PgPool::connect(&self.config.connection_string).await?;
        
        // 创建表
        sqlx::query(
            r#"
            CREATE TABLE IF NOT EXISTS iot_data (
                id VARCHAR(255) PRIMARY KEY,
                device_id VARCHAR(255) NOT NULL,
                timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
                data_type VARCHAR(100) NOT NULL,
                value JSONB NOT NULL,
                metadata JSONB,
                tags JSONB,
                created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
            )
            "#,
        )
        .execute(&pool)
        .await?;

        // 创建索引
        sqlx::query(
            "CREATE INDEX IF NOT EXISTS idx_device_timestamp ON iot_data(device_id, timestamp)"
        )
        .execute(&pool)
        .await?;

        self.pool = Some(pool);
        Ok(())
    }

    async fn store_data(&self, record: DataRecord) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(pool) = &self.pool {
            sqlx::query(
                r#"
                INSERT INTO iot_data (id, device_id, timestamp, data_type, value, metadata, tags)
                VALUES ($1, $2, $3, $4, $5, $6, $7)
                "#,
            )
            .bind(&record.id)
            .bind(&record.device_id)
            .bind(record.timestamp)
            .bind(&record.data_type)
            .bind(serde_json::to_value(&record.value)?)
            .bind(serde_json::to_value(&record.metadata)?)
            .bind(serde_json::to_value(&record.tags)?)
            .execute(pool)
            .await?;
        }
        Ok(())
    }

    async fn query_data(&self, condition: QueryCondition) -> Result<Vec<DataRecord>, Box<dyn std::error::Error>> {
        if let Some(pool) = &self.pool {
            let mut query = String::from("SELECT * FROM iot_data WHERE 1=1");
            let mut params: Vec<Box<dyn sqlx::Encode<'_, sqlx::Postgres> + Send + Sync>> = vec![];
            let mut param_count = 0;

            if let Some(device_id) = &condition.device_id {
                param_count += 1;
                query.push_str(&format!(" AND device_id = ${}", param_count));
                params.push(Box::new(device_id.clone()));
            }

            if let Some(data_type) = &condition.data_type {
                param_count += 1;
                query.push_str(&format!(" AND data_type = ${}", param_count));
                params.push(Box::new(data_type.clone()));
            }

            if let Some(start_time) = &condition.start_time {
                param_count += 1;
                query.push_str(&format!(" AND timestamp >= ${}", param_count));
                params.push(Box::new(*start_time));
            }

            if let Some(end_time) = &condition.end_time {
                param_count += 1;
                query.push_str(&format!(" AND timestamp <= ${}", param_count));
                params.push(Box::new(*end_time));
            }

            query.push_str(" ORDER BY timestamp DESC");

            if let Some(limit) = condition.limit {
                param_count += 1;
                query.push_str(&format!(" LIMIT ${}", param_count));
                params.push(Box::new(limit as i64));
            }

            if let Some(offset) = condition.offset {
                param_count += 1;
                query.push_str(&format!(" OFFSET ${}", param_count));
                params.push(Box::new(offset as i64));
            }

            let rows = sqlx::query_as::<_, (String, String, DateTime<Utc>, String, serde_json::Value, serde_json::Value, serde_json::Value)>(
                &query
            )
            .execute(pool)
            .await?;

            let mut records = Vec::new();
            for row in rows {
                records.push(DataRecord {
                    id: row.0,
                    device_id: row.1,
                    timestamp: row.2,
                    data_type: row.3,
                    value: row.4,
                    metadata: serde_json::from_value(row.5).unwrap_or_default(),
                    tags: serde_json::from_value(row.6).unwrap_or_default(),
                });
            }

            return Ok(records);
        }
        Ok(vec![])
    }

    async fn delete_data(&self, condition: QueryCondition) -> Result<usize, Box<dyn std::error::Error>> {
        if let Some(pool) = &self.pool {
            let mut query = String::from("DELETE FROM iot_data WHERE 1=1");
            let mut params: Vec<Box<dyn sqlx::Encode<'_, sqlx::Postgres> + Send + Sync>> = vec![];
            let mut param_count = 0;

            if let Some(device_id) = &condition.device_id {
                param_count += 1;
                query.push_str(&format!(" AND device_id = ${}", param_count));
                params.push(Box::new(device_id.clone()));
            }

            if let Some(start_time) = &condition.start_time {
                param_count += 1;
                query.push_str(&format!(" AND timestamp >= ${}", param_count));
                params.push(Box::new(*start_time));
            }

            if let Some(end_time) = &condition.end_time {
                param_count += 1;
                query.push_str(&format!(" AND timestamp <= ${}", param_count));
                params.push(Box::new(*end_time));
            }

            let result = sqlx::query(&query)
                .execute(pool)
                .await?;

            Ok(result.rows_affected() as usize)
        } else {
            Ok(0)
        }
    }

    async fn health_check(&self) -> Result<bool, Box<dyn std::error::Error>> {
        if let Some(pool) = &self.pool {
            sqlx::query("SELECT 1").execute(pool).await?;
            Ok(true)
        } else {
            Ok(false)
        }
    }
}

/// 数据存储管理器
pub struct DataStorageManager {
    storages: Arc<RwLock<HashMap<String, Arc<dyn DataStorage>>>>,
    default_storage: Arc<RwLock<Option<String>>>,
    event_sender: mpsc::Sender<StorageEvent>,
}

impl DataStorageManager {
    pub fn new() -> Self {
        let (event_sender, _) = mpsc::channel(1000);
        
        Self {
            storages: Arc::new(RwLock::new(HashMap::new())),
            default_storage: Arc::new(RwLock::new(None)),
            event_sender,
        }
    }

    /// 注册存储后端
    pub async fn register_storage(
        &self,
        name: String,
        storage: Arc<dyn DataStorage>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        {
            let mut storages = self.storages.write().unwrap();
            storages.insert(name.clone(), storage);
        }

        // 设置默认存储
        {
            let mut default_storage = self.default_storage.write().unwrap();
            if default_storage.is_none() {
                *default_storage = Some(name.clone());
            }
        }

        // 发送注册事件
        let _ = self.event_sender.send(StorageEvent::StorageRegistered { name }).await;

        Ok(())
    }

    /// 存储数据
    pub async fn store_data(&self, record: DataRecord) -> Result<(), Box<dyn std::error::Error>> {
        let storage_name = {
            let default_storage = self.default_storage.read().unwrap();
            default_storage.clone().unwrap_or_else(|| "default".to_string())
        };

        let storage = {
            let storages = self.storages.read().unwrap();
            storages.get(&storage_name).cloned()
        };

        if let Some(storage) = storage {
            storage.store_data(record).await?;
            
            // 发送存储事件
            let _ = self.event_sender.send(StorageEvent::DataStored { 
                storage_name,
                record_count: 1,
            }).await;
        }

        Ok(())
    }

    /// 查询数据
    pub async fn query_data(&self, condition: QueryCondition) -> Result<Vec<DataRecord>, Box<dyn std::error::Error>> {
        let storage_name = {
            let default_storage = self.default_storage.read().unwrap();
            default_storage.clone().unwrap_or_else(|| "default".to_string())
        };

        let storage = {
            let storages = self.storages.read().unwrap();
            storages.get(&storage_name).cloned()
        };

        if let Some(storage) = storage {
            storage.query_data(condition).await
        } else {
            Ok(vec![])
        }
    }

    /// 删除数据
    pub async fn delete_data(&self, condition: QueryCondition) -> Result<usize, Box<dyn std::error::Error>> {
        let storage_name = {
            let default_storage = self.default_storage.read().unwrap();
            default_storage.clone().unwrap_or_else(|| "default".to_string())
        };

        let storage = {
            let storages = self.storages.read().unwrap();
            storages.get(&storage_name).cloned()
        };

        if let Some(storage) = storage {
            let deleted_count = storage.delete_data(condition).await?;
            
            // 发送删除事件
            let _ = self.event_sender.send(StorageEvent::DataDeleted { 
                storage_name,
                deleted_count,
            }).await;

            Ok(deleted_count)
        } else {
            Ok(0)
        }
    }

    /// 健康检查
    pub async fn health_check(&self) -> HashMap<String, bool> {
        let mut health_status = HashMap::new();
        let storages = {
            let storages = self.storages.read().unwrap();
            storages.clone()
        };

        for (name, storage) in storages {
            match storage.health_check().await {
                Ok(healthy) => {
                    health_status.insert(name, healthy);
                }
                Err(_) => {
                    health_status.insert(name, false);
                }
            }
        }

        health_status
    }
}

/// 存储事件
#[derive(Debug, Clone)]
pub enum StorageEvent {
    StorageRegistered { name: String },
    DataStored { storage_name: String, record_count: usize },
    DataDeleted { storage_name: String, deleted_count: usize },
    StorageError { name: String, error: String },
}
```

#### Go实现

```go
package storage

import (
    "context"
    "database/sql"
    "encoding/json"
    "fmt"
    "sync"
    "time"
    _ "github.com/lib/pq"
)

// StorageType 存储类型
type StorageType string

const (
    StorageTypePostgreSQL StorageType = "postgresql"
    StorageTypeInfluxDB   StorageType = "influxdb"
    StorageTypeRedis      StorageType = "redis"
    StorageTypeMongoDB    StorageType = "mongodb"
    StorageTypeS3         StorageType = "s3"
    StorageTypeLocal      StorageType = "local"
)

// DataRecord 数据记录
type DataRecord struct {
    ID         string                 `json:"id"`
    DeviceID   string                 `json:"device_id"`
    Timestamp  time.Time              `json:"timestamp"`
    DataType   string                 `json:"data_type"`
    Value      interface{}            `json:"value"`
    Metadata   map[string]interface{} `json:"metadata"`
    Tags       map[string]string      `json:"tags"`
}

// QueryCondition 查询条件
type QueryCondition struct {
    DeviceID   *string            `json:"device_id,omitempty"`
    DataType   *string            `json:"data_type,omitempty"`
    StartTime  *time.Time         `json:"start_time,omitempty"`
    EndTime    *time.Time         `json:"end_time,omitempty"`
    Tags       map[string]string  `json:"tags,omitempty"`
    Limit      *int               `json:"limit,omitempty"`
    Offset     *int               `json:"offset,omitempty"`
}

// StorageConfig 存储配置
type StorageConfig struct {
    StorageType       StorageType `json:"storage_type"`
    ConnectionString  string      `json:"connection_string"`
    DatabaseName      string      `json:"database_name"`
    Username          *string     `json:"username,omitempty"`
    Password          *string     `json:"password,omitempty"`
    MaxConnections    int         `json:"max_connections"`
    Timeout           time.Duration `json:"timeout"`
    RetryCount        int         `json:"retry_count"`
}

// DataStorage 存储接口
type DataStorage interface {
    Initialize(config StorageConfig) error
    StoreData(record DataRecord) error
    QueryData(condition QueryCondition) ([]DataRecord, error)
    DeleteData(condition QueryCondition) (int, error)
    HealthCheck() (bool, error)
}

// PostgreSQLStorage PostgreSQL存储实现
type PostgreSQLStorage struct {
    db     *sql.DB
    config StorageConfig
}

// NewPostgreSQLStorage 创建PostgreSQL存储
func NewPostgreSQLStorage(config StorageConfig) *PostgreSQLStorage {
    return &PostgreSQLStorage{
        config: config,
    }
}

// Initialize 初始化
func (p *PostgreSQLStorage) Initialize(config StorageConfig) error {
    p.config = config
    
    db, err := sql.Open("postgres", config.ConnectionString)
    if err != nil {
        return err
    }
    
    // 设置连接池
    db.SetMaxOpenConns(config.MaxConnections)
    db.SetMaxIdleConns(config.MaxConnections / 2)
    db.SetConnMaxLifetime(time.Hour)
    
    p.db = db
    
    // 创建表
    _, err = db.Exec(`
        CREATE TABLE IF NOT EXISTS iot_data (
            id VARCHAR(255) PRIMARY KEY,
            device_id VARCHAR(255) NOT NULL,
            timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
            data_type VARCHAR(100) NOT NULL,
            value JSONB NOT NULL,
            metadata JSONB,
            tags JSONB,
            created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
        )
    `)
    if err != nil {
        return err
    }
    
    // 创建索引
    _, err = db.Exec(`
        CREATE INDEX IF NOT EXISTS idx_device_timestamp ON iot_data(device_id, timestamp)
    `)
    if err != nil {
        return err
    }
    
    return nil
}

// StoreData 存储数据
func (p *PostgreSQLStorage) StoreData(record DataRecord) error {
    valueJSON, err := json.Marshal(record.Value)
    if err != nil {
        return err
    }
    
    metadataJSON, err := json.Marshal(record.Metadata)
    if err != nil {
        return err
    }
    
    tagsJSON, err := json.Marshal(record.Tags)
    if err != nil {
        return err
    }
    
    _, err = p.db.Exec(`
        INSERT INTO iot_data (id, device_id, timestamp, data_type, value, metadata, tags)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
    `, record.ID, record.DeviceID, record.Timestamp, record.DataType, valueJSON, metadataJSON, tagsJSON)
    
    return err
}

// QueryData 查询数据
func (p *PostgreSQLStorage) QueryData(condition QueryCondition) ([]DataRecord, error) {
    query := "SELECT id, device_id, timestamp, data_type, value, metadata, tags FROM iot_data WHERE 1=1"
    var args []interface{}
    argCount := 0
    
    if condition.DeviceID != nil {
        argCount++
        query += fmt.Sprintf(" AND device_id = $%d", argCount)
        args = append(args, *condition.DeviceID)
    }
    
    if condition.DataType != nil {
        argCount++
        query += fmt.Sprintf(" AND data_type = $%d", argCount)
        args = append(args, *condition.DataType)
    }
    
    if condition.StartTime != nil {
        argCount++
        query += fmt.Sprintf(" AND timestamp >= $%d", argCount)
        args = append(args, *condition.StartTime)
    }
    
    if condition.EndTime != nil {
        argCount++
        query += fmt.Sprintf(" AND timestamp <= $%d", argCount)
        args = append(args, *condition.EndTime)
    }
    
    query += " ORDER BY timestamp DESC"
    
    if condition.Limit != nil {
        argCount++
        query += fmt.Sprintf(" LIMIT $%d", argCount)
        args = append(args, *condition.Limit)
    }
    
    if condition.Offset != nil {
        argCount++
        query += fmt.Sprintf(" OFFSET $%d", argCount)
        args = append(args, *condition.Offset)
    }
    
    rows, err := p.db.Query(query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var records []DataRecord
    for rows.Next() {
        var record DataRecord
        var valueJSON, metadataJSON, tagsJSON []byte
        
        err := rows.Scan(&record.ID, &record.DeviceID, &record.Timestamp, &record.DataType, &valueJSON, &metadataJSON, &tagsJSON)
        if err != nil {
            return nil, err
        }
        
        err = json.Unmarshal(valueJSON, &record.Value)
        if err != nil {
            return nil, err
        }
        
        err = json.Unmarshal(metadataJSON, &record.Metadata)
        if err != nil {
            return nil, err
        }
        
        err = json.Unmarshal(tagsJSON, &record.Tags)
        if err != nil {
            return nil, err
        }
        
        records = append(records, record)
    }
    
    return records, nil
}

// DeleteData 删除数据
func (p *PostgreSQLStorage) DeleteData(condition QueryCondition) (int, error) {
    query := "DELETE FROM iot_data WHERE 1=1"
    var args []interface{}
    argCount := 0
    
    if condition.DeviceID != nil {
        argCount++
        query += fmt.Sprintf(" AND device_id = $%d", argCount)
        args = append(args, *condition.DeviceID)
    }
    
    if condition.StartTime != nil {
        argCount++
        query += fmt.Sprintf(" AND timestamp >= $%d", argCount)
        args = append(args, *condition.StartTime)
    }
    
    if condition.EndTime != nil {
        argCount++
        query += fmt.Sprintf(" AND timestamp <= $%d", argCount)
        args = append(args, *condition.EndTime)
    }
    
    result, err := p.db.Exec(query, args...)
    if err != nil {
        return 0, err
    }
    
    deletedCount, err := result.RowsAffected()
    if err != nil {
        return 0, err
    }
    
    return int(deletedCount), nil
}

// HealthCheck 健康检查
func (p *PostgreSQLStorage) HealthCheck() (bool, error) {
    if p.db == nil {
        return false, fmt.Errorf("database not initialized")
    }
    
    err := p.db.Ping()
    return err == nil, err
}

// DataStorageManager 数据存储管理器
type DataStorageManager struct {
    storages       map[string]DataStorage
    defaultStorage string
    eventChan      chan StorageEvent
    mu             sync.RWMutex
}

// NewDataStorageManager 创建数据存储管理器
func NewDataStorageManager() *DataStorageManager {
    return &DataStorageManager{
        storages:  make(map[string]DataStorage),
        eventChan: make(chan StorageEvent, 1000),
    }
}

// RegisterStorage 注册存储后端
func (dsm *DataStorageManager) RegisterStorage(name string, storage DataStorage) error {
    dsm.mu.Lock()
    defer dsm.mu.Unlock()
    
    dsm.storages[name] = storage
    
    // 设置默认存储
    if dsm.defaultStorage == "" {
        dsm.defaultStorage = name
    }
    
    // 发送注册事件
    select {
    case dsm.eventChan <- StorageEvent{Type: EventTypeStorageRegistered, StorageName: name}:
    default:
    }
    
    return nil
}

// StoreData 存储数据
func (dsm *DataStorageManager) StoreData(record DataRecord) error {
    dsm.mu.RLock()
    storage, exists := dsm.storages[dsm.defaultStorage]
    dsm.mu.RUnlock()
    
    if !exists {
        return fmt.Errorf("default storage not found")
    }
    
    err := storage.StoreData(record)
    if err != nil {
        return err
    }
    
    // 发送存储事件
    select {
    case dsm.eventChan <- StorageEvent{Type: EventTypeDataStored, StorageName: dsm.defaultStorage, RecordCount: 1}:
    default:
    }
    
    return nil
}

// QueryData 查询数据
func (dsm *DataStorageManager) QueryData(condition QueryCondition) ([]DataRecord, error) {
    dsm.mu.RLock()
    storage, exists := dsm.storages[dsm.defaultStorage]
    dsm.mu.RUnlock()
    
    if !exists {
        return nil, fmt.Errorf("default storage not found")
    }
    
    return storage.QueryData(condition)
}

// DeleteData 删除数据
func (dsm *DataStorageManager) DeleteData(condition QueryCondition) (int, error) {
    dsm.mu.RLock()
    storage, exists := dsm.storages[dsm.defaultStorage]
    dsm.mu.RUnlock()
    
    if !exists {
        return 0, fmt.Errorf("default storage not found")
    }
    
    deletedCount, err := storage.DeleteData(condition)
    if err != nil {
        return 0, err
    }
    
    // 发送删除事件
    select {
    case dsm.eventChan <- StorageEvent{Type: EventTypeDataDeleted, StorageName: dsm.defaultStorage, DeletedCount: deletedCount}:
    default:
    }
    
    return deletedCount, nil
}

// HealthCheck 健康检查
func (dsm *DataStorageManager) HealthCheck() map[string]bool {
    dsm.mu.RLock()
    storages := make(map[string]DataStorage)
    for name, storage := range dsm.storages {
        storages[name] = storage
    }
    dsm.mu.RUnlock()
    
    healthStatus := make(map[string]bool)
    for name, storage := range storages {
        healthy, _ := storage.HealthCheck()
        healthStatus[name] = healthy
    }
    
    return healthStatus
}

// GetEventChannel 获取事件通道
func (dsm *DataStorageManager) GetEventChannel() <-chan StorageEvent {
    return dsm.eventChan
}

// StorageEvent 存储事件
type StorageEvent struct {
    Type         EventType `json:"type"`
    StorageName  string    `json:"storage_name"`
    RecordCount  int       `json:"record_count,omitempty"`
    DeletedCount int       `json:"deleted_count,omitempty"`
    Error        string    `json:"error,omitempty"`
}

// EventType 事件类型
type EventType string

const (
    EventTypeStorageRegistered EventType = "storage_registered"
    EventTypeDataStored        EventType = "data_stored"
    EventTypeDataDeleted       EventType = "data_deleted"
    EventTypeStorageError      EventType = "storage_error"
)
```

### 2. 使用示例

```rust
// Rust示例
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let storage_manager = Arc::new(DataStorageManager::new());

    // 创建PostgreSQL存储
    let config = StorageConfig {
        storage_type: StorageType::PostgreSQL,
        connection_string: "postgresql://user:password@localhost/iot_db".to_string(),
        database_name: "iot_db".to_string(),
        username: Some("user".to_string()),
        password: Some("password".to_string()),
        max_connections: 10,
        timeout: std::time::Duration::from_secs(30),
        retry_count: 3,
    };

    let mut postgres_storage = PostgreSQLStorage::new(config);
    postgres_storage.initialize(config).await?;

    // 注册存储
    storage_manager.register_storage(
        "postgres".to_string(),
        Arc::new(postgres_storage),
    ).await?;

    // 存储数据
    let record = DataRecord {
        id: "record-001".to_string(),
        device_id: "device-001".to_string(),
        timestamp: Utc::now(),
        data_type: "temperature".to_string(),
        value: serde_json::json!(23.5),
        metadata: HashMap::new(),
        tags: HashMap::new(),
    };

    storage_manager.store_data(record).await?;

    // 查询数据
    let condition = QueryCondition {
        device_id: Some("device-001".to_string()),
        data_type: Some("temperature".to_string()),
        start_time: Some(Utc::now() - chrono::Duration::hours(1)),
        end_time: Some(Utc::now()),
        tags: HashMap::new(),
        limit: Some(100),
        offset: Some(0),
    };

    let records = storage_manager.query_data(condition).await?;
    println!("Found {} records", records.len());

    // 健康检查
    let health = storage_manager.health_check().await;
    println!("Health status: {:?}", health);

    Ok(())
}
```

```go
// Go示例
func main() {
    storageManager := NewDataStorageManager()

    // 创建PostgreSQL存储
    config := StorageConfig{
        StorageType:      StorageTypePostgreSQL,
        ConnectionString: "postgresql://user:password@localhost/iot_db?sslmode=disable",
        DatabaseName:     "iot_db",
        Username:         stringPtr("user"),
        Password:         stringPtr("password"),
        MaxConnections:   10,
        Timeout:          30 * time.Second,
        RetryCount:       3,
    }

    postgresStorage := NewPostgreSQLStorage(config)
    err := postgresStorage.Initialize(config)
    if err != nil {
        log.Fatal(err)
    }

    // 注册存储
    err = storageManager.RegisterStorage("postgres", postgresStorage)
    if err != nil {
        log.Fatal(err)
    }

    // 存储数据
    record := DataRecord{
        ID:        "record-001",
        DeviceID:  "device-001",
        Timestamp: time.Now(),
        DataType:  "temperature",
        Value:     23.5,
        Metadata:  make(map[string]interface{}),
        Tags:      make(map[string]string),
    }

    err = storageManager.StoreData(record)
    if err != nil {
        log.Fatal(err)
    }

    // 查询数据
    startTime := time.Now().Add(-time.Hour)
    endTime := time.Now()
    deviceID := "device-001"
    dataType := "temperature"
    limit := 100

    condition := QueryCondition{
        DeviceID:  &deviceID,
        DataType:  &dataType,
        StartTime: &startTime,
        EndTime:   &endTime,
        Tags:      make(map[string]string),
        Limit:     &limit,
    }

    records, err := storageManager.QueryData(condition)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Found %d records\n", len(records))

    // 健康检查
    health := storageManager.HealthCheck()
    fmt.Printf("Health status: %+v\n", health)

    // 监听事件
    go func() {
        for event := range storageManager.GetEventChannel() {
            fmt.Printf("Storage event: %+v\n", event)
        }
    }()

    select {}
}

func stringPtr(v string) *string { return &v }
```

## 总结

数据存储系统提供了以下核心功能：

1. **多存储后端支持**：支持PostgreSQL、InfluxDB、Redis、MongoDB、S3等
2. **统一存储接口**：提供标准化的数据存储和查询接口
3. **数据记录模型**：支持设备数据、时间戳、元数据和标签
4. **灵活查询条件**：支持按设备、时间、类型、标签等条件查询
5. **存储管理器**：统一管理多个存储后端
6. **事件系统**：提供存储操作的事件通知
7. **健康检查**：监控存储后端的健康状态

这个实现为IoT平台提供了强大的数据持久化能力。
