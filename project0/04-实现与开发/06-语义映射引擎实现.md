# 语义映射引擎实现

## 概述

语义映射引擎是IoT系统中实现不同协议、数据格式和语义模型之间互操作的核心组件。本文档提供基于Rust和Go的语义映射引擎实现。

## 核心架构

### 1. 语义模型定义

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// 语义类型枚举
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SemanticType {
    Temperature,
    Humidity,
    Pressure,
    Voltage,
    Current,
    Power,
    Status,
    Location,
    Custom(String),
}

/// 语义属性
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SemanticProperty {
    pub name: String,
    pub semantic_type: SemanticType,
    pub unit: Option<String>,
    pub description: Option<String>,
    pub constraints: HashMap<String, serde_json::Value>,
}

/// 语义模型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SemanticModel {
    pub id: String,
    pub name: String,
    pub version: String,
    pub namespace: String,
    pub properties: HashMap<String, SemanticProperty>,
    pub relationships: HashMap<String, String>,
}

/// 语义映射规则
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MappingRule {
    pub id: String,
    pub source_model: String,
    pub target_model: String,
    pub transformations: Vec<Transformation>,
    pub conditions: Vec<Condition>,
}

/// 数据转换
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Transformation {
    Direct(String, String),           // 直接映射
    Scale(String, String, f64),       // 缩放转换
    Offset(String, String, f64),      // 偏移转换
    Unit(String, String, String),     // 单位转换
    Formula(String, String, String),  // 公式转换
    Custom(String, String, String),   // 自定义转换
}

/// 映射条件
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Condition {
    pub field: String,
    pub operator: String,
    pub value: serde_json::Value,
}
```

### 2. 语义映射引擎

```rust
use tokio::sync::RwLock;
use std::sync::Arc;

/// 语义映射引擎
pub struct SemanticMappingEngine {
    models: Arc<RwLock<HashMap<String, SemanticModel>>>,
    rules: Arc<RwLock<HashMap<String, MappingRule>>>,
    transformers: Arc<RwLock<HashMap<String, Box<dyn DataTransformer>>>>,
}

impl SemanticMappingEngine {
    pub fn new() -> Self {
        Self {
            models: Arc::new(RwLock::new(HashMap::new())),
            rules: Arc::new(RwLock::new(HashMap::new())),
            transformers: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// 注册语义模型
    pub async fn register_model(&self, model: SemanticModel) -> Result<(), Box<dyn std::error::Error>> {
        let mut models = self.models.write().await;
        models.insert(model.id.clone(), model);
        Ok(())
    }

    /// 注册映射规则
    pub async fn register_rule(&self, rule: MappingRule) -> Result<(), Box<dyn std::error::Error>> {
        let mut rules = self.rules.write().await;
        rules.insert(rule.id.clone(), rule);
        Ok(())
    }

    /// 执行语义映射
    pub async fn map_data(
        &self,
        source_data: HashMap<String, serde_json::Value>,
        source_model: &str,
        target_model: &str,
    ) -> Result<HashMap<String, serde_json::Value>, Box<dyn std::error::Error>> {
        let rules = self.rules.read().await;
        let models = self.models.read().await;
        let transformers = self.transformers.read().await;

        // 查找匹配的映射规则
        let rule = rules
            .values()
            .find(|r| r.source_model == source_model && r.target_model == target_model)
            .ok_or("No mapping rule found")?;

        let mut result = HashMap::new();

        // 应用转换规则
        for transformation in &rule.transformations {
            let transformed_value = self.apply_transformation(
                &source_data,
                transformation,
                &models,
                &transformers,
            ).await?;
            
            if let Some(value) = transformed_value {
                result.insert(transformation.get_target_field().to_string(), value);
            }
        }

        Ok(result)
    }

    /// 应用数据转换
    async fn apply_transformation(
        &self,
        source_data: &HashMap<String, serde_json::Value>,
        transformation: &Transformation,
        models: &HashMap<String, SemanticModel>,
        transformers: &HashMap<String, Box<dyn DataTransformer>>,
    ) -> Result<Option<serde_json::Value>, Box<dyn std::error::Error>> {
        match transformation {
            Transformation::Direct(source_field, target_field) => {
                if let Some(value) = source_data.get(source_field) {
                    Ok(Some(value.clone()))
                } else {
                    Ok(None)
                }
            }
            Transformation::Scale(source_field, _, factor) => {
                if let Some(value) = source_data.get(source_field) {
                    if let Some(num) = value.as_f64() {
                        Ok(Some(serde_json::Value::Number(
                            serde_json::Number::from_f64(num * factor).unwrap()
                        )))
                    } else {
                        Ok(None)
                    }
                } else {
                    Ok(None)
                }
            }
            Transformation::Offset(source_field, _, offset) => {
                if let Some(value) = source_data.get(source_field) {
                    if let Some(num) = value.as_f64() {
                        Ok(Some(serde_json::Value::Number(
                            serde_json::Number::from_f64(num + offset).unwrap()
                        )))
                    } else {
                        Ok(None)
                    }
                } else {
                    Ok(None)
                }
            }
            Transformation::Unit(source_field, _, _) => {
                // 单位转换逻辑
                if let Some(value) = source_data.get(source_field) {
                    Ok(Some(value.clone()))
                } else {
                    Ok(None)
                }
            }
            Transformation::Formula(source_field, _, formula) => {
                // 公式转换逻辑
                if let Some(value) = source_data.get(source_field) {
                    // 这里可以集成表达式计算引擎
                    Ok(Some(value.clone()))
                } else {
                    Ok(None)
                }
            }
            Transformation::Custom(source_field, _, transformer_name) => {
                if let Some(transformer) = transformers.get(transformer_name) {
                    if let Some(value) = source_data.get(source_field) {
                        transformer.transform(value).await
                    } else {
                        Ok(None)
                    }
                } else {
                    Ok(None)
                }
            }
        }
    }
}

impl Transformation {
    fn get_target_field(&self) -> &str {
        match self {
            Transformation::Direct(_, target) => target,
            Transformation::Scale(_, target, _) => target,
            Transformation::Offset(_, target, _) => target,
            Transformation::Unit(_, target, _) => target,
            Transformation::Formula(_, target, _) => target,
            Transformation::Custom(_, target, _) => target,
        }
    }
}
```

### 3. 数据转换器接口

```rust
use async_trait::async_trait;

/// 数据转换器接口
#[async_trait]
pub trait DataTransformer: Send + Sync {
    async fn transform(&self, value: &serde_json::Value) -> Result<Option<serde_json::Value>, Box<dyn std::error::Error>>;
    fn get_name(&self) -> &str;
}

/// 温度单位转换器
pub struct TemperatureUnitTransformer;

#[async_trait]
impl DataTransformer for TemperatureUnitTransformer {
    async fn transform(&self, value: &serde_json::Value) -> Result<Option<serde_json::Value>, Box<dyn std::error::Error>> {
        if let Some(temp) = value.as_f64() {
            // 摄氏度转华氏度
            let fahrenheit = temp * 9.0 / 5.0 + 32.0;
            Ok(Some(serde_json::Value::Number(
                serde_json::Number::from_f64(fahrenheit).unwrap()
            )))
        } else {
            Ok(None)
        }
    }

    fn get_name(&self) -> &str {
        "temperature_unit"
    }
}

/// 数据格式转换器
pub struct DataFormatTransformer;

#[async_trait]
impl DataTransformer for DataFormatTransformer {
    async fn transform(&self, value: &serde_json::Value) -> Result<Option<serde_json::Value>, Box<dyn std::error::Error>> {
        // 数据格式转换逻辑
        Ok(Some(value.clone()))
    }

    fn get_name(&self) -> &str {
        "data_format"
    }
}
```

## Go实现

### 1. 语义模型定义1

```go
package semantic

import (
    "encoding/json"
    "fmt"
    "sync"
    "time"
)

// SemanticType 语义类型
type SemanticType string

const (
    SemanticTypeTemperature SemanticType = "temperature"
    SemanticTypeHumidity    SemanticType = "humidity"
    SemanticTypePressure    SemanticType = "pressure"
    SemanticTypeVoltage     SemanticType = "voltage"
    SemanticTypeCurrent     SemanticType = "current"
    SemanticTypePower       SemanticType = "power"
    SemanticTypeStatus      SemanticType = "status"
    SemanticTypeLocation    SemanticType = "location"
)

// SemanticProperty 语义属性
type SemanticProperty struct {
    Name         string                 `json:"name"`
    SemanticType SemanticType          `json:"semantic_type"`
    Unit         string                 `json:"unit,omitempty"`
    Description  string                 `json:"description,omitempty"`
    Constraints  map[string]interface{} `json:"constraints,omitempty"`
}

// SemanticModel 语义模型
type SemanticModel struct {
    ID           string                        `json:"id"`
    Name         string                        `json:"name"`
    Version      string                        `json:"version"`
    Namespace    string                        `json:"namespace"`
    Properties   map[string]SemanticProperty   `json:"properties"`
    Relationships map[string]string            `json:"relationships"`
}

// Transformation 数据转换
type Transformation struct {
    Type         string `json:"type"`
    SourceField  string `json:"source_field"`
    TargetField  string `json:"target_field"`
    Parameter    string `json:"parameter,omitempty"`
    Formula      string `json:"formula,omitempty"`
}

// MappingRule 映射规则
type MappingRule struct {
    ID           string           `json:"id"`
    SourceModel  string           `json:"source_model"`
    TargetModel  string           `json:"target_model"`
    Transformations []Transformation `json:"transformations"`
    Conditions   []Condition      `json:"conditions,omitempty"`
}

// Condition 映射条件
type Condition struct {
    Field    string      `json:"field"`
    Operator string      `json:"operator"`
    Value    interface{} `json:"value"`
}
```

### 2. 语义映射引擎1

```go
// SemanticMappingEngine 语义映射引擎
type SemanticMappingEngine struct {
    models       map[string]SemanticModel
    rules        map[string]MappingRule
    transformers map[string]DataTransformer
    mu           sync.RWMutex
}

// NewSemanticMappingEngine 创建新的语义映射引擎
func NewSemanticMappingEngine() *SemanticMappingEngine {
    return &SemanticMappingEngine{
        models:       make(map[string]SemanticModel),
        rules:        make(map[string]MappingRule),
        transformers: make(map[string]DataTransformer),
    }
}

// RegisterModel 注册语义模型
func (e *SemanticMappingEngine) RegisterModel(model SemanticModel) error {
    e.mu.Lock()
    defer e.mu.Unlock()
    
    e.models[model.ID] = model
    return nil
}

// RegisterRule 注册映射规则
func (e *SemanticMappingEngine) RegisterRule(rule MappingRule) error {
    e.mu.Lock()
    defer e.mu.Unlock()
    
    e.rules[rule.ID] = rule
    return nil
}

// MapData 执行语义映射
func (e *SemanticMappingEngine) MapData(
    sourceData map[string]interface{},
    sourceModel string,
    targetModel string,
) (map[string]interface{}, error) {
    e.mu.RLock()
    defer e.mu.RUnlock()

    // 查找匹配的映射规则
    var rule MappingRule
    found := false
    for _, r := range e.rules {
        if r.SourceModel == sourceModel && r.TargetModel == targetModel {
            rule = r
            found = true
            break
        }
    }

    if !found {
        return nil, fmt.Errorf("no mapping rule found for %s -> %s", sourceModel, targetModel)
    }

    result := make(map[string]interface{})

    // 应用转换规则
    for _, transformation := range rule.Transformations {
        transformedValue, err := e.applyTransformation(sourceData, transformation)
        if err != nil {
            return nil, fmt.Errorf("transformation failed: %w", err)
        }
        
        if transformedValue != nil {
            result[transformation.TargetField] = transformedValue
        }
    }

    return result, nil
}

// applyTransformation 应用数据转换
func (e *SemanticMappingEngine) applyTransformation(
    sourceData map[string]interface{},
    transformation Transformation,
) (interface{}, error) {
    sourceValue, exists := sourceData[transformation.SourceField]
    if !exists {
        return nil, nil
    }

    switch transformation.Type {
    case "direct":
        return sourceValue, nil
        
    case "scale":
        if num, ok := sourceValue.(float64); ok {
            if factor, err := parseFloat(transformation.Parameter); err == nil {
                return num * factor, nil
            }
        }
        
    case "offset":
        if num, ok := sourceValue.(float64); ok {
            if offset, err := parseFloat(transformation.Parameter); err == nil {
                return num + offset, nil
            }
        }
        
    case "unit":
        // 单位转换逻辑
        return sourceValue, nil
        
    case "formula":
        // 公式转换逻辑
        return sourceValue, nil
        
    case "custom":
        if transformer, exists := e.transformers[transformation.Parameter]; exists {
            return transformer.Transform(sourceValue)
        }
    }

    return nil, nil
}

func parseFloat(s string) (float64, error) {
    var f float64
    _, err := fmt.Sscanf(s, "%f", &f)
    return f, err
}
```

### 3. 数据转换器接口1

```go
// DataTransformer 数据转换器接口
type DataTransformer interface {
    Transform(value interface{}) (interface{}, error)
    GetName() string
}

// TemperatureUnitTransformer 温度单位转换器
type TemperatureUnitTransformer struct{}

func (t *TemperatureUnitTransformer) Transform(value interface{}) (interface{}, error) {
    if temp, ok := value.(float64); ok {
        // 摄氏度转华氏度
        fahrenheit := temp*9.0/5.0 + 32.0
        return fahrenheit, nil
    }
    return nil, fmt.Errorf("invalid temperature value")
}

func (t *TemperatureUnitTransformer) GetName() string {
    return "temperature_unit"
}

// DataFormatTransformer 数据格式转换器
type DataFormatTransformer struct{}

func (t *DataFormatTransformer) Transform(value interface{}) (interface{}, error) {
    // 数据格式转换逻辑
    return value, nil
}

func (t *DataFormatTransformer) GetName() string {
    return "data_format"
}
```

## 使用示例

### Rust示例

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建语义映射引擎
    let engine = SemanticMappingEngine::new();
    
    // 注册语义模型
    let source_model = SemanticModel {
        id: "opc_ua_sensor".to_string(),
        name: "OPC UA Sensor Model".to_string(),
        version: "1.0".to_string(),
        namespace: "http://example.com/opc_ua".to_string(),
        properties: HashMap::new(),
        relationships: HashMap::new(),
    };
    engine.register_model(source_model).await?;
    
    // 注册映射规则
    let rule = MappingRule {
        id: "temp_mapping".to_string(),
        source_model: "opc_ua_sensor".to_string(),
        target_model: "mqtt_sensor".to_string(),
        transformations: vec![
            Transformation::Direct("temperature".to_string(), "temp".to_string()),
            Transformation::Scale("temperature".to_string(), "temp_f".to_string(), 9.0/5.0),
        ],
        conditions: vec![],
    };
    engine.register_rule(rule).await?;
    
    // 执行映射
    let source_data = {
        let mut data = HashMap::new();
        data.insert("temperature".to_string(), serde_json::Value::Number(
            serde_json::Number::from_f64(25.0).unwrap()
        ));
        data
    };
    
    let result = engine.map_data(
        source_data,
        "opc_ua_sensor",
        "mqtt_sensor"
    ).await?;
    
    println!("映射结果: {:?}", result);
    Ok(())
}
```

### Go示例

```go
func main() {
    // 创建语义映射引擎
    engine := NewSemanticMappingEngine()
    
    // 注册语义模型
    sourceModel := SemanticModel{
        ID:        "opc_ua_sensor",
        Name:      "OPC UA Sensor Model",
        Version:   "1.0",
        Namespace: "http://example.com/opc_ua",
        Properties: map[string]SemanticProperty{
            "temperature": {
                Name:         "temperature",
                SemanticType: SemanticTypeTemperature,
                Unit:         "°C",
            },
        },
        Relationships: make(map[string]string),
    }
    engine.RegisterModel(sourceModel)
    
    // 注册映射规则
    rule := MappingRule{
        ID:          "temp_mapping",
        SourceModel: "opc_ua_sensor",
        TargetModel: "mqtt_sensor",
        Transformations: []Transformation{
            {
                Type:        "direct",
                SourceField: "temperature",
                TargetField: "temp",
            },
            {
                Type:        "scale",
                SourceField: "temperature",
                TargetField: "temp_f",
                Parameter:   "1.8",
            },
        },
    }
    engine.RegisterRule(rule)
    
    // 执行映射
    sourceData := map[string]interface{}{
        "temperature": 25.0,
    }
    
    result, err := engine.MapData(sourceData, "opc_ua_sensor", "mqtt_sensor")
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Printf("映射结果: %+v\n", result)
}
```

## 总结

语义映射引擎提供了：

1. **语义模型管理**：定义和管理不同协议的语义模型
2. **映射规则引擎**：支持多种数据转换和映射规则
3. **可扩展转换器**：支持自定义数据转换逻辑
4. **高性能处理**：异步处理和并发安全
5. **跨语言支持**：Rust和Go双语言实现

这个实现为IoT系统的语义互操作提供了坚实的基础，支持不同协议和设备之间的数据转换和语义映射。
