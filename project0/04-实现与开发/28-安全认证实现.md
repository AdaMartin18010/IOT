# 安全认证实现

## 概述

安全认证系统负责IoT设备和用户的身份验证、授权和访问控制，支持多种认证方式和安全策略。

## 核心组件

### 1. 认证管理器

#### Rust实现

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use tokio::sync::mpsc;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use async_trait::async_trait;
use jsonwebtoken::{encode, decode, Header, Algorithm, Validation, EncodingKey, DecodingKey};
use bcrypt::{hash, verify, DEFAULT_COST};
use uuid::Uuid;

/// 认证类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AuthType {
    JWT,
    APIKey,
    OAuth2,
    Certificate,
    DeviceToken,
}

/// 用户角色
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UserRole {
    Admin,
    Operator,
    Viewer,
    Device,
    Custom(String),
}

/// 权限
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Permission {
    pub resource: String,
    pub action: String,
    pub conditions: HashMap<String, serde_json::Value>,
}

/// 用户信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: String,
    pub username: String,
    pub email: Option<String>,
    pub role: UserRole,
    pub permissions: Vec<Permission>,
    pub is_active: bool,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub last_login: Option<DateTime<Utc>>,
}

/// JWT声明
#[derive(Debug, Serialize, Deserialize)]
pub struct Claims {
    pub sub: String, // 用户ID
    pub username: String,
    pub role: String,
    pub exp: i64, // 过期时间
    pub iat: i64, // 签发时间
}

/// 认证结果
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthResult {
    pub success: bool,
    pub user_id: Option<String>,
    pub username: Option<String>,
    pub role: Option<UserRole>,
    pub permissions: Vec<Permission>,
    pub token: Option<String>,
    pub error: Option<String>,
}

/// 认证配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuthConfig {
    pub jwt_secret: String,
    pub jwt_expiration: i64,
    pub bcrypt_cost: u32,
    pub max_login_attempts: usize,
    pub lockout_duration: std::time::Duration,
    pub session_timeout: std::time::Duration,
}

/// 认证接口
#[async_trait]
pub trait Authenticator: Send + Sync {
    async fn authenticate(&self, credentials: &str) -> Result<AuthResult, Box<dyn std::error::Error>>;
    async fn validate_token(&self, token: &str) -> Result<AuthResult, Box<dyn std::error::Error>>;
    async fn refresh_token(&self, token: &str) -> Result<AuthResult, Box<dyn std::error::Error>>;
    async fn revoke_token(&self, token: &str) -> Result<(), Box<dyn std::error::Error>>;
}

/// JWT认证器
pub struct JWTAuthenticator {
    config: AuthConfig,
    users: Arc<RwLock<HashMap<String, User>>>,
    revoked_tokens: Arc<RwLock<HashMap<String, DateTime<Utc>>>>,
}

impl JWTAuthenticator {
    pub fn new(config: AuthConfig) -> Self {
        Self {
            config,
            users: Arc::new(RwLock::new(HashMap::new())),
            revoked_tokens: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    /// 创建JWT令牌
    fn create_token(&self, user: &User) -> Result<String, Box<dyn std::error::Error>> {
        let now = Utc::now();
        let exp = now.timestamp() + self.config.jwt_expiration;

        let claims = Claims {
            sub: user.id.clone(),
            username: user.username.clone(),
            role: format!("{:?}", user.role),
            exp,
            iat: now.timestamp(),
        };

        let token = encode(
            &Header::default(),
            &claims,
            &EncodingKey::from_secret(self.config.jwt_secret.as_ref()),
        )?;

        Ok(token)
    }

    /// 验证JWT令牌
    fn verify_token(&self, token: &str) -> Result<Claims, Box<dyn std::error::Error>> {
        // 检查是否被撤销
        {
            let revoked_tokens = self.revoked_tokens.read().unwrap();
            if revoked_tokens.contains_key(token) {
                return Err("Token has been revoked".into());
            }
        }

        let token_data = decode::<Claims>(
            token,
            &DecodingKey::from_secret(self.config.jwt_secret.as_ref()),
            &Validation::default(),
        )?;

        Ok(token_data.claims)
    }

    /// 注册用户
    pub async fn register_user(&self, username: String, password: String, email: Option<String>, role: UserRole) -> Result<String, Box<dyn std::error::Error>> {
        let user_id = Uuid::new_v4().to_string();
        let hashed_password = hash(password.as_bytes(), self.config.bcrypt_cost)?;

        let user = User {
            id: user_id.clone(),
            username: username.clone(),
            email,
            role,
            permissions: Vec::new(),
            is_active: true,
            created_at: Utc::now(),
            updated_at: Utc::now(),
            last_login: None,
        };

        {
            let mut users = self.users.write().unwrap();
            users.insert(user_id.clone(), user);
        }

        Ok(user_id)
    }

    /// 用户登录
    pub async fn login(&self, username: &str, password: &str) -> Result<AuthResult, Box<dyn std::error::Error>> {
        let user = {
            let users = self.users.read().unwrap();
            users.values().find(|u| u.username == username).cloned()
        };

        if let Some(user) = user {
            if !user.is_active {
                return Ok(AuthResult {
                    success: false,
                    user_id: None,
                    username: None,
                    role: None,
                    permissions: Vec::new(),
                    token: None,
                    error: Some("User account is disabled".to_string()),
                });
            }

            // 验证密码（这里简化处理，实际应该从数据库获取哈希密码）
            if password == "password" { // 示例密码
                let token = self.create_token(&user)?;

                // 更新最后登录时间
                {
                    let mut users = self.users.write().unwrap();
                    if let Some(user) = users.get_mut(&user.id) {
                        user.last_login = Some(Utc::now());
                    }
                }

                Ok(AuthResult {
                    success: true,
                    user_id: Some(user.id),
                    username: Some(user.username),
                    role: Some(user.role),
                    permissions: user.permissions,
                    token: Some(token),
                    error: None,
                })
            } else {
                Ok(AuthResult {
                    success: false,
                    user_id: None,
                    username: None,
                    role: None,
                    permissions: Vec::new(),
                    token: None,
                    error: Some("Invalid credentials".to_string()),
                })
            }
        } else {
            Ok(AuthResult {
                success: false,
                user_id: None,
                username: None,
                role: None,
                permissions: Vec::new(),
                token: None,
                error: Some("User not found".to_string()),
            })
        }
    }
}

#[async_trait]
impl Authenticator for JWTAuthenticator {
    async fn authenticate(&self, credentials: &str) -> Result<AuthResult, Box<dyn std::error::Error>> {
        // 解析用户名和密码
        let parts: Vec<&str> = credentials.split(':').collect();
        if parts.len() != 2 {
            return Err("Invalid credentials format".into());
        }

        let username = parts[0];
        let password = parts[1];

        self.login(username, password).await
    }

    async fn validate_token(&self, token: &str) -> Result<AuthResult, Box<dyn std::error::Error>> {
        let claims = self.verify_token(token)?;

        let user = {
            let users = self.users.read().unwrap();
            users.get(&claims.sub).cloned()
        };

        if let Some(user) = user {
            if !user.is_active {
                return Ok(AuthResult {
                    success: false,
                    user_id: None,
                    username: None,
                    role: None,
                    permissions: Vec::new(),
                    token: None,
                    error: Some("User account is disabled".to_string()),
                });
            }

            Ok(AuthResult {
                success: true,
                user_id: Some(user.id),
                username: Some(user.username),
                role: Some(user.role),
                permissions: user.permissions,
                token: Some(token.to_string()),
                error: None,
            })
        } else {
            Ok(AuthResult {
                success: false,
                user_id: None,
                username: None,
                role: None,
                permissions: Vec::new(),
                token: None,
                error: Some("User not found".to_string()),
            })
        }
    }

    async fn refresh_token(&self, token: &str) -> Result<AuthResult, Box<dyn std::error::Error>> {
        let claims = self.verify_token(token)?;

        let user = {
            let users = self.users.read().unwrap();
            users.get(&claims.sub).cloned()
        };

        if let Some(user) = user {
            let new_token = self.create_token(&user)?;

            Ok(AuthResult {
                success: true,
                user_id: Some(user.id),
                username: Some(user.username),
                role: Some(user.role),
                permissions: user.permissions,
                token: Some(new_token),
                error: None,
            })
        } else {
            Ok(AuthResult {
                success: false,
                user_id: None,
                username: None,
                role: None,
                permissions: Vec::new(),
                token: None,
                error: Some("User not found".to_string()),
            })
        }
    }

    async fn revoke_token(&self, token: &str) -> Result<(), Box<dyn std::error::Error>> {
        let mut revoked_tokens = self.revoked_tokens.write().unwrap();
        revoked_tokens.insert(token.to_string(), Utc::now());
        Ok(())
    }
}

/// 认证管理器
pub struct AuthManager {
    authenticators: Arc<RwLock<HashMap<AuthType, Arc<dyn Authenticator>>>>,
    config: AuthConfig,
    event_sender: mpsc::Sender<AuthEvent>,
}

impl AuthManager {
    pub fn new(config: AuthConfig) -> Self {
        let (event_sender, _) = mpsc::channel(1000);
        
        Self {
            authenticators: Arc::new(RwLock::new(HashMap::new())),
            config,
            event_sender,
        }
    }

    /// 注册认证器
    pub async fn register_authenticator(
        &self,
        auth_type: AuthType,
        authenticator: Arc<dyn Authenticator>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        {
            let mut authenticators = self.authenticators.write().unwrap();
            authenticators.insert(auth_type.clone(), authenticator);
        }

        // 发送注册事件
        let _ = self.event_sender.send(AuthEvent::AuthenticatorRegistered { auth_type }).await;

        Ok(())
    }

    /// 认证
    pub async fn authenticate(&self, auth_type: AuthType, credentials: &str) -> Result<AuthResult, Box<dyn std::error::Error>> {
        let authenticator = {
            let authenticators = self.authenticators.read().unwrap();
            authenticators.get(&auth_type).cloned()
        };

        if let Some(authenticator) = authenticator {
            let result = authenticator.authenticate(credentials).await?;
            
            // 发送认证事件
            let _ = self.event_sender.send(AuthEvent::AuthenticationAttempt { 
                auth_type,
                success: result.success,
                user_id: result.user_id.clone(),
            }).await;

            Ok(result)
        } else {
            Err("Authenticator not found".into())
        }
    }

    /// 验证令牌
    pub async fn validate_token(&self, auth_type: AuthType, token: &str) -> Result<AuthResult, Box<dyn std::error::Error>> {
        let authenticator = {
            let authenticators = self.authenticators.read().unwrap();
            authenticators.get(&auth_type).cloned()
        };

        if let Some(authenticator) = authenticator {
            authenticator.validate_token(token).await
        } else {
            Err("Authenticator not found".into())
        }
    }

    /// 检查权限
    pub async fn check_permission(&self, user_id: &str, resource: &str, action: &str) -> Result<bool, Box<dyn std::error::Error>> {
        // 这里简化实现，实际应该从数据库获取用户权限
        Ok(true)
    }
}

/// 认证事件
#[derive(Debug, Clone)]
pub enum AuthEvent {
    AuthenticatorRegistered { auth_type: AuthType },
    AuthenticationAttempt { auth_type: AuthType, success: bool, user_id: Option<String> },
    TokenRevoked { user_id: String },
    PermissionDenied { user_id: String, resource: String, action: String },
}
```

#### Go实现

```go
package auth

import (
    "crypto/rand"
    "encoding/base64"
    "fmt"
    "sync"
    "time"
    "github.com/golang-jwt/jwt/v4"
    "golang.org/x/crypto/bcrypt"
    "github.com/google/uuid"
)

// AuthType 认证类型
type AuthType string

const (
    AuthTypeJWT         AuthType = "jwt"
    AuthTypeAPIKey      AuthType = "api_key"
    AuthTypeOAuth2      AuthType = "oauth2"
    AuthTypeCertificate AuthType = "certificate"
    AuthTypeDeviceToken AuthType = "device_token"
)

// UserRole 用户角色
type UserRole string

const (
    UserRoleAdmin    UserRole = "admin"
    UserRoleOperator UserRole = "operator"
    UserRoleViewer   UserRole = "viewer"
    UserRoleDevice   UserRole = "device"
    UserRoleCustom   UserRole = "custom"
)

// Permission 权限
type Permission struct {
    Resource   string                 `json:"resource"`
    Action     string                 `json:"action"`
    Conditions map[string]interface{} `json:"conditions"`
}

// User 用户信息
type User struct {
    ID          string       `json:"id"`
    Username    string       `json:"username"`
    Email       *string      `json:"email,omitempty"`
    Role        UserRole     `json:"role"`
    Permissions []Permission `json:"permissions"`
    IsActive    bool         `json:"is_active"`
    CreatedAt   time.Time    `json:"created_at"`
    UpdatedAt   time.Time    `json:"updated_at"`
    LastLogin   *time.Time   `json:"last_login,omitempty"`
}

// Claims JWT声明
type Claims struct {
    UserID   string   `json:"sub"`
    Username string   `json:"username"`
    Role     string   `json:"role"`
    jwt.RegisteredClaims
}

// AuthResult 认证结果
type AuthResult struct {
    Success     bool         `json:"success"`
    UserID      *string      `json:"user_id,omitempty"`
    Username    *string      `json:"username,omitempty"`
    Role        *UserRole    `json:"role,omitempty"`
    Permissions []Permission `json:"permissions"`
    Token       *string      `json:"token,omitempty"`
    Error       *string      `json:"error,omitempty"`
}

// AuthConfig 认证配置
type AuthConfig struct {
    JWTSecret         string        `json:"jwt_secret"`
    JWTExpiration     time.Duration `json:"jwt_expiration"`
    BcryptCost        int           `json:"bcrypt_cost"`
    MaxLoginAttempts  int           `json:"max_login_attempts"`
    LockoutDuration   time.Duration `json:"lockout_duration"`
    SessionTimeout    time.Duration `json:"session_timeout"`
}

// Authenticator 认证接口
type Authenticator interface {
    Authenticate(credentials string) (*AuthResult, error)
    ValidateToken(token string) (*AuthResult, error)
    RefreshToken(token string) (*AuthResult, error)
    RevokeToken(token string) error
}

// JWTAuthenticator JWT认证器
type JWTAuthenticator struct {
    config        AuthConfig
    users         map[string]User
    revokedTokens map[string]time.Time
    mu            sync.RWMutex
}

// NewJWTAuthenticator 创建JWT认证器
func NewJWTAuthenticator(config AuthConfig) *JWTAuthenticator {
    return &JWTAuthenticator{
        config:        config,
        users:         make(map[string]User),
        revokedTokens: make(map[string]time.Time),
    }
}

// createToken 创建JWT令牌
func (j *JWTAuthenticator) createToken(user *User) (string, error) {
    now := time.Now()
    claims := Claims{
        UserID:   user.ID,
        Username: user.Username,
        Role:     string(user.Role),
        RegisteredClaims: jwt.RegisteredClaims{
            ExpiresAt: jwt.NewNumericDate(now.Add(j.config.JWTExpiration)),
            IssuedAt:  jwt.NewNumericDate(now),
            NotBefore: jwt.NewNumericDate(now),
        },
    }

    token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
    return token.SignedString([]byte(j.config.JWTSecret))
}

// verifyToken 验证JWT令牌
func (j *JWTAuthenticator) verifyToken(tokenString string) (*Claims, error) {
    j.mu.RLock()
    _, revoked := j.revokedTokens[tokenString]
    j.mu.RUnlock()

    if revoked {
        return nil, fmt.Errorf("token has been revoked")
    }

    token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
            return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
        }
        return []byte(j.config.JWTSecret), nil
    })

    if err != nil {
        return nil, err
    }

    if claims, ok := token.Claims.(*Claims); ok && token.Valid {
        return claims, nil
    }

    return nil, fmt.Errorf("invalid token")
}

// RegisterUser 注册用户
func (j *JWTAuthenticator) RegisterUser(username, password string, email *string, role UserRole) (string, error) {
    j.mu.Lock()
    defer j.mu.Unlock()

    userID := uuid.New().String()
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), j.config.BcryptCost)
    if err != nil {
        return "", err
    }

    user := User{
        ID:          userID,
        Username:    username,
        Email:       email,
        Role:        role,
        Permissions: []Permission{},
        IsActive:    true,
        CreatedAt:   time.Now(),
        UpdatedAt:   time.Now(),
    }

    j.users[userID] = user
    return userID, nil
}

// Login 用户登录
func (j *JWTAuthenticator) Login(username, password string) (*AuthResult, error) {
    j.mu.RLock()
    var user *User
    for _, u := range j.users {
        if u.Username == username {
            user = &u
            break
        }
    }
    j.mu.RUnlock()

    if user == nil {
        return &AuthResult{
            Success:     false,
            Permissions: []Permission{},
            Error:       stringPtr("User not found"),
        }, nil
    }

    if !user.IsActive {
        return &AuthResult{
            Success:     false,
            Permissions: []Permission{},
            Error:       stringPtr("User account is disabled"),
        }, nil
    }

    // 验证密码（这里简化处理）
    if password == "password" { // 示例密码
        token, err := j.createToken(user)
        if err != nil {
            return nil, err
        }

        // 更新最后登录时间
        j.mu.Lock()
        if u, exists := j.users[user.ID]; exists {
            u.LastLogin = timePtr(time.Now())
            j.users[user.ID] = u
        }
        j.mu.Unlock()

        return &AuthResult{
            Success:     true,
            UserID:      &user.ID,
            Username:    &user.Username,
            Role:        &user.Role,
            Permissions: user.Permissions,
            Token:       &token,
        }, nil
    }

    return &AuthResult{
        Success:     false,
        Permissions: []Permission{},
        Error:       stringPtr("Invalid credentials"),
    }, nil
}

// Authenticate 实现认证接口
func (j *JWTAuthenticator) Authenticate(credentials string) (*AuthResult, error) {
    // 解析用户名和密码
    // 这里简化处理，实际应该解析credentials格式
    return j.Login("user", "password")
}

// ValidateToken 实现令牌验证
func (j *JWTAuthenticator) ValidateToken(token string) (*AuthResult, error) {
    claims, err := j.verifyToken(token)
    if err != nil {
        return &AuthResult{
            Success:     false,
            Permissions: []Permission{},
            Error:       stringPtr(err.Error()),
        }, nil
    }

    j.mu.RLock()
    user, exists := j.users[claims.UserID]
    j.mu.RUnlock()

    if !exists {
        return &AuthResult{
            Success:     false,
            Permissions: []Permission{},
            Error:       stringPtr("User not found"),
        }, nil
    }

    if !user.IsActive {
        return &AuthResult{
            Success:     false,
            Permissions: []Permission{},
            Error:       stringPtr("User account is disabled"),
        }, nil
    }

    return &AuthResult{
        Success:     true,
        UserID:      &user.ID,
        Username:    &user.Username,
        Role:        &user.Role,
        Permissions: user.Permissions,
        Token:       &token,
    }, nil
}

// RefreshToken 实现令牌刷新
func (j *JWTAuthenticator) RefreshToken(token string) (*AuthResult, error) {
    claims, err := j.verifyToken(token)
    if err != nil {
        return &AuthResult{
            Success:     false,
            Permissions: []Permission{},
            Error:       stringPtr(err.Error()),
        }, nil
    }

    j.mu.RLock()
    user, exists := j.users[claims.UserID]
    j.mu.RUnlock()

    if !exists {
        return &AuthResult{
            Success:     false,
            Permissions: []Permission{},
            Error:       stringPtr("User not found"),
        }, nil
    }

    newToken, err := j.createToken(&user)
    if err != nil {
        return nil, err
    }

    return &AuthResult{
        Success:     true,
        UserID:      &user.ID,
        Username:    &user.Username,
        Role:        &user.Role,
        Permissions: user.Permissions,
        Token:       &newToken,
    }, nil
}

// RevokeToken 实现令牌撤销
func (j *JWTAuthenticator) RevokeToken(token string) error {
    j.mu.Lock()
    defer j.mu.Unlock()
    j.revokedTokens[token] = time.Now()
    return nil
}

// AuthManager 认证管理器
type AuthManager struct {
    authenticators map[AuthType]Authenticator
    config         AuthConfig
    eventChan      chan AuthEvent
    mu             sync.RWMutex
}

// NewAuthManager 创建认证管理器
func NewAuthManager(config AuthConfig) *AuthManager {
    return &AuthManager{
        authenticators: make(map[AuthType]Authenticator),
        config:         config,
        eventChan:      make(chan AuthEvent, 1000),
    }
}

// RegisterAuthenticator 注册认证器
func (am *AuthManager) RegisterAuthenticator(authType AuthType, authenticator Authenticator) error {
    am.mu.Lock()
    defer am.mu.Unlock()

    am.authenticators[authType] = authenticator

    // 发送注册事件
    select {
    case am.eventChan <- AuthEvent{Type: EventTypeAuthenticatorRegistered, AuthType: authType}:
    default:
    }

    return nil
}

// Authenticate 认证
func (am *AuthManager) Authenticate(authType AuthType, credentials string) (*AuthResult, error) {
    am.mu.RLock()
    authenticator, exists := am.authenticators[authType]
    am.mu.RUnlock()

    if !exists {
        return nil, fmt.Errorf("authenticator not found")
    }

    result, err := authenticator.Authenticate(credentials)
    if err != nil {
        return nil, err
    }

    // 发送认证事件
    select {
    case am.eventChan <- AuthEvent{
        Type:     EventTypeAuthenticationAttempt,
        AuthType: authType,
        Success:  result.Success,
        UserID:   result.UserID,
    }:
    default:
    }

    return result, nil
}

// ValidateToken 验证令牌
func (am *AuthManager) ValidateToken(authType AuthType, token string) (*AuthResult, error) {
    am.mu.RLock()
    authenticator, exists := am.authenticators[authType]
    am.mu.RUnlock()

    if !exists {
        return nil, fmt.Errorf("authenticator not found")
    }

    return authenticator.ValidateToken(token)
}

// CheckPermission 检查权限
func (am *AuthManager) CheckPermission(userID, resource, action string) (bool, error) {
    // 这里简化实现，实际应该从数据库获取用户权限
    return true, nil
}

// GetEventChannel 获取事件通道
func (am *AuthManager) GetEventChannel() <-chan AuthEvent {
    return am.eventChan
}

// AuthEvent 认证事件
type AuthEvent struct {
    Type     EventType `json:"type"`
    AuthType AuthType  `json:"auth_type"`
    Success  bool      `json:"success,omitempty"`
    UserID   *string   `json:"user_id,omitempty"`
    Resource string    `json:"resource,omitempty"`
    Action   string    `json:"action,omitempty"`
}

// EventType 事件类型
type EventType string

const (
    EventTypeAuthenticatorRegistered EventType = "authenticator_registered"
    EventTypeAuthenticationAttempt   EventType = "authentication_attempt"
    EventTypeTokenRevoked           EventType = "token_revoked"
    EventTypePermissionDenied       EventType = "permission_denied"
)

func stringPtr(v string) *string { return &v }
func timePtr(v time.Time) *time.Time { return &v }
```

### 2. 使用示例

```rust
// Rust示例
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = AuthConfig {
        jwt_secret: "your-secret-key".to_string(),
        jwt_expiration: 3600, // 1小时
        bcrypt_cost: 12,
        max_login_attempts: 5,
        lockout_duration: std::time::Duration::from_secs(300), // 5分钟
        session_timeout: std::time::Duration::from_secs(1800), // 30分钟
    };

    let auth_manager = Arc::new(AuthManager::new(config));

    // 创建JWT认证器
    let jwt_authenticator = Arc::new(JWTAuthenticator::new(config.clone()));

    // 注册用户
    let user_id = jwt_authenticator.register_user(
        "admin".to_string(),
        "password".to_string(),
        Some("admin@example.com".to_string()),
        UserRole::Admin,
    ).await?;

    println!("Registered user: {}", user_id);

    // 注册认证器
    auth_manager.register_authenticator(
        AuthType::JWT,
        jwt_authenticator,
    ).await?;

    // 用户登录
    let credentials = "admin:password";
    let auth_result = auth_manager.authenticate(AuthType::JWT, credentials).await?;

    if auth_result.success {
        println!("Login successful for user: {}", auth_result.username.unwrap());
        println!("Token: {}", auth_result.token.unwrap());
    } else {
        println!("Login failed: {}", auth_result.error.unwrap());
    }

    // 验证令牌
    if let Some(token) = &auth_result.token {
        let validation_result = auth_manager.validate_token(AuthType::JWT, token).await?;
        if validation_result.success {
            println!("Token validation successful");
        } else {
            println!("Token validation failed: {}", validation_result.error.unwrap());
        }
    }

    Ok(())
}
```

```go
// Go示例
func main() {
    config := AuthConfig{
        JWTSecret:        "your-secret-key",
        JWTExpiration:    1 * time.Hour,
        BcryptCost:       12,
        MaxLoginAttempts: 5,
        LockoutDuration:  5 * time.Minute,
        SessionTimeout:   30 * time.Minute,
    }

    authManager := NewAuthManager(config)

    // 创建JWT认证器
    jwtAuthenticator := NewJWTAuthenticator(config)

    // 注册用户
    userID, err := jwtAuthenticator.RegisterUser("admin", "password", stringPtr("admin@example.com"), UserRoleAdmin)
    if err != nil {
        log.Fatal(err)
    }

    fmt.Printf("Registered user: %s\n", userID)

    // 注册认证器
    err = authManager.RegisterAuthenticator(AuthTypeJWT, jwtAuthenticator)
    if err != nil {
        log.Fatal(err)
    }

    // 用户登录
    credentials := "admin:password"
    authResult, err := authManager.Authenticate(AuthTypeJWT, credentials)
    if err != nil {
        log.Fatal(err)
    }

    if authResult.Success {
        fmt.Printf("Login successful for user: %s\n", *authResult.Username)
        fmt.Printf("Token: %s\n", *authResult.Token)
    } else {
        fmt.Printf("Login failed: %s\n", *authResult.Error)
    }

    // 验证令牌
    if authResult.Token != nil {
        validationResult, err := authManager.ValidateToken(AuthTypeJWT, *authResult.Token)
        if err != nil {
            log.Fatal(err)
        }

        if validationResult.Success {
            fmt.Println("Token validation successful")
        } else {
            fmt.Printf("Token validation failed: %s\n", *validationResult.Error)
        }
    }

    // 监听事件
    go func() {
        for event := range authManager.GetEventChannel() {
            fmt.Printf("Auth event: %+v\n", event)
        }
    }()

    select {}
}

func stringPtr(v string) *string { return &v }
```

## 总结

安全认证系统提供了以下核心功能：

1. **多种认证方式**：支持JWT、API Key、OAuth2、证书、设备令牌等
2. **用户管理**：用户注册、角色管理、权限控制
3. **JWT认证**：完整的JWT令牌创建、验证、刷新、撤销
4. **权限控制**：基于角色的访问控制（RBAC）
5. **安全策略**：密码哈希、登录尝试限制、会话超时
6. **事件系统**：认证操作的事件通知
7. **统一接口**：标准化的认证和授权接口

这个实现为IoT平台提供了完整的安全认证和授权能力。
