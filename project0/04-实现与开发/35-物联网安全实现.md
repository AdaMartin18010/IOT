# 物联网安全实现

## 概述

物联网安全系统提供身份认证、访问控制、数据加密、安全监控和威胁检测等核心安全功能。

## 核心架构

### 1. 身份认证系统

```rust
pub struct SecurityManager {
    auth_service: Arc<AuthenticationService>,
    access_control: Arc<AccessControlService>,
    encryption_service: Arc<EncryptionService>,
    threat_detector: Arc<ThreatDetector>,
}

pub struct AuthenticationService {
    users: Arc<RwLock<HashMap<String, User>>>,
    tokens: Arc<RwLock<HashMap<String, TokenInfo>>>,
    jwt_secret: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: String,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub roles: Vec<Role>,
    pub status: UserStatus,
    pub created_at: DateTime<Utc>,
    pub last_login: Option<DateTime<Utc>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UserStatus {
    Active,
    Inactive,
    Locked,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Role {
    pub id: String,
    pub name: String,
    pub permissions: Vec<Permission>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Permission {
    pub resource: String,
    pub action: String,
}

impl AuthenticationService {
    pub fn new(jwt_secret: String) -> Self {
        Self {
            users: Arc::new(RwLock::new(HashMap::new())),
            tokens: Arc::new(RwLock::new(HashMap::new())),
            jwt_secret,
        }
    }

    // 用户注册
    pub async fn register_user(&self, username: &str, email: &str, password: &str) -> Result<User, AuthError> {
        let mut users = self.users.write().await;
        
        if users.values().any(|u| u.username == username || u.email == email) {
            return Err(AuthError::UserAlreadyExists);
        }
        
        let password_hash = hash_password(password)?;
        
        let user = User {
            id: Uuid::new_v4().to_string(),
            username: username.to_string(),
            email: email.to_string(),
            password_hash,
            roles: Vec::new(),
            status: UserStatus::Active,
            created_at: Utc::now(),
            last_login: None,
        };
        
        users.insert(user.id.clone(), user.clone());
        Ok(user)
    }

    // 用户登录
    pub async fn login(&self, username: &str, password: &str) -> Result<TokenInfo, AuthError> {
        let mut users = self.users.write().await;
        
        let user = users.values_mut()
            .find(|u| u.username == username || u.email == username)
            .ok_or(AuthError::InvalidCredentials)?;
        
        if !verify_password(password, &user.password_hash)? {
            return Err(AuthError::InvalidCredentials);
        }
        
        user.last_login = Some(Utc::now());
        
        let token_info = self.generate_token(user).await?;
        
        let mut tokens = self.tokens.write().await;
        tokens.insert(token_info.token.clone(), token_info.clone());
        
        Ok(token_info)
    }

    // 生成JWT令牌
    async fn generate_token(&self, user: &User) -> Result<TokenInfo, AuthError> {
        let now = Utc::now();
        let expires_at = now + Duration::from_hours(24);
        
        let claims = Claims {
            sub: user.id.clone(),
            username: user.username.clone(),
            exp: expires_at.timestamp() as usize,
            iat: now.timestamp() as usize,
        };
        
        let token = encode(&Header::default(), &claims, &EncodingKey::from_secret(self.jwt_secret.as_ref()))?;
        let refresh_token = Uuid::new_v4().to_string();
        
        Ok(TokenInfo {
            token,
            user_id: user.id.clone(),
            issued_at: now,
            expires_at,
            refresh_token,
        })
    }
}
```

### 2. 访问控制系统

```rust
pub struct AccessControlService {
    policies: Arc<RwLock<HashMap<String, Policy>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Policy {
    pub id: String,
    pub name: String,
    pub subjects: Vec<String>,
    pub resources: Vec<String>,
    pub actions: Vec<String>,
    pub effect: PolicyEffect,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum PolicyEffect {
    Allow,
    Deny,
}

impl AccessControlService {
    pub fn new() -> Self {
        Self {
            policies: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    // 检查访问权限
    pub async fn check_permission(&self, user: &User, resource: &str, action: &str) -> Result<bool, AccessError> {
        let policies = self.policies.read().await;
        
        let applicable_policies: Vec<&Policy> = policies.values()
            .filter(|policy| {
                self.is_policy_applicable(policy, user, resource, action).await
            })
            .collect();
        
        for policy in applicable_policies {
            if matches!(policy.effect, PolicyEffect::Allow) {
                return Ok(true);
            } else {
                return Ok(false);
            }
        }
        
        Ok(false)
    }

    // 检查策略是否适用
    async fn is_policy_applicable(&self, policy: &Policy, user: &User, resource: &str, action: &str) -> bool {
        // 检查主体
        let subject_match = policy.subjects.iter().any(|subject| {
            subject == "*" || 
            subject == &user.id ||
            user.roles.iter().any(|role| &role.name == subject)
        });
        
        if !subject_match {
            return false;
        }
        
        // 检查资源
        let resource_match = policy.resources.iter().any(|r| {
            r == "*" || r == resource
        });
        
        if !resource_match {
            return false;
        }
        
        // 检查操作
        let action_match = policy.actions.iter().any(|a| {
            a == "*" || a == action
        });
        
        action_match
    }
}
```

### 3. 数据加密服务

```rust
pub struct EncryptionService {
    key_manager: Arc<KeyManager>,
}

#[derive(Debug, Clone)]
pub struct EncryptedData {
    pub ciphertext: Vec<u8>,
    pub nonce: Vec<u8>,
    pub algorithm: String,
    pub key_id: String,
}

impl EncryptionService {
    pub fn new() -> Self {
        Self {
            key_manager: Arc::new(KeyManager::new()),
        }
    }

    // 加密数据
    pub async fn encrypt(&self, plaintext: &[u8], key_id: Option<&str>) -> Result<EncryptedData, EncryptionError> {
        let key_id = key_id.unwrap_or("default");
        let key = self.key_manager.get_key(key_id).await?;
        
        let cipher = Aes256Gcm::new_from_slice(&key)
            .map_err(|_| EncryptionError::InvalidKey)?;
        
        let nonce = Aes256Gcm::generate_nonce(&mut OsRng);
        
        let ciphertext = cipher.encrypt(&nonce, plaintext)
            .map_err(|_| EncryptionError::EncryptionFailed)?;
        
        Ok(EncryptedData {
            ciphertext,
            nonce: nonce.to_vec(),
            algorithm: "AES256-GCM".to_string(),
            key_id: key_id.to_string(),
        })
    }

    // 解密数据
    pub async fn decrypt(&self, encrypted_data: &EncryptedData) -> Result<Vec<u8>, EncryptionError> {
        let key = self.key_manager.get_key(&encrypted_data.key_id).await?;
        
        let cipher = Aes256Gcm::new_from_slice(&key)
            .map_err(|_| EncryptionError::InvalidKey)?;
        
        let nonce = Aes256GcmNonce::from_slice(&encrypted_data.nonce);
        
        let plaintext = cipher.decrypt(nonce, encrypted_data.ciphertext.as_ref())
            .map_err(|_| EncryptionError::DecryptionFailed)?;
        
        Ok(plaintext)
    }
}
```

### 4. 威胁检测系统

```rust
pub struct ThreatDetector {
    rules: Vec<ThreatRule>,
    alert_sender: mpsc::Sender<SecurityAlert>,
}

#[derive(Debug, Clone)]
pub struct ThreatRule {
    pub id: String,
    pub name: String,
    pub pattern: ThreatPattern,
    pub severity: ThreatSeverity,
    pub action: ThreatAction,
}

#[derive(Debug, Clone)]
pub enum ThreatPattern {
    FailedLoginAttempts(u32, Duration),
    BruteForceAttack(u32, Duration),
    SuspiciousIP(String),
}

#[derive(Debug, Clone)]
pub enum ThreatSeverity {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone)]
pub enum ThreatAction {
    Log,
    Alert,
    Block,
    Quarantine,
}

#[derive(Debug, Clone)]
pub struct SecurityEvent {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub event_type: String,
    pub user_id: Option<String>,
    pub ip_address: String,
    pub resource: String,
    pub action: String,
    pub details: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub struct SecurityAlert {
    pub id: String,
    pub timestamp: DateTime<Utc>,
    pub threat_type: String,
    pub severity: ThreatSeverity,
    pub description: String,
    pub affected_resources: Vec<String>,
    pub recommended_actions: Vec<String>,
}

impl ThreatDetector {
    pub fn new() -> Self {
        let (alert_sender, _alert_receiver) = mpsc::channel();
        
        Self {
            rules: vec![
                ThreatRule {
                    id: "failed-login".to_string(),
                    name: "失败登录检测".to_string(),
                    pattern: ThreatPattern::FailedLoginAttempts(5, Duration::from_minutes(10)),
                    severity: ThreatSeverity::Medium,
                    action: ThreatAction::Alert,
                },
                ThreatRule {
                    id: "brute-force".to_string(),
                    name: "暴力破解检测".to_string(),
                    pattern: ThreatPattern::BruteForceAttack(10, Duration::from_minutes(5)),
                    severity: ThreatSeverity::High,
                    action: ThreatAction::Block,
                },
            ],
            alert_sender,
        }
    }

    // 分析安全事件
    pub async fn analyze_event(&self, event: SecurityEvent) -> Result<Vec<SecurityAlert>, ThreatError> {
        let mut alerts = Vec::new();
        
        for rule in &self.rules {
            if self.matches_pattern(&rule.pattern, &event).await {
                let alert = SecurityAlert {
                    id: Uuid::new_v4().to_string(),
                    timestamp: Utc::now(),
                    threat_type: rule.name.clone(),
                    severity: rule.severity.clone(),
                    description: format!("检测到威胁: {}", rule.name),
                    affected_resources: vec![event.resource.clone()],
                    recommended_actions: self.get_recommended_actions(&rule.action),
                };
                
                alerts.push(alert.clone());
                
                self.alert_sender.send(alert).await
                    .map_err(|_| ThreatError::AlertSendFailed)?;
            }
        }
        
        Ok(alerts)
    }

    // 检查事件是否匹配模式
    async fn matches_pattern(&self, pattern: &ThreatPattern, event: &SecurityEvent) -> bool {
        match pattern {
            ThreatPattern::FailedLoginAttempts(count, window) => {
                // 简化实现：检查事件类型
                event.event_type == "login_failed"
            }
            ThreatPattern::BruteForceAttack(count, window) => {
                event.event_type == "login_attempt"
            }
            ThreatPattern::SuspiciousIP(ip_pattern) => {
                event.ip_address.contains(ip_pattern)
            }
        }
    }
    
    fn get_recommended_actions(&self, action: &ThreatAction) -> Vec<String> {
        match action {
            ThreatAction::Log => vec!["记录事件到日志".to_string()],
            ThreatAction::Alert => vec!["发送告警通知".to_string()],
            ThreatAction::Block => vec!["阻止访问".to_string(), "通知管理员".to_string()],
            ThreatAction::Quarantine => vec!["隔离账户".to_string(), "暂停服务".to_string()],
        }
    }
}
```

### 5. 安全API

```rust
#[derive(Deserialize)]
pub struct LoginRequest {
    pub username: String,
    pub password: String,
}

#[derive(Serialize)]
pub struct LoginResponse {
    pub token: String,
    pub refresh_token: String,
    pub expires_at: DateTime<Utc>,
    pub user: User,
}

// 安全API路由
pub fn security_routes() -> Router {
    Router::new()
        .route("/auth/register", post(register_user))
        .route("/auth/login", post(login))
        .route("/auth/logout", post(logout))
        .route("/auth/verify", get(verify_token))
        .route("/encrypt", post(encrypt_data))
        .route("/decrypt", post(decrypt_data))
        .route("/threats", get(list_threats))
}

async fn login(
    Json(request): Json<LoginRequest>,
    State(security_manager): State<Arc<SecurityManager>>,
) -> Result<Json<LoginResponse>, StatusCode> {
    let token_info = security_manager.auth_service.login(
        &request.username,
        &request.password,
    ).await
        .map_err(|_| StatusCode::UNAUTHORIZED)?;

    let user = security_manager.auth_service.verify_token(&token_info.token).await
        .map_err(|_| StatusCode::UNAUTHORIZED)?;

    Ok(Json(LoginResponse {
        token: token_info.token,
        refresh_token: token_info.refresh_token,
        expires_at: token_info.expires_at,
        user,
    }))
}

async fn verify_token(
    headers: HeaderMap,
    State(security_manager): State<Arc<SecurityManager>>,
) -> Result<Json<User>, StatusCode> {
    let auth_header = headers.get("Authorization")
        .ok_or(StatusCode::UNAUTHORIZED)?
        .to_str()
        .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    let token = auth_header.strip_prefix("Bearer ")
        .ok_or(StatusCode::UNAUTHORIZED)?;
    
    let user = security_manager.auth_service.verify_token(token).await
        .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    Ok(Json(user))
}
```

## 使用示例

### 1. 用户认证流程

```rust
#[tokio::main]
async fn main() {
    let security_manager = Arc::new(SecurityManager::new());
    
    // 注册用户
    let user = security_manager.auth_service.register_user(
        "admin",
        "admin@example.com",
        "secure_password123",
    ).await.unwrap();
    
    println!("用户注册成功: {}", user.username);
    
    // 用户登录
    let token_info = security_manager.auth_service.login(
        "admin",
        "secure_password123",
    ).await.unwrap();
    
    println!("登录成功，令牌: {}", token_info.token);
}
```

### 2. 访问控制检查

```rust
// 检查访问权限
async fn check_access_permission(security_manager: Arc<SecurityManager>, user: &User) {
    let has_permission = security_manager.access_control.check_permission(
        user,
        "devices",
        "read",
    ).await.unwrap();
    
    if has_permission {
        println!("用户 {} 有读取设备的权限", user.username);
    } else {
        println!("用户 {} 没有读取设备的权限", user.username);
    }
}
```

### 3. 数据加密

```rust
// 数据加密示例
async fn encrypt_sensitive_data(security_manager: Arc<SecurityManager>) {
    let sensitive_data = "这是敏感数据".as_bytes();
    
    let encrypted_data = security_manager.encryption_service.encrypt(
        sensitive_data,
        None,
    ).await.unwrap();
    
    println!("数据已加密: {:?}", encrypted_data.ciphertext);
    
    // 解密数据
    let decrypted_data = security_manager.encryption_service.decrypt(&encrypted_data).await.unwrap();
    let decrypted_string = String::from_utf8(decrypted_data).unwrap();
    
    println!("解密后的数据: {}", decrypted_string);
}
```

## 核心特性

1. **身份认证**: JWT令牌、密码策略、用户管理
2. **访问控制**: 基于角色的访问控制(RBAC)、策略引擎
3. **数据加密**: AES-GCM加密、密钥管理
4. **威胁检测**: 规则引擎、实时告警
5. **安全监控**: 安全事件记录、风险评估
6. **会话管理**: 令牌刷新、设备管理
7. **API安全**: 完整的RESTful安全API

这个物联网安全实现提供了全面的安全防护功能，确保IoT平台的数据安全和访问控制。
