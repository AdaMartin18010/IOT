# 物联网可视化实现

## 概述

物联网可视化系统提供实时数据展示、历史趋势图表、设备状态监控和交互式仪表板功能。

## 核心架构

### 1. 可视化引擎

```rust
// 可视化引擎核心结构
pub struct VisualizationEngine {
    charts: HashMap<String, Box<dyn Chart>>,
    dashboards: HashMap<String, Dashboard>,
    data_sources: HashMap<String, Box<dyn DataSource>>,
    renderer: Box<dyn ChartRenderer>,
    cache: Arc<RedisCache>,
}

// 图表接口
pub trait Chart: Send + Sync {
    fn render(&self, data: &ChartData) -> Result<ChartOutput, VisualizationError>;
    fn get_type(&self) -> ChartType;
    fn get_config(&self) -> ChartConfig;
}

// 数据源接口
pub trait DataSource: Send + Sync {
    fn get_data(&self, query: &DataQuery) -> Result<Vec<DataPoint>, VisualizationError>;
    fn get_metadata(&self) -> DataSourceMetadata;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChartData {
    pub id: String,
    pub title: String,
    pub data_points: Vec<DataPoint>,
    pub metadata: HashMap<String, String>,
    pub time_range: Option<TimeRange>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataPoint {
    pub timestamp: DateTime<Utc>,
    pub values: HashMap<String, f64>,
    pub labels: HashMap<String, String>,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChartOutput {
    pub chart_id: String,
    pub chart_type: ChartType,
    pub svg_data: Option<String>,
    pub json_data: Option<serde_json::Value>,
    pub html_data: Option<String>,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ChartType {
    LineChart,
    BarChart,
    PieChart,
    ScatterPlot,
    Heatmap,
    Gauge,
    Table,
    Map,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ChartConfig {
    pub width: u32,
    pub height: u32,
    pub colors: Vec<String>,
    pub title: String,
    pub x_axis: AxisConfig,
    pub y_axis: AxisConfig,
    pub legend: LegendConfig,
    pub animation: AnimationConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Dashboard {
    pub id: String,
    pub title: String,
    pub description: String,
    pub layout: DashboardLayout,
    pub widgets: Vec<Widget>,
    pub theme: Theme,
    pub refresh_interval: Option<Duration>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Widget {
    pub id: String,
    pub title: String,
    pub widget_type: WidgetType,
    pub data_source: String,
    pub config: WidgetConfig,
    pub position: WidgetPosition,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WidgetType {
    Chart(ChartType),
    Metric,
    Status,
    Table,
    Map,
    Custom(String),
}
```

### 2. 图表实现

```rust
// 折线图实现
pub struct LineChart {
    config: ChartConfig,
}

impl Chart for LineChart {
    fn render(&self, data: &ChartData) -> Result<ChartOutput, VisualizationError> {
        let mut chart_data = serde_json::Map::new();
        
        // 构建图表数据
        let mut series = Vec::new();
        for (metric_name, _) in &data.data_points[0].values {
            let mut points = Vec::new();
            for point in &data.data_points {
                if let Some(value) = point.values.get(metric_name) {
                    points.push(json!({
                        "x": point.timestamp.timestamp(),
                        "y": value
                    }));
                }
            }
            series.push(json!({
                "name": metric_name,
                "data": points
            }));
        }
        
        chart_data.insert("series".to_string(), json!(series));
        chart_data.insert("config".to_string(), serde_json::to_value(&self.config)?);
        
        Ok(ChartOutput {
            chart_id: data.id.clone(),
            chart_type: ChartType::LineChart,
            svg_data: None,
            json_data: Some(serde_json::Value::Object(chart_data)),
            html_data: None,
            metadata: HashMap::new(),
        })
    }
    
    fn get_type(&self) -> ChartType {
        ChartType::LineChart
    }
    
    fn get_config(&self) -> ChartConfig {
        self.config.clone()
    }
}

// 仪表盘实现
pub struct GaugeChart {
    config: ChartConfig,
    min_value: f64,
    max_value: f64,
    thresholds: Vec<GaugeThreshold>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GaugeThreshold {
    pub value: f64,
    pub color: String,
    pub label: String,
}

impl Chart for GaugeChart {
    fn render(&self, data: &ChartData) -> Result<ChartOutput, VisualizationError> {
        if data.data_points.is_empty() {
            return Err(VisualizationError::NoData);
        }
        
        let current_value = data.data_points.last().unwrap().values.values().next().unwrap_or(&0.0);
        
        let mut chart_data = serde_json::Map::new();
        chart_data.insert("value".to_string(), json!(*current_value));
        chart_data.insert("min".to_string(), json!(self.min_value));
        chart_data.insert("max".to_string(), json!(self.max_value));
        chart_data.insert("thresholds".to_string(), serde_json::to_value(&self.thresholds)?);
        chart_data.insert("config".to_string(), serde_json::to_value(&self.config)?);
        
        Ok(ChartOutput {
            chart_id: data.id.clone(),
            chart_type: ChartType::Gauge,
            svg_data: None,
            json_data: Some(serde_json::Value::Object(chart_data)),
            html_data: None,
            metadata: HashMap::new(),
        })
    }
    
    fn get_type(&self) -> ChartType {
        ChartType::Gauge
    }
    
    fn get_config(&self) -> ChartConfig {
        self.config.clone()
    }
}
```

### 3. 仪表板管理器

```rust
pub struct DashboardManager {
    dashboards: Arc<RwLock<HashMap<String, Dashboard>>>,
    data_sources: HashMap<String, Box<dyn DataSource>>,
    renderer: Box<dyn ChartRenderer>,
}

impl DashboardManager {
    pub fn new() -> Self {
        Self {
            dashboards: Arc::new(RwLock::new(HashMap::new())),
            data_sources: HashMap::new(),
            renderer: Box::new(DefaultChartRenderer::new()),
        }
    }

    // 创建仪表板
    pub async fn create_dashboard(&self, dashboard: Dashboard) -> Result<(), VisualizationError> {
        let mut dashboards = self.dashboards.write().await;
        dashboards.insert(dashboard.id.clone(), dashboard);
        Ok(())
    }

    // 渲染仪表板
    pub async fn render_dashboard(&self, dashboard_id: &str) -> Result<DashboardOutput, VisualizationError> {
        let dashboards = self.dashboards.read().await;
        let dashboard = dashboards.get(dashboard_id)
            .ok_or(VisualizationError::DashboardNotFound)?;
        
        let mut rendered_widgets = Vec::new();
        
        for widget in &dashboard.widgets {
            let data = self.get_widget_data(widget).await?;
            let rendered_widget = self.renderer.render_widget(widget, &data).await?;
            rendered_widgets.push(rendered_widget);
        }
        
        Ok(DashboardOutput {
            dashboard_id: dashboard_id.to_string(),
            title: dashboard.title.clone(),
            widgets: rendered_widgets,
            layout: dashboard.layout.clone(),
            theme: dashboard.theme.clone(),
        })
    }

    // 获取小部件数据
    async fn get_widget_data(&self, widget: &Widget) -> Result<ChartData, VisualizationError> {
        let data_source = self.data_sources.get(&widget.data_source)
            .ok_or(VisualizationError::DataSourceNotFound)?;
        
        let query = DataQuery {
            metrics: vec!["temperature".to_string(), "humidity".to_string()],
            time_range: TimeRange {
                start: Utc::now() - Duration::from_hours(24),
                end: Utc::now(),
            },
            limit: Some(1000),
        };
        
        let data_points = data_source.get_data(&query)?;
        
        Ok(ChartData {
            id: widget.id.clone(),
            title: widget.title.clone(),
            data_points,
            metadata: HashMap::new(),
            time_range: Some(query.time_range),
        })
    }
}
```

### 4. 实时数据可视化

```rust
pub struct RealTimeVisualization {
    websocket_manager: Arc<WebSocketManager>,
    dashboard_manager: Arc<DashboardManager>,
    update_interval: Duration,
}

impl RealTimeVisualization {
    pub fn new(dashboard_manager: Arc<DashboardManager>) -> Self {
        Self {
            websocket_manager: Arc::new(WebSocketManager::new()),
            dashboard_manager,
            update_interval: Duration::from_secs(5),
        }
    }

    // 启动实时更新
    pub async fn start_realtime_updates(&self) {
        let mut interval = tokio::time::interval(self.update_interval);
        
        loop {
            interval.tick().await;
            
            // 获取所有活跃的仪表板
            let dashboards = self.dashboard_manager.dashboards.read().await;
            for dashboard in dashboards.values() {
                if let Some(refresh_interval) = dashboard.refresh_interval {
                    if refresh_interval.as_secs() > 0 {
                        // 渲染仪表板
                        if let Ok(output) = self.dashboard_manager.render_dashboard(&dashboard.id).await {
                            // 通过WebSocket发送更新
                            self.websocket_manager.broadcast_dashboard_update(&dashboard.id, &output).await;
                        }
                    }
                }
            }
        }
    }

    // 订阅仪表板更新
    pub async fn subscribe_to_dashboard(&self, dashboard_id: &str, client_id: &str) -> Result<(), VisualizationError> {
        self.websocket_manager.subscribe_to_topic(client_id, &format!("dashboard:{}", dashboard_id)).await;
        Ok(())
    }
}
```

### 5. 可视化API

```rust
#[derive(Deserialize)]
pub struct CreateDashboardRequest {
    pub title: String,
    pub description: String,
    pub widgets: Vec<CreateWidgetRequest>,
    pub layout: DashboardLayout,
    pub refresh_interval: Option<Duration>,
}

#[derive(Serialize)]
pub struct DashboardResponse {
    pub dashboard: Dashboard,
    pub rendered_output: Option<DashboardOutput>,
}

// 可视化API路由
pub fn visualization_routes() -> Router {
    Router::new()
        .route("/dashboards", post(create_dashboard))
        .route("/dashboards/:id", get(get_dashboard))
        .route("/dashboards/:id", put(update_dashboard))
        .route("/dashboards/:id", delete(delete_dashboard))
        .route("/dashboards/:id/render", get(render_dashboard))
        .route("/charts", post(create_chart))
        .route("/charts/:id", get(get_chart))
        .route("/charts/:id/render", post(render_chart))
        .route("/websocket", get(websocket_handler))
}

async fn create_dashboard(
    Json(request): Json<CreateDashboardRequest>,
    State(dashboard_manager): State<Arc<DashboardManager>>,
) -> Result<Json<DashboardResponse>, StatusCode> {
    let dashboard = Dashboard {
        id: Uuid::new_v4().to_string(),
        title: request.title,
        description: request.description,
        layout: request.layout,
        widgets: request.widgets.into_iter().map(|w| w.into()).collect(),
        theme: Theme::default(),
        refresh_interval: request.refresh_interval,
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };

    dashboard_manager.create_dashboard(dashboard.clone()).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    let rendered_output = dashboard_manager.render_dashboard(&dashboard.id).await.ok();

    Ok(Json(DashboardResponse {
        dashboard,
        rendered_output,
    }))
}

async fn render_dashboard(
    Path(dashboard_id): Path<String>,
    State(dashboard_manager): State<Arc<DashboardManager>>,
) -> Result<Json<DashboardOutput>, StatusCode> {
    let output = dashboard_manager.render_dashboard(&dashboard_id).await
        .map_err(|_| StatusCode::NOT_FOUND)?;

    Ok(Json(output))
}
```

## 使用示例

### 1. 创建实时监控仪表板

```rust
#[tokio::main]
async fn main() {
    let dashboard_manager = Arc::new(DashboardManager::new());
    
    // 创建温度监控仪表板
    let temperature_widget = Widget {
        id: "temp-gauge".to_string(),
        title: "温度监控".to_string(),
        widget_type: WidgetType::Chart(ChartType::Gauge),
        data_source: "sensor-data".to_string(),
        config: WidgetConfig {
            chart_config: Some(ChartConfig {
                width: 300,
                height: 200,
                colors: vec!["#00ff00".to_string(), "#ffff00".to_string(), "#ff0000".to_string()],
                title: "温度".to_string(),
                x_axis: AxisConfig::default(),
                y_axis: AxisConfig::default(),
                legend: LegendConfig::default(),
                animation: AnimationConfig::default(),
            }),
            metric_config: None,
            status_config: None,
            table_config: None,
            map_config: None,
        },
        position: WidgetPosition {
            widget_id: "temp-gauge".to_string(),
            x: 0,
            y: 0,
            width: 6,
            height: 4,
        },
    };

    let dashboard = Dashboard {
        id: "monitoring-dashboard".to_string(),
        title: "设备监控仪表板".to_string(),
        description: "实时监控设备状态和传感器数据".to_string(),
        layout: DashboardLayout {
            grid_size: GridSize { columns: 12, rows: 8 },
            widgets: vec![temperature_widget.position.clone()],
        },
        widgets: vec![temperature_widget],
        theme: Theme::default(),
        refresh_interval: Some(Duration::from_secs(5)),
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };

    dashboard_manager.create_dashboard(dashboard).await.unwrap();
    println!("监控仪表板创建成功");
}
```

### 2. 实时数据更新

```rust
// 启动实时可视化
async fn start_realtime_visualization(dashboard_manager: Arc<DashboardManager>) {
    let realtime_viz = RealTimeVisualization::new(dashboard_manager);
    
    // 启动实时更新循环
    tokio::spawn(async move {
        realtime_viz.start_realtime_updates().await;
    });
    
    println!("实时可视化已启动");
}
```

## 核心特性

1. **多种图表类型**: 折线图、柱状图、饼图、散点图、热力图、仪表盘等
2. **交互式仪表板**: 可拖拽布局、实时更新、主题定制
3. **实时数据展示**: WebSocket实时推送、自动刷新
4. **数据源集成**: 支持多种数据源、灵活查询
5. **响应式设计**: 自适应布局、移动端支持
6. **主题定制**: 多种主题、颜色配置
7. **性能优化**: 缓存机制、懒加载
8. **API接口**: RESTful API和WebSocket支持

这个物联网可视化实现提供了完整的数据展示和监控功能，支持实时和历史数据的可视化展示。
