# 任务调度系统实现

## 1. 任务调度核心架构

### 1.1 任务定义和调度器

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{mpsc, RwLock};
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc, Duration};
use uuid::Uuid;
use std::time::SystemTime;

/// 任务状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TaskStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Cancelled,
}

/// 任务优先级
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum TaskPriority {
    Low = 1,
    Normal = 2,
    High = 3,
    Critical = 4,
}

/// 任务定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Task {
    pub id: String,
    pub name: String,
    pub description: Option<String>,
    pub task_type: TaskType,
    pub priority: TaskPriority,
    pub status: TaskStatus,
    pub created_at: DateTime<Utc>,
    pub scheduled_at: Option<DateTime<Utc>>,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
    pub retry_count: u32,
    pub max_retries: u32,
    pub timeout: Option<u64>, // 秒
    pub payload: serde_json::Value,
    pub result: Option<serde_json::Value>,
    pub error: Option<String>,
    pub tags: Vec<String>,
}

/// 任务类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TaskType {
    OneTime,
    Recurring(RecurrenceRule),
    Delayed(u64), // 延迟秒数
}

/// 重复规则
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecurrenceRule {
    pub frequency: Frequency,
    pub interval: u32,
    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
    pub max_occurrences: Option<u32>,
}

/// 频率类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Frequency {
    Seconds,
    Minutes,
    Hours,
    Days,
    Weeks,
    Months,
    Years,
}

/// 任务执行器接口
#[async_trait::async_trait]
pub trait TaskExecutor: Send + Sync {
    async fn execute(&self, task: &Task) -> Result<serde_json::Value, Box<dyn std::error::Error>>;
    fn get_name(&self) -> &str;
}

/// 任务调度器
pub struct TaskScheduler {
    tasks: Arc<RwLock<HashMap<String, Task>>>,
    executors: Arc<RwLock<HashMap<String, Arc<dyn TaskExecutor>>>>,
    task_sender: mpsc::Sender<Task>,
    task_receiver: mpsc::Receiver<Task>,
    worker_count: usize,
    running: Arc<RwLock<bool>>,
}

impl TaskScheduler {
    pub fn new(worker_count: usize) -> Self {
        let (task_sender, task_receiver) = mpsc::channel(1000);
        
        Self {
            tasks: Arc::new(RwLock::new(HashMap::new())),
            executors: Arc::new(RwLock::new(HashMap::new())),
            task_sender,
            task_receiver,
            worker_count,
            running: Arc::new(RwLock::new(false)),
        }
    }

    /// 注册任务执行器
    pub async fn register_executor(&self, executor: Arc<dyn TaskExecutor>) {
        let mut executors = self.executors.write().await;
        executors.insert(executor.get_name().to_string(), executor);
    }

    /// 提交任务
    pub async fn submit_task(&self, task: Task) -> Result<(), Box<dyn std::error::Error>> {
        let task_id = task.id.clone();
        
        // 保存任务
        {
            let mut tasks = self.tasks.write().await;
            tasks.insert(task_id.clone(), task.clone());
        }
        
        // 发送到队列
        self.task_sender.send(task).await
            .map_err(|e| format!("Failed to submit task: {}", e).into())
    }

    /// 创建一次性任务
    pub async fn create_one_time_task(
        &self,
        name: String,
        executor_name: String,
        payload: serde_json::Value,
        priority: TaskPriority,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let task = Task {
            id: Uuid::new_v4().to_string(),
            name,
            description: None,
            task_type: TaskType::OneTime,
            priority,
            status: TaskStatus::Pending,
            created_at: Utc::now(),
            scheduled_at: Some(Utc::now()),
            started_at: None,
            completed_at: None,
            retry_count: 0,
            max_retries: 3,
            timeout: Some(300), // 5分钟
            payload,
            result: None,
            error: None,
            tags: vec![executor_name],
        };
        
        let task_id = task.id.clone();
        self.submit_task(task).await?;
        
        Ok(task_id)
    }

    /// 创建重复任务
    pub async fn create_recurring_task(
        &self,
        name: String,
        executor_name: String,
        payload: serde_json::Value,
        recurrence_rule: RecurrenceRule,
        priority: TaskPriority,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let task = Task {
            id: Uuid::new_v4().to_string(),
            name,
            description: None,
            task_type: TaskType::Recurring(recurrence_rule),
            priority,
            status: TaskStatus::Pending,
            created_at: Utc::now(),
            scheduled_at: Some(Utc::now()),
            started_at: None,
            completed_at: None,
            retry_count: 0,
            max_retries: 3,
            timeout: Some(300),
            payload,
            result: None,
            error: None,
            tags: vec![executor_name],
        };
        
        let task_id = task.id.clone();
        self.submit_task(task).await?;
        
        Ok(task_id)
    }

    /// 启动调度器
    pub async fn start(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        {
            let mut running = self.running.write().await;
            *running = true;
        }
        
        // 启动工作线程
        for worker_id in 0..self.worker_count {
            let task_receiver = self.task_receiver.clone();
            let tasks = self.tasks.clone();
            let executors = self.executors.clone();
            let running = self.running.clone();
            
            tokio::spawn(async move {
                Self::worker_loop(worker_id, task_receiver, tasks, executors, running).await;
            });
        }
        
        // 启动调度循环
        let tasks = self.tasks.clone();
        let task_sender = self.task_sender.clone();
        let running = self.running.clone();
        
        tokio::spawn(async move {
            Self::scheduler_loop(tasks, task_sender, running).await;
        });
        
        Ok(())
    }

    /// 停止调度器
    pub async fn stop(&self) {
        let mut running = self.running.write().await;
        *running = false;
    }

    /// 获取任务状态
    pub async fn get_task(&self, task_id: &str) -> Option<Task> {
        let tasks = self.tasks.read().await;
        tasks.get(task_id).cloned()
    }

    /// 取消任务
    pub async fn cancel_task(&self, task_id: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let mut tasks = self.tasks.write().await;
        if let Some(task) = tasks.get_mut(task_id) {
            task.status = TaskStatus::Cancelled;
            task.completed_at = Some(Utc::now());
            Ok(true)
        } else {
            Ok(false)
        }
    }

    /// 工作线程循环
    async fn worker_loop(
        worker_id: usize,
        mut task_receiver: mpsc::Receiver<Task>,
        tasks: Arc<RwLock<HashMap<String, Task>>>,
        executors: Arc<RwLock<HashMap<String, Arc<dyn TaskExecutor>>>>,
        running: Arc<RwLock<bool>>,
    ) {
        while *running.read().await {
            if let Some(task) = task_receiver.recv().await {
                println!("Worker {} processing task: {}", worker_id, task.name);
                
                // 更新任务状态为运行中
                {
                    let mut tasks_map = tasks.write().await;
                    if let Some(task_ref) = tasks_map.get_mut(&task.id) {
                        task_ref.status = TaskStatus::Running;
                        task_ref.started_at = Some(Utc::now());
                    }
                }
                
                // 执行任务
                let result = Self::execute_task(&task, &executors).await;
                
                // 更新任务状态
                {
                    let mut tasks_map = tasks.write().await;
                    if let Some(task_ref) = tasks_map.get_mut(&task.id) {
                        match result {
                            Ok(value) => {
                                task_ref.status = TaskStatus::Completed;
                                task_ref.result = Some(value);
                            }
                            Err(e) => {
                                task_ref.error = Some(e.to_string());
                                if task_ref.retry_count < task_ref.max_retries {
                                    task_ref.status = TaskStatus::Pending;
                                    task_ref.retry_count += 1;
                                    task_ref.scheduled_at = Some(Utc::now() + Duration::seconds(60));
                                } else {
                                    task_ref.status = TaskStatus::Failed;
                                }
                            }
                        }
                        task_ref.completed_at = Some(Utc::now());
                    }
                }
            }
        }
    }

    /// 执行任务
    async fn execute_task(
        task: &Task,
        executors: &Arc<RwLock<HashMap<String, Arc<dyn TaskExecutor>>>>,
    ) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        let executor_name = task.tags.first()
            .ok_or("No executor specified")?;
        
        let executors_map = executors.read().await;
        let executor = executors_map.get(executor_name)
            .ok_or_else(|| format!("Executor not found: {}", executor_name))?;
        
        executor.execute(task).await
    }

    /// 调度器循环
    async fn scheduler_loop(
        tasks: Arc<RwLock<HashMap<String, Task>>>,
        task_sender: mpsc::Sender<Task>,
        running: Arc<RwLock<bool>>,
    ) {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(1));
        
        while *running.read().await {
            interval.tick().await;
            
            let now = Utc::now();
            let mut tasks_to_schedule = Vec::new();
            
            // 检查需要调度的任务
            {
                let mut tasks_map = tasks.write().await;
                for (task_id, task) in tasks_map.iter_mut() {
                    if task.status == TaskStatus::Pending {
                        if let Some(scheduled_at) = task.scheduled_at {
                            if now >= scheduled_at {
                                tasks_to_schedule.push(task.clone());
                                
                                // 更新重复任务的下次执行时间
                                if let TaskType::Recurring(ref rule) = task.task_type {
                                    if let Some(next_time) = Self::calculate_next_execution(task, rule) {
                                        task.scheduled_at = Some(next_time);
                                    } else {
                                        task.status = TaskStatus::Completed;
                                    }
                                } else {
                                    // 一次性任务，标记为已完成
                                    task.status = TaskStatus::Completed;
                                }
                            }
                        }
                    }
                }
            }
            
            // 发送任务到队列
            for task in tasks_to_schedule {
                if let Err(e) = task_sender.send(task).await {
                    eprintln!("Failed to send task to queue: {}", e);
                }
            }
        }
    }

    /// 计算下次执行时间
    fn calculate_next_execution(task: &Task, rule: &RecurrenceRule) -> Option<DateTime<Utc>> {
        let current_time = task.scheduled_at.unwrap_or(Utc::now());
        
        // 检查是否超过结束时间
        if let Some(end_time) = rule.end_time {
            if current_time >= end_time {
                return None;
            }
        }
        
        // 计算下次执行时间
        let next_time = match rule.frequency {
            Frequency::Seconds => current_time + Duration::seconds(rule.interval as i64),
            Frequency::Minutes => current_time + Duration::minutes(rule.interval as i64),
            Frequency::Hours => current_time + Duration::hours(rule.interval as i64),
            Frequency::Days => current_time + Duration::days(rule.interval as i64),
            Frequency::Weeks => current_time + Duration::weeks(rule.interval as i64),
            Frequency::Months => {
                // 简化的月份计算
                current_time + Duration::days(rule.interval as i64 * 30)
            }
            Frequency::Years => {
                // 简化的年份计算
                current_time + Duration::days(rule.interval as i64 * 365)
            }
        };
        
        Some(next_time)
    }
}
```

### 1.2 任务执行器实现

```rust
/// HTTP任务执行器
pub struct HttpTaskExecutor {
    name: String,
    client: reqwest::Client,
}

impl HttpTaskExecutor {
    pub fn new(name: String) -> Self {
        Self {
            name,
            client: reqwest::Client::new(),
        }
    }
}

#[async_trait::async_trait]
impl TaskExecutor for HttpTaskExecutor {
    async fn execute(&self, task: &Task) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        let url = task.payload["url"].as_str()
            .ok_or("URL not specified")?;
        
        let method = task.payload["method"].as_str().unwrap_or("GET");
        let headers = task.payload.get("headers")
            .and_then(|h| h.as_object())
            .unwrap_or(&serde_json::Map::new());
        
        let mut request_builder = match method {
            "GET" => self.client.get(url),
            "POST" => self.client.post(url),
            "PUT" => self.client.put(url),
            "DELETE" => self.client.delete(url),
            _ => return Err("Unsupported HTTP method".into()),
        };
        
        // 添加头部
        for (key, value) in headers {
            if let Some(value_str) = value.as_str() {
                request_builder = request_builder.header(key, value_str);
            }
        }
        
        // 添加请求体
        if let Some(body) = task.payload.get("body") {
            request_builder = request_builder.json(body);
        }
        
        // 执行请求
        let response = request_builder.send().await?;
        let status = response.status();
        let body = response.text().await?;
        
        let result = serde_json::json!({
            "status": status.as_u16(),
            "body": body,
            "headers": response.headers().iter().map(|(k, v)| (k.as_str(), v.to_str().unwrap_or(""))).collect::<HashMap<_, _>>()
        });
        
        Ok(result)
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}

/// 脚本任务执行器
pub struct ScriptTaskExecutor {
    name: String,
}

impl ScriptTaskExecutor {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

#[async_trait::async_trait]
impl TaskExecutor for ScriptTaskExecutor {
    async fn execute(&self, task: &Task) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        let script = task.payload["script"].as_str()
            .ok_or("Script not specified")?;
        
        let args = task.payload.get("args")
            .and_then(|a| a.as_array())
            .map(|arr| arr.iter().filter_map(|v| v.as_str()).collect::<Vec<_>>())
            .unwrap_or_default();
        
        let output = tokio::process::Command::new("sh")
            .arg("-c")
            .arg(script)
            .args(&args)
            .output()
            .await?;
        
        let result = serde_json::json!({
            "stdout": String::from_utf8_lossy(&output.stdout),
            "stderr": String::from_utf8_lossy(&output.stderr),
            "exit_code": output.status.code()
        });
        
        Ok(result)
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}

/// 数据处理任务执行器
pub struct DataProcessingTaskExecutor {
    name: String,
}

impl DataProcessingTaskExecutor {
    pub fn new(name: String) -> Self {
        Self { name }
    }
}

#[async_trait::async_trait]
impl TaskExecutor for DataProcessingTaskExecutor {
    async fn execute(&self, task: &Task) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        let operation = task.payload["operation"].as_str()
            .ok_or("Operation not specified")?;
        
        let data = task.payload.get("data")
            .ok_or("Data not specified")?;
        
        let result = match operation {
            "aggregate" => {
                if let Some(array) = data.as_array() {
                    let sum: f64 = array.iter()
                        .filter_map(|v| v.as_f64())
                        .sum();
                    let count = array.len();
                    let avg = if count > 0 { sum / count as f64 } else { 0.0 };
                    
                    serde_json::json!({
                        "sum": sum,
                        "count": count,
                        "average": avg
                    })
                } else {
                    return Err("Data must be an array for aggregation".into());
                }
            }
            "filter" => {
                let condition = task.payload["condition"].as_str()
                    .ok_or("Filter condition not specified")?;
                
                if let Some(array) = data.as_array() {
                    let filtered: Vec<_> = array.iter()
                        .filter(|item| {
                            // 简化的过滤逻辑
                            item.to_string().contains(condition)
                        })
                        .collect();
                    
                    serde_json::json!({
                        "filtered_count": filtered.len(),
                        "filtered_data": filtered
                    })
                } else {
                    return Err("Data must be an array for filtering".into());
                }
            }
            "transform" => {
                let transform_type = task.payload["transform_type"].as_str()
                    .ok_or("Transform type not specified")?;
                
                match transform_type {
                    "uppercase" => {
                        if let Some(text) = data.as_str() {
                            serde_json::json!({
                                "result": text.to_uppercase()
                            })
                        } else {
                            return Err("Data must be a string for uppercase transform".into());
                        }
                    }
                    "lowercase" => {
                        if let Some(text) = data.as_str() {
                            serde_json::json!({
                                "result": text.to_lowercase()
                            })
                        } else {
                            return Err("Data must be a string for lowercase transform".into());
                        }
                    }
                    _ => return Err("Unsupported transform type".into()),
                }
            }
            _ => return Err("Unsupported operation".into()),
        };
        
        Ok(result)
    }

    fn get_name(&self) -> &str {
        &self.name
    }
}
```

## 2. 应用示例

### 2.1 IoT系统任务调度

```rust
use crate::scheduler::{TaskScheduler, TaskPriority, RecurrenceRule, Frequency, HttpTaskExecutor, ScriptTaskExecutor, DataProcessingTaskExecutor};

async fn iot_task_scheduling_system() -> Result<(), Box<dyn std::error::Error>> {
    // 创建任务调度器
    let mut scheduler = TaskScheduler::new(4); // 4个工作线程
    
    // 注册任务执行器
    scheduler.register_executor(Arc::new(HttpTaskExecutor::new("http".to_string()))).await;
    scheduler.register_executor(Arc::new(ScriptTaskExecutor::new("script".to_string()))).await;
    scheduler.register_executor(Arc::new(DataProcessingTaskExecutor::new("data_processing".to_string()))).await;
    
    // 启动调度器
    scheduler.start().await?;
    
    // 创建定期数据收集任务
    let data_collection_rule = RecurrenceRule {
        frequency: Frequency::Minutes,
        interval: 5, // 每5分钟
        start_time: Utc::now(),
        end_time: None,
        max_occurrences: None,
    };
    
    let data_collection_payload = serde_json::json!({
        "url": "http://sensor-api:8080/data",
        "method": "GET",
        "headers": {
            "Authorization": "Bearer sensor-token"
        }
    });
    
    let data_collection_task_id = scheduler.create_recurring_task(
        "Data Collection".to_string(),
        "http".to_string(),
        data_collection_payload,
        data_collection_rule,
        TaskPriority::High,
    ).await?;
    
    println!("Created data collection task: {}", data_collection_task_id);
    
    // 创建数据处理任务
    let data_processing_payload = serde_json::json!({
        "operation": "aggregate",
        "data": [25.5, 26.1, 24.8, 25.9, 26.3]
    });
    
    let data_processing_task_id = scheduler.create_one_time_task(
        "Data Processing".to_string(),
        "data_processing".to_string(),
        data_processing_payload,
        TaskPriority::Normal,
    ).await?;
    
    println!("Created data processing task: {}", data_processing_task_id);
    
    // 创建系统维护任务
    let maintenance_rule = RecurrenceRule {
        frequency: Frequency::Hours,
        interval: 24, // 每24小时
        start_time: Utc::now(),
        end_time: None,
        max_occurrences: None,
    };
    
    let maintenance_payload = serde_json::json!({
        "script": "df -h && free -h && uptime",
        "args": []
    });
    
    let maintenance_task_id = scheduler.create_recurring_task(
        "System Maintenance".to_string(),
        "script".to_string(),
        maintenance_payload,
        maintenance_rule,
        TaskPriority::Low,
    ).await?;
    
    println!("Created maintenance task: {}", maintenance_task_id);
    
    // 创建告警检查任务
    let alert_check_rule = RecurrenceRule {
        frequency: Frequency::Minutes,
        interval: 1, // 每分钟
        start_time: Utc::now(),
        end_time: None,
        max_occurrences: None,
    };
    
    let alert_check_payload = serde_json::json!({
        "url": "http://alert-service:8080/check",
        "method": "POST",
        "headers": {
            "Content-Type": "application/json"
        },
        "body": {
            "check_type": "temperature_threshold"
        }
    });
    
    let alert_check_task_id = scheduler.create_recurring_task(
        "Alert Check".to_string(),
        "http".to_string(),
        alert_check_payload,
        alert_check_rule,
        TaskPriority::Critical,
    ).await?;
    
    println!("Created alert check task: {}", alert_check_task_id);
    
    // 监控任务状态
    let task_ids = vec![
        data_collection_task_id,
        data_processing_task_id,
        maintenance_task_id,
        alert_check_task_id,
    ];
    
    tokio::spawn(async move {
        loop {
            for task_id in &task_ids {
                if let Some(task) = scheduler.get_task(task_id).await {
                    println!("Task {}: {:?} - {}", task.name, task.status, task.id);
                    
                    if let Some(result) = &task.result {
                        println!("  Result: {}", result);
                    }
                    
                    if let Some(error) = &task.error {
                        println!("  Error: {}", error);
                    }
                }
            }
            
            tokio::time::sleep(tokio::time::Duration::from_secs(30)).await;
        }
    });
    
    // 运行一段时间后停止
    tokio::time::sleep(tokio::time::Duration::from_secs(300)).await; // 5分钟
    
    scheduler.stop().await;
    println!("Task scheduler stopped");
    
    Ok(())
}
```

## 3. 总结

本实现提供了：

1. **任务调度器** - 支持一次性、重复和延迟任务
2. **多种任务执行器** - HTTP、脚本、数据处理
3. **任务优先级** - 支持不同优先级的任务调度
4. **重试机制** - 失败任务自动重试
5. **任务状态管理** - 完整的任务生命周期管理
6. **实际应用示例** - IoT系统任务调度

这个任务调度系统为IoT平台提供了灵活的任务管理和执行能力，支持各种自动化场景。
