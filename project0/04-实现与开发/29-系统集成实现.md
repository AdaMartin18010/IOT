# 系统集成实现

## 概述

系统集成模块负责整合各个IoT组件，提供统一的系统管理和协调能力，确保各组件间的协同工作。

## 核心组件

### 1. 系统集成管理器

#### Rust实现

```rust
use std::collections::HashMap;
use std::sync::{Arc, RwLock};
use tokio::sync::mpsc;
use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use async_trait::async_trait;

/// 组件状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ComponentStatus {
    Initializing,
    Running,
    Stopped,
    Error(String),
    Maintenance,
}

/// 组件类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ComponentType {
    ProtocolAdapter,
    DeviceManager,
    DataStorage,
    MessageRouter,
    Monitoring,
    Security,
    API,
    Custom(String),
}

/// 组件信息
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComponentInfo {
    pub id: String,
    pub name: String,
    pub component_type: ComponentType,
    pub status: ComponentStatus,
    pub version: String,
    pub config: HashMap<String, serde_json::Value>,
    pub dependencies: Vec<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub health_score: f64,
}

/// 系统配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemConfig {
    pub system_name: String,
    pub version: String,
    pub environment: String,
    pub max_components: usize,
    pub health_check_interval: std::time::Duration,
    pub auto_restart: bool,
    pub log_level: String,
    pub components: HashMap<String, ComponentConfig>,
}

/// 组件配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComponentConfig {
    pub enabled: bool,
    pub config: HashMap<String, serde_json::Value>,
    pub dependencies: Vec<String>,
    pub startup_order: usize,
}

/// 系统健康状态
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SystemHealth {
    pub overall_health: f64,
    pub component_count: usize,
    pub healthy_components: usize,
    pub error_components: usize,
    pub last_check: DateTime<Utc>,
    pub component_health: HashMap<String, f64>,
}

/// 组件接口
#[async_trait]
pub trait SystemComponent: Send + Sync {
    async fn initialize(&mut self, config: ComponentConfig) -> Result<(), Box<dyn std::error::Error>>;
    async fn start(&mut self) -> Result<(), Box<dyn std::error::Error>>;
    async fn stop(&mut self) -> Result<(), Box<dyn std::error::Error>>;
    async fn health_check(&self) -> Result<f64, Box<dyn std::error::Error>>;
    fn get_info(&self) -> ComponentInfo;
    fn get_dependencies(&self) -> Vec<String>;
}

/// 系统集成管理器
pub struct SystemIntegrationManager {
    components: Arc<RwLock<HashMap<String, Arc<dyn SystemComponent>>>>,
    component_info: Arc<RwLock<HashMap<String, ComponentInfo>>>,
    config: SystemConfig,
    event_sender: mpsc::Sender<SystemEvent>,
    health_check_interval: std::time::Duration,
}

impl SystemIntegrationManager {
    pub fn new(config: SystemConfig) -> Self {
        let (event_sender, _) = mpsc::channel(1000);
        
        Self {
            components: Arc::new(RwLock::new(HashMap::new())),
            component_info: Arc::new(RwLock::new(HashMap::new())),
            config,
            event_sender,
            health_check_interval: std::time::Duration::from_secs(30),
        }
    }

    /// 注册组件
    pub async fn register_component(
        &self,
        component: Arc<dyn SystemComponent>,
    ) -> Result<String, Box<dyn std::error::Error>> {
        let info = component.get_info();
        let component_id = info.id.clone();

        {
            let mut components = self.components.write().unwrap();
            components.insert(component_id.clone(), component);
        }

        {
            let mut component_info = self.component_info.write().unwrap();
            component_info.insert(component_id.clone(), info);
        }

        // 发送注册事件
        let _ = self.event_sender.send(SystemEvent::ComponentRegistered { 
            component_id: component_id.clone() 
        }).await;

        Ok(component_id)
    }

    /// 初始化组件
    pub async fn initialize_component(&self, component_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let component = {
            let components = self.components.read().unwrap();
            components.get(component_id).cloned()
        };

        if let Some(mut component) = component {
            let config = {
                let system_config = &self.config;
                system_config.components.get(component_id).cloned()
            };

            if let Some(config) = config {
                component.initialize(config).await?;
                
                // 更新状态
                {
                    let mut component_info = self.component_info.write().unwrap();
                    if let Some(info) = component_info.get_mut(component_id) {
                        info.status = ComponentStatus::Initializing;
                        info.updated_at = Utc::now();
                    }
                }

                // 发送初始化事件
                let _ = self.event_sender.send(SystemEvent::ComponentInitialized { 
                    component_id: component_id.to_string() 
                }).await;
            }
        }

        Ok(())
    }

    /// 启动组件
    pub async fn start_component(&self, component_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let component = {
            let components = self.components.read().unwrap();
            components.get(component_id).cloned()
        };

        if let Some(mut component) = component {
            // 检查依赖
            let dependencies = component.get_dependencies();
            for dep_id in dependencies {
                let dep_status = {
                    let component_info = self.component_info.read().unwrap();
                    component_info.get(&dep_id).map(|info| info.status.clone())
                };

                if let Some(status) = dep_status {
                    if !matches!(status, ComponentStatus::Running) {
                        return Err(format!("Dependency {} is not running", dep_id).into());
                    }
                }
            }

            component.start().await?;
            
            // 更新状态
            {
                let mut component_info = self.component_info.write().unwrap();
                if let Some(info) = component_info.get_mut(component_id) {
                    info.status = ComponentStatus::Running;
                    info.updated_at = Utc::now();
                }
            }

            // 发送启动事件
            let _ = self.event_sender.send(SystemEvent::ComponentStarted { 
                component_id: component_id.to_string() 
            }).await;
        }

        Ok(())
    }

    /// 停止组件
    pub async fn stop_component(&self, component_id: &str) -> Result<(), Box<dyn std::error::Error>> {
        let component = {
            let components = self.components.read().unwrap();
            components.get(component_id).cloned()
        };

        if let Some(mut component) = component {
            component.stop().await?;
            
            // 更新状态
            {
                let mut component_info = self.component_info.write().unwrap();
                if let Some(info) = component_info.get_mut(component_id) {
                    info.status = ComponentStatus::Stopped;
                    info.updated_at = Utc::now();
                }
            }

            // 发送停止事件
            let _ = self.event_sender.send(SystemEvent::ComponentStopped { 
                component_id: component_id.to_string() 
            }).await;
        }

        Ok(())
    }

    /// 获取组件
    pub fn get_component(&self, component_id: &str) -> Option<Arc<dyn SystemComponent>> {
        let components = self.components.read().unwrap();
        components.get(component_id).cloned()
    }

    /// 获取组件信息
    pub fn get_component_info(&self, component_id: &str) -> Option<ComponentInfo> {
        let component_info = self.component_info.read().unwrap();
        component_info.get(component_id).cloned()
    }

    /// 获取所有组件信息
    pub fn get_all_components(&self) -> Vec<ComponentInfo> {
        let component_info = self.component_info.read().unwrap();
        component_info.values().cloned().collect()
    }

    /// 按类型获取组件
    pub fn get_components_by_type(&self, component_type: ComponentType) -> Vec<Arc<dyn SystemComponent>> {
        let components = self.components.read().unwrap();
        components
            .values()
            .filter(|component| {
                let info = component.get_info();
                std::mem::discriminant(&info.component_type) == std::mem::discriminant(&component_type)
            })
            .cloned()
            .collect()
    }

    /// 系统健康检查
    pub async fn health_check(&self) -> SystemHealth {
        let mut component_health = HashMap::new();
        let mut healthy_count = 0;
        let mut error_count = 0;
        let mut total_health_score = 0.0;

        let components = {
            let components = self.components.read().unwrap();
            components.clone()
        };

        for (component_id, component) in components {
            match component.health_check().await {
                Ok(health_score) => {
                    component_health.insert(component_id.clone(), health_score);
                    total_health_score += health_score;
                    
                    if health_score >= 0.8 {
                        healthy_count += 1;
                    } else if health_score < 0.5 {
                        error_count += 1;
                    }
                }
                Err(_) => {
                    component_health.insert(component_id.clone(), 0.0);
                    error_count += 1;
                }
            }
        }

        let component_count = components.len();
        let overall_health = if component_count > 0 {
            total_health_score / component_count as f64
        } else {
            0.0
        };

        SystemHealth {
            overall_health,
            component_count,
            healthy_components: healthy_count,
            error_components: error_count,
            last_check: Utc::now(),
            component_health,
        }
    }

    /// 启动系统
    pub async fn start_system(&self) -> Result<(), Box<dyn std::error::Error>> {
        // 按启动顺序启动组件
        let mut startup_order: Vec<_> = {
            let component_info = self.component_info.read().unwrap();
            component_info.values().collect()
        };

        startup_order.sort_by(|a, b| {
            let a_order = self.config.components.get(&a.id)
                .map(|c| c.startup_order)
                .unwrap_or(0);
            let b_order = self.config.components.get(&b.id)
                .map(|c| c.startup_order)
                .unwrap_or(0);
            a_order.cmp(&b_order)
        });

        for component_info in startup_order {
            if let Some(config) = self.config.components.get(&component_info.id) {
                if config.enabled {
                    self.initialize_component(&component_info.id).await?;
                    self.start_component(&component_info.id).await?;
                }
            }
        }

        // 发送系统启动事件
        let _ = self.event_sender.send(SystemEvent::SystemStarted).await;

        Ok(())
    }

    /// 停止系统
    pub async fn stop_system(&self) -> Result<(), Box<dyn std::error::Error>> {
        let components = {
            let components = self.components.read().unwrap();
            components.clone()
        };

        for (component_id, _) in components {
            let _ = self.stop_component(&component_id).await;
        }

        // 发送系统停止事件
        let _ = self.event_sender.send(SystemEvent::SystemStopped).await;

        Ok(())
    }
}

/// 系统事件
#[derive(Debug, Clone)]
pub enum SystemEvent {
    ComponentRegistered { component_id: String },
    ComponentInitialized { component_id: String },
    ComponentStarted { component_id: String },
    ComponentStopped { component_id: String },
    ComponentError { component_id: String, error: String },
    SystemStarted,
    SystemStopped,
    HealthCheck { health: SystemHealth },
}
```

#### Go实现

```go
package integration

import (
    "fmt"
    "sync"
    "time"
    "encoding/json"
)

// ComponentStatus 组件状态
type ComponentStatus string

const (
    ComponentStatusInitializing ComponentStatus = "initializing"
    ComponentStatusRunning     ComponentStatus = "running"
    ComponentStatusStopped     ComponentStatus = "stopped"
    ComponentStatusError       ComponentStatus = "error"
    ComponentStatusMaintenance ComponentStatus = "maintenance"
)

// ComponentType 组件类型
type ComponentType string

const (
    ComponentTypeProtocolAdapter ComponentType = "protocol_adapter"
    ComponentTypeDeviceManager   ComponentType = "device_manager"
    ComponentTypeDataStorage     ComponentType = "data_storage"
    ComponentTypeMessageRouter   ComponentType = "message_router"
    ComponentTypeMonitoring      ComponentType = "monitoring"
    ComponentTypeSecurity        ComponentType = "security"
    ComponentTypeAPI             ComponentType = "api"
    ComponentTypeCustom          ComponentType = "custom"
)

// ComponentInfo 组件信息
type ComponentInfo struct {
    ID            string                 `json:"id"`
    Name          string                 `json:"name"`
    ComponentType ComponentType          `json:"component_type"`
    Status        ComponentStatus        `json:"status"`
    Version       string                 `json:"version"`
    Config        map[string]interface{} `json:"config"`
    Dependencies  []string               `json:"dependencies"`
    CreatedAt     time.Time              `json:"created_at"`
    UpdatedAt     time.Time              `json:"updated_at"`
    HealthScore   float64                `json:"health_score"`
}

// SystemConfig 系统配置
type SystemConfig struct {
    SystemName           string                    `json:"system_name"`
    Version              string                    `json:"version"`
    Environment          string                    `json:"environment"`
    MaxComponents        int                       `json:"max_components"`
    HealthCheckInterval  time.Duration             `json:"health_check_interval"`
    AutoRestart          bool                      `json:"auto_restart"`
    LogLevel             string                    `json:"log_level"`
    Components           map[string]ComponentConfig `json:"components"`
}

// ComponentConfig 组件配置
type ComponentConfig struct {
    Enabled      bool                   `json:"enabled"`
    Config       map[string]interface{} `json:"config"`
    Dependencies []string               `json:"dependencies"`
    StartupOrder int                    `json:"startup_order"`
}

// SystemHealth 系统健康状态
type SystemHealth struct {
    OverallHealth      float64            `json:"overall_health"`
    ComponentCount     int                `json:"component_count"`
    HealthyComponents  int                `json:"healthy_components"`
    ErrorComponents    int                `json:"error_components"`
    LastCheck          time.Time          `json:"last_check"`
    ComponentHealth    map[string]float64 `json:"component_health"`
}

// SystemComponent 组件接口
type SystemComponent interface {
    Initialize(config ComponentConfig) error
    Start() error
    Stop() error
    HealthCheck() (float64, error)
    GetInfo() ComponentInfo
    GetDependencies() []string
}

// SystemIntegrationManager 系统集成管理器
type SystemIntegrationManager struct {
    components              map[string]SystemComponent
    componentInfo           map[string]ComponentInfo
    config                  SystemConfig
    eventChan               chan SystemEvent
    healthCheckInterval     time.Duration
    mu                      sync.RWMutex
}

// NewSystemIntegrationManager 创建系统集成管理器
func NewSystemIntegrationManager(config SystemConfig) *SystemIntegrationManager {
    return &SystemIntegrationManager{
        components:          make(map[string]SystemComponent),
        componentInfo:       make(map[string]ComponentInfo),
        config:              config,
        eventChan:           make(chan SystemEvent, 1000),
        healthCheckInterval: 30 * time.Second,
    }
}

// RegisterComponent 注册组件
func (sim *SystemIntegrationManager) RegisterComponent(component SystemComponent) error {
    sim.mu.Lock()
    defer sim.mu.Unlock()

    info := component.GetInfo()
    sim.components[info.ID] = component
    sim.componentInfo[info.ID] = info

    // 发送注册事件
    select {
    case sim.eventChan <- SystemEvent{Type: EventTypeComponentRegistered, ComponentID: info.ID}:
    default:
    }

    return nil
}

// InitializeComponent 初始化组件
func (sim *SystemIntegrationManager) InitializeComponent(componentID string) error {
    sim.mu.RLock()
    component, exists := sim.components[componentID]
    config := sim.config.Components[componentID]
    sim.mu.RUnlock()

    if !exists {
        return fmt.Errorf("component %s not found", componentID)
    }

    if err := component.Initialize(config); err != nil {
        sim.updateComponentStatus(componentID, ComponentStatusError, err.Error())
        return err
    }

    sim.updateComponentStatus(componentID, ComponentStatusInitializing, "")

    // 发送初始化事件
    select {
    case sim.eventChan <- SystemEvent{Type: EventTypeComponentInitialized, ComponentID: componentID}:
    default:
    }

    return nil
}

// StartComponent 启动组件
func (sim *SystemIntegrationManager) StartComponent(componentID string) error {
    sim.mu.RLock()
    component, exists := sim.components[componentID]
    sim.mu.RUnlock()

    if !exists {
        return fmt.Errorf("component %s not found", componentID)
    }

    // 检查依赖
    dependencies := component.GetDependencies()
    for _, depID := range dependencies {
        sim.mu.RLock()
        depInfo, exists := sim.componentInfo[depID]
        sim.mu.RUnlock()

        if !exists || depInfo.Status != ComponentStatusRunning {
            return fmt.Errorf("dependency %s is not running", depID)
        }
    }

    if err := component.Start(); err != nil {
        sim.updateComponentStatus(componentID, ComponentStatusError, err.Error())
        return err
    }

    sim.updateComponentStatus(componentID, ComponentStatusRunning, "")

    // 发送启动事件
    select {
    case sim.eventChan <- SystemEvent{Type: EventTypeComponentStarted, ComponentID: componentID}:
    default:
    }

    return nil
}

// StopComponent 停止组件
func (sim *SystemIntegrationManager) StopComponent(componentID string) error {
    sim.mu.RLock()
    component, exists := sim.components[componentID]
    sim.mu.RUnlock()

    if !exists {
        return fmt.Errorf("component %s not found", componentID)
    }

    if err := component.Stop(); err != nil {
        sim.updateComponentStatus(componentID, ComponentStatusError, err.Error())
        return err
    }

    sim.updateComponentStatus(componentID, ComponentStatusStopped, "")

    // 发送停止事件
    select {
    case sim.eventChan <- SystemEvent{Type: EventTypeComponentStopped, ComponentID: componentID}:
    default:
    }

    return nil
}

// GetComponent 获取组件
func (sim *SystemIntegrationManager) GetComponent(componentID string) (SystemComponent, bool) {
    sim.mu.RLock()
    defer sim.mu.RUnlock()
    
    component, exists := sim.components[componentID]
    return component, exists
}

// GetComponentInfo 获取组件信息
func (sim *SystemIntegrationManager) GetComponentInfo(componentID string) (ComponentInfo, bool) {
    sim.mu.RLock()
    defer sim.mu.RUnlock()
    
    info, exists := sim.componentInfo[componentID]
    return info, exists
}

// GetAllComponents 获取所有组件信息
func (sim *SystemIntegrationManager) GetAllComponents() []ComponentInfo {
    sim.mu.RLock()
    defer sim.mu.RUnlock()
    
    components := make([]ComponentInfo, 0, len(sim.componentInfo))
    for _, info := range sim.componentInfo {
        components = append(components, info)
    }
    return components
}

// GetComponentsByType 按类型获取组件
func (sim *SystemIntegrationManager) GetComponentsByType(componentType ComponentType) []SystemComponent {
    sim.mu.RLock()
    defer sim.mu.RUnlock()
    
    var components []SystemComponent
    for _, component := range sim.components {
        if component.GetInfo().ComponentType == componentType {
            components = append(components, component)
        }
    }
    return components
}

// HealthCheck 系统健康检查
func (sim *SystemIntegrationManager) HealthCheck() SystemHealth {
    sim.mu.RLock()
    components := make(map[string]SystemComponent)
    for id, component := range sim.components {
        components[id] = component
    }
    sim.mu.RUnlock()

    componentHealth := make(map[string]float64)
    healthyCount := 0
    errorCount := 0
    totalHealthScore := 0.0

    for componentID, component := range components {
        healthScore, err := component.HealthCheck()
        if err != nil {
            componentHealth[componentID] = 0.0
            errorCount++
        } else {
            componentHealth[componentID] = healthScore
            totalHealthScore += healthScore
            
            if healthScore >= 0.8 {
                healthyCount++
            } else if healthScore < 0.5 {
                errorCount++
            }
        }
    }

    componentCount := len(components)
    overallHealth := 0.0
    if componentCount > 0 {
        overallHealth = totalHealthScore / float64(componentCount)
    }

    return SystemHealth{
        OverallHealth:     overallHealth,
        ComponentCount:    componentCount,
        HealthyComponents: healthyCount,
        ErrorComponents:   errorCount,
        LastCheck:         time.Now(),
        ComponentHealth:   componentHealth,
    }
}

// StartSystem 启动系统
func (sim *SystemIntegrationManager) StartSystem() error {
    // 按启动顺序启动组件
    sim.mu.RLock()
    components := make([]ComponentInfo, 0, len(sim.componentInfo))
    for _, info := range sim.componentInfo {
        components = append(components, info)
    }
    sim.mu.RUnlock()

    // 按启动顺序排序
    for i := 0; i < len(components); i++ {
        for j := i + 1; j < len(components); j++ {
            aOrder := sim.config.Components[components[i].ID].StartupOrder
            bOrder := sim.config.Components[components[j].ID].StartupOrder
            if aOrder > bOrder {
                components[i], components[j] = components[j], components[i]
            }
        }
    }

    for _, componentInfo := range components {
        if config, exists := sim.config.Components[componentInfo.ID]; exists && config.Enabled {
            if err := sim.InitializeComponent(componentInfo.ID); err != nil {
                return err
            }
            if err := sim.StartComponent(componentInfo.ID); err != nil {
                return err
            }
        }
    }

    // 发送系统启动事件
    select {
    case sim.eventChan <- SystemEvent{Type: EventTypeSystemStarted}:
    default:
    }

    return nil
}

// StopSystem 停止系统
func (sim *SystemIntegrationManager) StopSystem() error {
    sim.mu.RLock()
    components := make(map[string]SystemComponent)
    for id, component := range sim.components {
        components[id] = component
    }
    sim.mu.RUnlock()

    for componentID := range components {
        sim.StopComponent(componentID)
    }

    // 发送系统停止事件
    select {
    case sim.eventChan <- SystemEvent{Type: EventTypeSystemStopped}:
    default:
    }

    return nil
}

// updateComponentStatus 更新组件状态
func (sim *SystemIntegrationManager) updateComponentStatus(componentID string, status ComponentStatus, errorMsg string) {
    sim.mu.Lock()
    defer sim.mu.Unlock()

    if info, exists := sim.componentInfo[componentID]; exists {
        info.Status = status
        info.UpdatedAt = time.Now()
        sim.componentInfo[componentID] = info
    }
}

// GetEventChannel 获取事件通道
func (sim *SystemIntegrationManager) GetEventChannel() <-chan SystemEvent {
    return sim.eventChan
}

// SystemEvent 系统事件
type SystemEvent struct {
    Type        EventType     `json:"type"`
    ComponentID string        `json:"component_id,omitempty"`
    Error       string        `json:"error,omitempty"`
    Health      *SystemHealth `json:"health,omitempty"`
}

// EventType 事件类型
type EventType string

const (
    EventTypeComponentRegistered  EventType = "component_registered"
    EventTypeComponentInitialized EventType = "component_initialized"
    EventTypeComponentStarted     EventType = "component_started"
    EventTypeComponentStopped     EventType = "component_stopped"
    EventTypeComponentError       EventType = "component_error"
    EventTypeSystemStarted        EventType = "system_started"
    EventTypeSystemStopped        EventType = "system_stopped"
    EventTypeHealthCheck          EventType = "health_check"
)
```

### 2. 使用示例

```rust
// Rust示例
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let config = SystemConfig {
        system_name: "IoT Platform".to_string(),
        version: "1.0.0".to_string(),
        environment: "production".to_string(),
        max_components: 100,
        health_check_interval: std::time::Duration::from_secs(30),
        auto_restart: true,
        log_level: "info".to_string(),
        components: HashMap::new(),
    };

    let system_manager = Arc::new(SystemIntegrationManager::new(config));

    // 注册各种组件
    // 这里应该注册实际的组件实现
    // system_manager.register_component(Arc::new(ProtocolAdapterManager::new())).await?;
    // system_manager.register_component(Arc::new(DeviceManager::new())).await?;
    // system_manager.register_component(Arc::new(DataStorageManager::new())).await?;

    // 启动系统
    system_manager.start_system().await?;
    println!("System started successfully");

    // 健康检查
    let health = system_manager.health_check().await;
    println!("System health: {:.2}%", health.overall_health * 100.0);
    println!("Healthy components: {}/{}", health.healthy_components, health.component_count);

    // 获取所有组件信息
    let components = system_manager.get_all_components();
    println!("Registered components: {}", components.len());

    // 保持系统运行
    tokio::time::sleep(std::time::Duration::from_secs(60)).await;

    // 停止系统
    system_manager.stop_system().await?;
    println!("System stopped");

    Ok(())
}
```

```go
// Go示例
func main() {
    config := SystemConfig{
        SystemName:          "IoT Platform",
        Version:             "1.0.0",
        Environment:         "production",
        MaxComponents:       100,
        HealthCheckInterval: 30 * time.Second,
        AutoRestart:         true,
        LogLevel:            "info",
        Components:          make(map[string]ComponentConfig),
    }

    systemManager := NewSystemIntegrationManager(config)

    // 注册各种组件
    // 这里应该注册实际的组件实现
    // systemManager.RegisterComponent(NewProtocolAdapterManager())
    // systemManager.RegisterComponent(NewDeviceManager())
    // systemManager.RegisterComponent(NewDataStorageManager())

    // 启动系统
    err := systemManager.StartSystem()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("System started successfully")

    // 健康检查
    health := systemManager.HealthCheck()
    fmt.Printf("System health: %.2f%%\n", health.OverallHealth*100.0)
    fmt.Printf("Healthy components: %d/%d\n", health.HealthyComponents, health.ComponentCount)

    // 获取所有组件信息
    components := systemManager.GetAllComponents()
    fmt.Printf("Registered components: %d\n", len(components))

    // 监听事件
    go func() {
        for event := range systemManager.GetEventChannel() {
            fmt.Printf("System event: %+v\n", event)
        }
    }()

    // 保持系统运行
    time.Sleep(60 * time.Second)

    // 停止系统
    err = systemManager.StopSystem()
    if err != nil {
        log.Fatal(err)
    }
    fmt.Println("System stopped")
}
```

## 总结

系统集成实现提供了以下核心功能：

1. **组件管理**：统一注册、初始化、启动、停止各种IoT组件
2. **依赖管理**：确保组件按正确的依赖顺序启动
3. **状态监控**：实时跟踪组件状态和健康信息
4. **系统生命周期**：完整的系统启动和停止流程
5. **健康检查**：定期检查系统整体健康状态
6. **事件系统**：提供系统状态变化的事件通知
7. **配置管理**：统一的系统配置和组件配置管理

这个实现为IoT平台提供了完整的系统集成和协调能力。
