# 数据库访问层实现

## 1. 数据库访问核心架构

### 1.1 数据库连接和连接池

```rust
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};
use sqlx::{Pool, Postgres, Row, FromRow};
use chrono::{DateTime, Utc};

/// 数据库配置
#[derive(Debug, Clone)]
pub struct DatabaseConfig {
    pub host: String,
    pub port: u16,
    pub database: String,
    pub username: String,
    pub password: String,
    pub max_connections: u32,
    pub min_connections: u32,
    pub connection_timeout: u64,
    pub idle_timeout: u64,
    pub max_lifetime: u64,
}

/// 数据库连接管理器
pub struct DatabaseManager {
    pool: Pool<Postgres>,
    config: DatabaseConfig,
}

impl DatabaseManager {
    pub async fn new(config: DatabaseConfig) -> Result<Self, Box<dyn std::error::Error>> {
        let database_url = format!(
            "postgresql://{}:{}@{}:{}/{}",
            config.username,
            config.password,
            config.host,
            config.port,
            config.database
        );
        
        let pool = Pool::builder()
            .max_size(config.max_connections)
            .min_size(config.min_connections)
            .connect_timeout(std::time::Duration::from_secs(config.connection_timeout))
            .idle_timeout(std::time::Duration::from_secs(config.idle_timeout))
            .max_lifetime(std::time::Duration::from_secs(config.max_lifetime))
            .build(&database_url)
            .await?;
        
        Ok(Self { pool, config })
    }

    /// 获取连接池
    pub fn get_pool(&self) -> &Pool<Postgres> {
        &self.pool
    }

    /// 健康检查
    pub async fn health_check(&self) -> Result<bool, Box<dyn std::error::Error>> {
        let _row = sqlx::query("SELECT 1").fetch_one(&self.pool).await?;
        Ok(true)
    }

    /// 获取连接池统计
    pub async fn get_stats(&self) -> Result<PoolStats, Box<dyn std::error::Error>> {
        let size = self.pool.size();
        let idle = self.pool.num_idle();
        let active = size - idle;
        
        Ok(PoolStats {
            total_connections: size,
            idle_connections: idle,
            active_connections: active,
            max_connections: self.config.max_connections,
        })
    }
}

/// 连接池统计
#[derive(Debug, Clone)]
pub struct PoolStats {
    pub total_connections: usize,
    pub idle_connections: usize,
    pub active_connections: usize,
    pub max_connections: u32,
}
```

### 1.2 基础实体和Repository模式

```rust
/// 基础实体
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BaseEntity {
    pub id: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub version: u64,
}

/// Repository接口
#[async_trait::async_trait]
pub trait Repository<T>: Send + Sync
where
    T: Clone + Send + Sync + 'static,
{
    async fn find_by_id(&self, id: &str) -> Result<Option<T>, Box<dyn std::error::Error>>;
    async fn find_all(&self) -> Result<Vec<T>, Box<dyn std::error::Error>>;
    async fn find_by_criteria(&self, criteria: QueryCriteria) -> Result<Vec<T>, Box<dyn std::error::Error>>;
    async fn save(&self, entity: &T) -> Result<T, Box<dyn std::error::Error>>;
    async fn update(&self, entity: &T) -> Result<T, Box<dyn std::error::Error>>;
    async fn delete(&self, id: &str) -> Result<bool, Box<dyn std::error::Error>>;
    async fn count(&self) -> Result<u64, Box<dyn std::error::Error>>;
    async fn exists(&self, id: &str) -> Result<bool, Box<dyn std::error::Error>>;
}

/// 查询条件
#[derive(Debug, Clone)]
pub struct QueryCriteria {
    pub filters: Vec<Filter>,
    pub sort_by: Option<String>,
    pub sort_order: Option<SortOrder>,
    pub limit: Option<u64>,
    pub offset: Option<u64>,
}

/// 过滤条件
#[derive(Debug, Clone)]
pub struct Filter {
    pub field: String,
    pub operator: FilterOperator,
    pub value: serde_json::Value,
}

/// 过滤操作符
#[derive(Debug, Clone)]
pub enum FilterOperator {
    Equals,
    NotEquals,
    GreaterThan,
    LessThan,
    GreaterThanOrEqual,
    LessThanOrEqual,
    Like,
    In,
    NotIn,
    IsNull,
    IsNotNull,
}

/// 排序顺序
#[derive(Debug, Clone)]
pub enum SortOrder {
    Asc,
    Desc,
}
```

### 1.3 IoT设备实体和Repository

```rust
/// IoT设备实体
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct Device {
    pub id: String,
    pub name: String,
    pub device_type: String,
    pub location: Option<String>,
    pub status: DeviceStatus,
    pub protocol: String,
    pub connection_info: serde_json::Value,
    pub metadata: serde_json::Value,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub last_seen: Option<DateTime<Utc>>,
    pub version: u64,
}

/// 设备状态
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "device_status", rename_all = "lowercase")]
pub enum DeviceStatus {
    Online,
    Offline,
    Error,
    Maintenance,
}

/// 设备Repository实现
pub struct DeviceRepository {
    pool: Pool<Postgres>,
}

impl DeviceRepository {
    pub fn new(pool: Pool<Postgres>) -> Self {
        Self { pool }
    }

    /// 创建表
    pub async fn create_table(&self) -> Result<(), Box<dyn std::error::Error>> {
        sqlx::query(
            r#"
            CREATE TYPE device_status AS ENUM ('online', 'offline', 'error', 'maintenance');
            
            CREATE TABLE IF NOT EXISTS devices (
                id VARCHAR(255) PRIMARY KEY,
                name VARCHAR(255) NOT NULL,
                device_type VARCHAR(100) NOT NULL,
                location VARCHAR(255),
                status device_status NOT NULL DEFAULT 'offline',
                protocol VARCHAR(50) NOT NULL,
                connection_info JSONB NOT NULL,
                metadata JSONB NOT NULL DEFAULT '{}',
                created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
                updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
                last_seen TIMESTAMP WITH TIME ZONE,
                version BIGINT NOT NULL DEFAULT 1
            );
            
            CREATE INDEX IF NOT EXISTS idx_devices_status ON devices(status);
            CREATE INDEX IF NOT EXISTS idx_devices_type ON devices(device_type);
            CREATE INDEX IF NOT EXISTS idx_devices_location ON devices(location);
            CREATE INDEX IF NOT EXISTS idx_devices_last_seen ON devices(last_seen);
            "#
        )
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }

    /// 根据状态查找设备
    pub async fn find_by_status(&self, status: DeviceStatus) -> Result<Vec<Device>, Box<dyn std::error::Error>> {
        let devices = sqlx::query_as::<_, Device>(
            "SELECT * FROM devices WHERE status = $1 ORDER BY created_at DESC"
        )
        .bind(status)
        .fetch_all(&self.pool)
        .await?;
        
        Ok(devices)
    }

    /// 根据设备类型查找
    pub async fn find_by_type(&self, device_type: &str) -> Result<Vec<Device>, Box<dyn std::error::Error>> {
        let devices = sqlx::query_as::<_, Device>(
            "SELECT * FROM devices WHERE device_type = $1 ORDER BY created_at DESC"
        )
        .bind(device_type)
        .fetch_all(&self.pool)
        .await?;
        
        Ok(devices)
    }

    /// 更新设备状态
    pub async fn update_status(&self, id: &str, status: DeviceStatus) -> Result<bool, Box<dyn std::error::Error>> {
        let result = sqlx::query(
            "UPDATE devices SET status = $1, updated_at = NOW(), version = version + 1 WHERE id = $2"
        )
        .bind(status)
        .bind(id)
        .execute(&self.pool)
        .await?;
        
        Ok(result.rows_affected() > 0)
    }

    /// 更新最后在线时间
    pub async fn update_last_seen(&self, id: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let result = sqlx::query(
            "UPDATE devices SET last_seen = NOW(), updated_at = NOW(), version = version + 1 WHERE id = $1"
        )
        .bind(id)
        .execute(&self.pool)
        .await?;
        
        Ok(result.rows_affected() > 0)
    }

    /// 批量更新状态
    pub async fn batch_update_status(&self, updates: Vec<(String, DeviceStatus)>) -> Result<u64, Box<dyn std::error::Error>> {
        let mut transaction = self.pool.begin().await?;
        let mut updated_count = 0;
        
        for (id, status) in updates {
            let result = sqlx::query(
                "UPDATE devices SET status = $1, updated_at = NOW(), version = version + 1 WHERE id = $2"
            )
            .bind(status)
            .bind(id)
            .execute(&mut transaction)
            .await?;
            
            updated_count += result.rows_affected();
        }
        
        transaction.commit().await?;
        Ok(updated_count)
    }
}

#[async_trait::async_trait]
impl Repository<Device> for DeviceRepository {
    async fn find_by_id(&self, id: &str) -> Result<Option<Device>, Box<dyn std::error::Error>> {
        let device = sqlx::query_as::<_, Device>(
            "SELECT * FROM devices WHERE id = $1"
        )
        .bind(id)
        .fetch_optional(&self.pool)
        .await?;
        
        Ok(device)
    }

    async fn find_all(&self) -> Result<Vec<Device>, Box<dyn std::error::Error>> {
        let devices = sqlx::query_as::<_, Device>(
            "SELECT * FROM devices ORDER BY created_at DESC"
        )
        .fetch_all(&self.pool)
        .await?;
        
        Ok(devices)
    }

    async fn find_by_criteria(&self, criteria: QueryCriteria) -> Result<Vec<Device>, Box<dyn std::error::Error>> {
        let mut query = "SELECT * FROM devices".to_string();
        let mut conditions = Vec::new();
        let mut bind_values = Vec::new();
        let mut param_count = 1;
        
        // 构建WHERE子句
        for filter in &criteria.filters {
            let condition = match filter.operator {
                FilterOperator::Equals => format!("{} = ${}", filter.field, param_count),
                FilterOperator::NotEquals => format!("{} != ${}", filter.field, param_count),
                FilterOperator::GreaterThan => format!("{} > ${}", filter.field, param_count),
                FilterOperator::LessThan => format!("{} < ${}", filter.field, param_count),
                FilterOperator::GreaterThanOrEqual => format!("{} >= ${}", filter.field, param_count),
                FilterOperator::LessThanOrEqual => format!("{} <= ${}", filter.field, param_count),
                FilterOperator::Like => format!("{} LIKE ${}", filter.field, param_count),
                FilterOperator::In => format!("{} = ANY(${})", filter.field, param_count),
                FilterOperator::NotIn => format!("{} != ALL(${})", filter.field, param_count),
                FilterOperator::IsNull => format!("{} IS NULL", filter.field),
                FilterOperator::IsNotNull => format!("{} IS NOT NULL", filter.field),
            };
            
            conditions.push(condition);
            bind_values.push(filter.value.clone());
            param_count += 1;
        }
        
        if !conditions.is_empty() {
            query.push_str(" WHERE ");
            query.push_str(&conditions.join(" AND "));
        }
        
        // 添加排序
        if let Some(sort_by) = &criteria.sort_by {
            query.push_str(&format!(" ORDER BY {}", sort_by));
            if let Some(sort_order) = &criteria.sort_order {
                match sort_order {
                    SortOrder::Asc => query.push_str(" ASC"),
                    SortOrder::Desc => query.push_str(" DESC"),
                }
            }
        }
        
        // 添加分页
        if let Some(limit) = criteria.limit {
            query.push_str(&format!(" LIMIT {}", limit));
        }
        
        if let Some(offset) = criteria.offset {
            query.push_str(&format!(" OFFSET {}", offset));
        }
        
        // 执行查询
        let mut query_builder = sqlx::query_as::<_, Device>(&query);
        for value in bind_values {
            query_builder = query_builder.bind(value);
        }
        
        let devices = query_builder.fetch_all(&self.pool).await?;
        Ok(devices)
    }

    async fn save(&self, entity: &Device) -> Result<Device, Box<dyn std::error::Error>> {
        let device = sqlx::query_as::<_, Device>(
            r#"
            INSERT INTO devices (id, name, device_type, location, status, protocol, connection_info, metadata, created_at, updated_at, last_seen, version)
            VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
            RETURNING *
            "#
        )
        .bind(&entity.id)
        .bind(&entity.name)
        .bind(&entity.device_type)
        .bind(&entity.location)
        .bind(&entity.status)
        .bind(&entity.protocol)
        .bind(&entity.connection_info)
        .bind(&entity.metadata)
        .bind(&entity.created_at)
        .bind(&entity.updated_at)
        .bind(&entity.last_seen)
        .bind(&entity.version)
        .fetch_one(&self.pool)
        .await?;
        
        Ok(device)
    }

    async fn update(&self, entity: &Device) -> Result<Device, Box<dyn std::error::Error>> {
        let device = sqlx::query_as::<_, Device>(
            r#"
            UPDATE devices 
            SET name = $2, device_type = $3, location = $4, status = $5, protocol = $6, 
                connection_info = $7, metadata = $8, updated_at = NOW(), last_seen = $9, version = $10
            WHERE id = $1 AND version = $10
            RETURNING *
            "#
        )
        .bind(&entity.id)
        .bind(&entity.name)
        .bind(&entity.device_type)
        .bind(&entity.location)
        .bind(&entity.status)
        .bind(&entity.protocol)
        .bind(&entity.connection_info)
        .bind(&entity.metadata)
        .bind(&entity.last_seen)
        .bind(&entity.version)
        .fetch_one(&self.pool)
        .await?;
        
        Ok(device)
    }

    async fn delete(&self, id: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let result = sqlx::query("DELETE FROM devices WHERE id = $1")
            .bind(id)
            .execute(&self.pool)
            .await?;
        
        Ok(result.rows_affected() > 0)
    }

    async fn count(&self) -> Result<u64, Box<dyn std::error::Error>> {
        let row = sqlx::query("SELECT COUNT(*) as count FROM devices")
            .fetch_one(&self.pool)
            .await?;
        
        let count: i64 = row.get("count");
        Ok(count as u64)
    }

    async fn exists(&self, id: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let row = sqlx::query("SELECT EXISTS(SELECT 1 FROM devices WHERE id = $1) as exists")
            .bind(id)
            .fetch_one(&self.pool)
            .await?;
        
        let exists: bool = row.get("exists");
        Ok(exists)
    }
}
```

### 1.4 传感器数据实体和Repository

```rust
/// 传感器数据实体
#[derive(Debug, Clone, Serialize, Deserialize, FromRow)]
pub struct SensorData {
    pub id: String,
    pub device_id: String,
    pub sensor_type: String,
    pub value: f64,
    pub unit: String,
    pub timestamp: DateTime<Utc>,
    pub quality: DataQuality,
    pub metadata: serde_json::Value,
    pub created_at: DateTime<Utc>,
}

/// 数据质量
#[derive(Debug, Clone, Serialize, Deserialize, sqlx::Type)]
#[sqlx(type_name = "data_quality", rename_all = "lowercase")]
pub enum DataQuality {
    Good,
    Uncertain,
    Bad,
}

/// 传感器数据Repository
pub struct SensorDataRepository {
    pool: Pool<Postgres>,
}

impl SensorDataRepository {
    pub fn new(pool: Pool<Postgres>) -> Self {
        Self { pool }
    }

    /// 创建表
    pub async fn create_table(&self) -> Result<(), Box<dyn std::error::Error>> {
        sqlx::query(
            r#"
            CREATE TYPE data_quality AS ENUM ('good', 'uncertain', 'bad');
            
            CREATE TABLE IF NOT EXISTS sensor_data (
                id VARCHAR(255) PRIMARY KEY,
                device_id VARCHAR(255) NOT NULL,
                sensor_type VARCHAR(100) NOT NULL,
                value DOUBLE PRECISION NOT NULL,
                unit VARCHAR(50) NOT NULL,
                timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
                quality data_quality NOT NULL DEFAULT 'good',
                metadata JSONB NOT NULL DEFAULT '{}',
                created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
            );
            
            CREATE INDEX IF NOT EXISTS idx_sensor_data_device_id ON sensor_data(device_id);
            CREATE INDEX IF NOT EXISTS idx_sensor_data_timestamp ON sensor_data(timestamp);
            CREATE INDEX IF NOT EXISTS idx_sensor_data_type ON sensor_data(sensor_type);
            CREATE INDEX IF NOT EXISTS idx_sensor_data_quality ON sensor_data(quality);
            "#
        )
        .execute(&self.pool)
        .await?;
        
        Ok(())
    }

    /// 批量插入数据
    pub async fn batch_insert(&self, data: Vec<SensorData>) -> Result<u64, Box<dyn std::error::Error>> {
        let mut transaction = self.pool.begin().await?;
        let mut inserted_count = 0;
        
        for item in data {
            let result = sqlx::query(
                r#"
                INSERT INTO sensor_data (id, device_id, sensor_type, value, unit, timestamp, quality, metadata, created_at)
                VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                "#
            )
            .bind(&item.id)
            .bind(&item.device_id)
            .bind(&item.sensor_type)
            .bind(&item.value)
            .bind(&item.unit)
            .bind(&item.timestamp)
            .bind(&item.quality)
            .bind(&item.metadata)
            .bind(&item.created_at)
            .execute(&mut transaction)
            .await?;
            
            inserted_count += result.rows_affected();
        }
        
        transaction.commit().await?;
        Ok(inserted_count)
    }

    /// 根据设备ID和时间范围查询数据
    pub async fn find_by_device_and_time_range(
        &self,
        device_id: &str,
        start_time: DateTime<Utc>,
        end_time: DateTime<Utc>,
        limit: Option<u64>,
    ) -> Result<Vec<SensorData>, Box<dyn std::error::Error>> {
        let mut query = sqlx::query_as::<_, SensorData>(
            "SELECT * FROM sensor_data WHERE device_id = $1 AND timestamp BETWEEN $2 AND $3 ORDER BY timestamp DESC"
        )
        .bind(device_id)
        .bind(start_time)
        .bind(end_time);
        
        if let Some(limit_val) = limit {
            query = query.bind(limit_val);
        }
        
        let data = query.fetch_all(&self.pool).await?;
        Ok(data)
    }

    /// 获取聚合数据
    pub async fn get_aggregated_data(
        &self,
        device_id: &str,
        sensor_type: &str,
        start_time: DateTime<Utc>,
        end_time: DateTime<Utc>,
        aggregation: AggregationType,
    ) -> Result<AggregatedData, Box<dyn std::error::Error>> {
        let sql = match aggregation {
            AggregationType::Average => {
                "SELECT AVG(value) as value, COUNT(*) as count, MIN(value) as min_value, MAX(value) as max_value FROM sensor_data WHERE device_id = $1 AND sensor_type = $2 AND timestamp BETWEEN $3 AND $4"
            }
            AggregationType::Sum => {
                "SELECT SUM(value) as value, COUNT(*) as count, MIN(value) as min_value, MAX(value) as max_value FROM sensor_data WHERE device_id = $1 AND sensor_type = $2 AND timestamp BETWEEN $3 AND $4"
            }
            AggregationType::Min => {
                "SELECT MIN(value) as value, COUNT(*) as count, MIN(value) as min_value, MAX(value) as max_value FROM sensor_data WHERE device_id = $1 AND sensor_type = $2 AND timestamp BETWEEN $3 AND $4"
            }
            AggregationType::Max => {
                "SELECT MAX(value) as value, COUNT(*) as count, MIN(value) as min_value, MAX(value) as max_value FROM sensor_data WHERE device_id = $1 AND sensor_type = $2 AND timestamp BETWEEN $3 AND $4"
            }
        };
        
        let row = sqlx::query(sql)
            .bind(device_id)
            .bind(sensor_type)
            .bind(start_time)
            .bind(end_time)
            .fetch_one(&self.pool)
            .await?;
        
        let aggregated_data = AggregatedData {
            value: row.get("value"),
            count: row.get("count"),
            min_value: row.get("min_value"),
            max_value: row.get("max_value"),
            aggregation_type: aggregation,
        };
        
        Ok(aggregated_data)
    }
}

/// 聚合类型
#[derive(Debug, Clone)]
pub enum AggregationType {
    Average,
    Sum,
    Min,
    Max,
}

/// 聚合数据
#[derive(Debug, Clone)]
pub struct AggregatedData {
    pub value: Option<f64>,
    pub count: i64,
    pub min_value: Option<f64>,
    pub max_value: Option<f64>,
    pub aggregation_type: AggregationType,
}
```

## 2. 应用示例

### 2.1 IoT数据库管理

```rust
use crate::database::{DatabaseManager, DatabaseConfig, DeviceRepository, SensorDataRepository, Device, SensorData, DeviceStatus, DataQuality};

async fn iot_database_management() -> Result<(), Box<dyn std::error::Error>> {
    // 创建数据库配置
    let config = DatabaseConfig {
        host: "localhost".to_string(),
        port: 5432,
        database: "iot_platform".to_string(),
        username: "iot_user".to_string(),
        password: "iot_password".to_string(),
        max_connections: 20,
        min_connections: 5,
        connection_timeout: 30,
        idle_timeout: 300,
        max_lifetime: 3600,
    };
    
    // 创建数据库管理器
    let db_manager = DatabaseManager::new(config).await?;
    
    // 健康检查
    if !db_manager.health_check().await? {
        return Err("Database health check failed".into());
    }
    
    // 获取连接池统计
    let stats = db_manager.get_stats().await?;
    println!("Database pool stats: {:?}", stats);
    
    // 创建设备Repository
    let device_repo = DeviceRepository::new(db_manager.get_pool().clone());
    device_repo.create_table().await?;
    
    // 创建传感器数据Repository
    let sensor_data_repo = SensorDataRepository::new(db_manager.get_pool().clone());
    sensor_data_repo.create_table().await?;
    
    // 创建设备
    let device = Device {
        id: "sensor-001".to_string(),
        name: "Temperature Sensor 1".to_string(),
        device_type: "temperature".to_string(),
        location: Some("Building A - Room 101".to_string()),
        status: DeviceStatus::Online,
        protocol: "mqtt".to_string(),
        connection_info: serde_json::json!({
            "broker": "mqtt://localhost:1883",
            "topic": "sensors/temperature/001",
            "qos": 1
        }),
        metadata: serde_json::json!({
            "manufacturer": "SensorCorp",
            "model": "TEMP-2000",
            "calibration_date": "2024-01-15"
        }),
        created_at: Utc::now(),
        updated_at: Utc::now(),
        last_seen: Some(Utc::now()),
        version: 1,
    };
    
    let saved_device = device_repo.save(&device).await?;
    println!("Saved device: {:?}", saved_device);
    
    // 创建传感器数据
    let sensor_data = vec![
        SensorData {
            id: uuid::Uuid::new_v4().to_string(),
            device_id: "sensor-001".to_string(),
            sensor_type: "temperature".to_string(),
            value: 25.5,
            unit: "°C".to_string(),
            timestamp: Utc::now(),
            quality: DataQuality::Good,
            metadata: serde_json::json!({
                "accuracy": 0.1,
                "calibration_offset": 0.0
            }),
            created_at: Utc::now(),
        },
        SensorData {
            id: uuid::Uuid::new_v4().to_string(),
            device_id: "sensor-001".to_string(),
            sensor_type: "humidity".to_string(),
            value: 60.0,
            unit: "%".to_string(),
            timestamp: Utc::now(),
            quality: DataQuality::Good,
            metadata: serde_json::json!({
                "accuracy": 2.0,
                "calibration_offset": 0.0
            }),
            created_at: Utc::now(),
        },
    ];
    
    let inserted_count = sensor_data_repo.batch_insert(sensor_data).await?;
    println!("Inserted {} sensor data records", inserted_count);
    
    // 查询设备
    let found_device = device_repo.find_by_id("sensor-001").await?;
    if let Some(device) = found_device {
        println!("Found device: {:?}", device);
    }
    
    // 查询在线设备
    let online_devices = device_repo.find_by_status(DeviceStatus::Online).await?;
    println!("Online devices: {}", online_devices.len());
    
    // 查询传感器数据
    let start_time = Utc::now() - chrono::Duration::hours(1);
    let end_time = Utc::now();
    let data = sensor_data_repo.find_by_device_and_time_range(
        "sensor-001",
        start_time,
        end_time,
        Some(100),
    ).await?;
    println!("Found {} sensor data records", data.len());
    
    // 获取聚合数据
    let aggregated_data = sensor_data_repo.get_aggregated_data(
        "sensor-001",
        "temperature",
        start_time,
        end_time,
        AggregationType::Average,
    ).await?;
    println!("Aggregated data: {:?}", aggregated_data);
    
    // 更新设备状态
    device_repo.update_status("sensor-001", DeviceStatus::Maintenance).await?;
    println!("Updated device status to maintenance");
    
    // 查询设备数量
    let device_count = device_repo.count().await?;
    println!("Total devices: {}", device_count);
    
    // 使用查询条件
    let criteria = QueryCriteria {
        filters: vec![
            Filter {
                field: "device_type".to_string(),
                operator: FilterOperator::Equals,
                value: serde_json::json!("temperature"),
            },
            Filter {
                field: "status".to_string(),
                operator: FilterOperator::Equals,
                value: serde_json::json!("online"),
            },
        ],
        sort_by: Some("created_at".to_string()),
        sort_order: Some(SortOrder::Desc),
        limit: Some(10),
        offset: None,
    };
    
    let filtered_devices = device_repo.find_by_criteria(criteria).await?;
    println!("Filtered devices: {}", filtered_devices.len());
    
    Ok(())
}
```

## 3. 总结

本实现提供了：

1. **数据库连接管理** - 连接池和健康检查
2. **Repository模式** - 统一的数据访问接口
3. **实体映射** - 自动的数据库映射
4. **查询构建器** - 灵活的查询条件
5. **批量操作** - 高性能的批量数据处理
6. **聚合查询** - 数据统计和分析
7. **实际应用示例** - IoT数据库管理

这个数据库访问层为IoT平台提供了高效、可靠的数据持久化能力，支持复杂的查询和数据分析。
