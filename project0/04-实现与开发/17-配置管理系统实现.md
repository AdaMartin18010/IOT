# 配置管理系统实现

## 目录

- [配置管理系统实现](#配置管理系统实现)
  - [目录](#目录)
  - [1. 配置管理核心](#1-配置管理核心)
    - [1.1 配置管理系统架构](#11-配置管理系统架构)
    - [1.2 配置存储](#12-配置存储)
  - [2. 配置验证器](#2-配置验证器)
    - [2.1 配置验证器](#21-配置验证器)
  - [3. 配置加载器](#3-配置加载器)
    - [3.1 配置加载器](#31-配置加载器)
  - [4. 配置监听器](#4-配置监听器)
    - [4.1 配置监听器](#41-配置监听器)

## 1. 配置管理核心

### 1.1 配置管理系统架构

```rust
use std::collections::HashMap;
use tokio::sync::RwLock;
use serde::{Deserialize, Serialize};

// 配置管理系统
#[derive(Debug, Clone)]
pub struct ConfigurationManagementSystem {
    pub config_store: ConfigStore,
    pub config_validator: ConfigValidator,
    pub config_loader: ConfigLoader,
    pub config_watcher: ConfigWatcher,
    pub config_distributor: ConfigDistributor,
}

impl ConfigurationManagementSystem {
    pub fn new() -> Self {
        Self {
            config_store: ConfigStore::new(),
            config_validator: ConfigValidator::new(),
            config_loader: ConfigLoader::new(),
            config_watcher: ConfigWatcher::new(),
            config_distributor: ConfigDistributor::new(),
        }
    }

    // 初始化配置管理
    pub async fn initialize(
        &self,
        config: &SystemConfig,
    ) -> Result<(), ConfigError> {
        // 加载初始配置
        let initial_configs = self.config_loader.load_initial_configs(config).await?;
        
        // 验证配置
        for config in &initial_configs {
            self.config_validator.validate_config(config).await?;
        }
        
        // 存储配置
        for config in initial_configs {
            self.config_store.store_config(config).await?;
        }
        
        // 启动配置监听
        self.config_watcher.start_watching(config).await?;
        
        // 启动配置分发
        self.config_distributor.start_distribution(config).await?;
        
        Ok(())
    }

    // 获取配置
    pub async fn get_config(
        &self,
        config_id: &str,
        version: Option<String>,
    ) -> Result<Configuration, ConfigError> {
        // 从存储中获取配置
        let config = self.config_store.get_config(config_id, version).await?;
        
        // 验证配置
        self.config_validator.validate_config(&config).await?;
        
        Ok(config)
    }

    // 更新配置
    pub async fn update_config(
        &self,
        config_id: &str,
        updates: &ConfigUpdates,
    ) -> Result<Configuration, ConfigError> {
        // 获取当前配置
        let current_config = self.get_config(config_id, None).await?;
        
        // 应用更新
        let updated_config = self.apply_config_updates(&current_config, updates).await?;
        
        // 验证更新后的配置
        self.config_validator.validate_config(&updated_config).await?;
        
        // 存储更新后的配置
        self.config_store.store_config(updated_config.clone()).await?;
        
        // 分发配置更新
        self.config_distributor.distribute_config_update(
            config_id,
            &updated_config,
        ).await?;
        
        Ok(updated_config)
    }

    // 应用配置更新
    async fn apply_config_updates(
        &self,
        current_config: &Configuration,
        updates: &ConfigUpdates,
    ) -> Result<Configuration, ConfigError> {
        let mut updated_config = current_config.clone();
        
        // 应用字段更新
        for (field_path, value) in &updates.field_updates {
            self.update_config_field(&mut updated_config, field_path, value).await?;
        }
        
        // 应用环境特定配置
        for (environment, env_config) in &updates.environment_configs {
            self.apply_environment_config(&mut updated_config, environment, env_config).await?;
        }
        
        // 更新版本信息
        updated_config.version = self.generate_new_version(&current_config.version).await?;
        updated_config.last_modified = chrono::Utc::now();
        
        Ok(updated_config)
    }

    // 监听配置变化
    pub async fn watch_config_changes(
        &self,
        config_id: &str,
        callback: ConfigChangeCallback,
    ) -> Result<ConfigWatcherHandle, ConfigError> {
        self.config_watcher.watch_config(config_id, callback).await
    }

    // 回滚配置
    pub async fn rollback_config(
        &self,
        config_id: &str,
        target_version: &str,
    ) -> Result<Configuration, ConfigError> {
        // 获取目标版本配置
        let target_config = self.get_config(config_id, Some(target_version.to_string())).await?;
        
        // 验证目标配置
        self.config_validator.validate_config(&target_config).await?;
        
        // 存储回滚配置
        self.config_store.store_config(target_config.clone()).await?;
        
        // 分发回滚通知
        self.config_distributor.distribute_config_rollback(
            config_id,
            &target_config,
        ).await?;
        
        Ok(target_config)
    }
}
```

### 1.2 配置存储

```rust
// 配置存储
#[derive(Debug, Clone)]
pub struct ConfigStore {
    pub storage_backend: StorageBackend,
    pub cache_manager: CacheManager,
    pub version_manager: VersionManager,
}

impl ConfigStore {
    pub fn new() -> Self {
        Self {
            storage_backend: StorageBackend::new(),
            cache_manager: CacheManager::new(),
            version_manager: VersionManager::new(),
        }
    }

    // 存储配置
    pub async fn store_config(
        &self,
        config: Configuration,
    ) -> Result<(), ConfigError> {
        // 生成版本
        let versioned_config = self.version_manager.create_version(&config).await?;
        
        // 存储到后端
        self.storage_backend.store_config(&versioned_config).await?;
        
        // 更新缓存
        self.cache_manager.update_cache(&versioned_config).await?;
        
        Ok(())
    }

    // 获取配置
    pub async fn get_config(
        &self,
        config_id: &str,
        version: Option<String>,
    ) -> Result<Configuration, ConfigError> {
        // 尝试从缓存获取
        if let Some(cached_config) = self.cache_manager.get_config(config_id, &version).await? {
            return Ok(cached_config);
        }
        
        // 从存储后端获取
        let config = self.storage_backend.get_config(config_id, version).await?;
        
        // 更新缓存
        self.cache_manager.update_cache(&config).await?;
        
        Ok(config)
    }

    // 列出配置版本
    pub async fn list_config_versions(
        &self,
        config_id: &str,
    ) -> Result<Vec<ConfigVersion>, ConfigError> {
        self.version_manager.list_versions(config_id).await
    }

    // 删除配置
    pub async fn delete_config(
        &self,
        config_id: &str,
        version: Option<String>,
    ) -> Result<(), ConfigError> {
        // 从存储后端删除
        self.storage_backend.delete_config(config_id, version).await?;
        
        // 从缓存删除
        self.cache_manager.delete_config(config_id, &version).await?;
        
        Ok(())
    }
}

// 存储后端
#[derive(Debug, Clone)]
pub struct StorageBackend {
    pub file_storage: FileStorage,
    pub database_storage: DatabaseStorage,
    pub cloud_storage: CloudStorage,
}

impl StorageBackend {
    pub fn new() -> Self {
        Self {
            file_storage: FileStorage::new(),
            database_storage: DatabaseStorage::new(),
            cloud_storage: CloudStorage::new(),
        }
    }

    // 存储配置
    pub async fn store_config(
        &self,
        config: &VersionedConfiguration,
    ) -> Result<(), ConfigError> {
        match config.storage_type {
            StorageType::File => {
                self.file_storage.store_config(config).await?;
            }
            StorageType::Database => {
                self.database_storage.store_config(config).await?;
            }
            StorageType::Cloud => {
                self.cloud_storage.store_config(config).await?;
            }
        }
        
        Ok(())
    }

    // 获取配置
    pub async fn get_config(
        &self,
        config_id: &str,
        version: Option<String>,
    ) -> Result<Configuration, ConfigError> {
        // 尝试从文件存储获取
        if let Ok(config) = self.file_storage.get_config(config_id, &version).await {
            return Ok(config);
        }
        
        // 尝试从数据库存储获取
        if let Ok(config) = self.database_storage.get_config(config_id, &version).await {
            return Ok(config);
        }
        
        // 尝试从云存储获取
        if let Ok(config) = self.cloud_storage.get_config(config_id, &version).await {
            return Ok(config);
        }
        
        Err(ConfigError::ConfigNotFound)
    }
}

// 文件存储
#[derive(Debug, Clone)]
pub struct FileStorage {
    pub base_path: std::path::PathBuf,
    pub file_format: FileFormat,
}

impl FileStorage {
    pub fn new() -> Self {
        Self {
            base_path: std::path::PathBuf::from("./configs"),
            file_format: FileFormat::JSON,
        }
    }

    // 存储配置到文件
    pub async fn store_config(
        &self,
        config: &VersionedConfiguration,
    ) -> Result<(), ConfigError> {
        // 构建文件路径
        let file_path = self.build_file_path(&config.config.id, &config.version).await?;
        
        // 确保目录存在
        if let Some(parent) = file_path.parent() {
            tokio::fs::create_dir_all(parent).await
                .map_err(|e| ConfigError::FileSystemError(e.to_string()))?;
        }
        
        // 序列化配置
        let content = match self.file_format {
            FileFormat::JSON => {
                serde_json::to_string_pretty(&config.config)
                    .map_err(|e| ConfigError::SerializationError(e.to_string()))?
            }
            FileFormat::YAML => {
                serde_yaml::to_string(&config.config)
                    .map_err(|e| ConfigError::SerializationError(e.to_string()))?
            }
            FileFormat::TOML => {
                toml::to_string_pretty(&config.config)
                    .map_err(|e| ConfigError::SerializationError(e.to_string()))?
            }
        };
        
        // 写入文件
        tokio::fs::write(&file_path, content).await
            .map_err(|e| ConfigError::FileSystemError(e.to_string()))?;
        
        Ok(())
    }

    // 从文件读取配置
    pub async fn get_config(
        &self,
        config_id: &str,
        version: &Option<String>,
    ) -> Result<Configuration, ConfigError> {
        // 构建文件路径
        let file_path = self.build_file_path(config_id, version).await?;
        
        // 检查文件是否存在
        if !file_path.exists() {
            return Err(ConfigError::ConfigNotFound);
        }
        
        // 读取文件内容
        let content = tokio::fs::read_to_string(&file_path).await
            .map_err(|e| ConfigError::FileSystemError(e.to_string()))?;
        
        // 反序列化配置
        let config = match self.file_format {
            FileFormat::JSON => {
                serde_json::from_str(&content)
                    .map_err(|e| ConfigError::DeserializationError(e.to_string()))?
            }
            FileFormat::YAML => {
                serde_yaml::from_str(&content)
                    .map_err(|e| ConfigError::DeserializationError(e.to_string()))?
            }
            FileFormat::TOML => {
                toml::from_str(&content)
                    .map_err(|e| ConfigError::DeserializationError(e.to_string()))?
            }
        };
        
        Ok(config)
    }

    // 构建文件路径
    async fn build_file_path(
        &self,
        config_id: &str,
        version: &Option<String>,
    ) -> Result<std::path::PathBuf, ConfigError> {
        let mut path = self.base_path.clone();
        path.push(config_id);
        
        if let Some(ver) = version {
            path.push(format!("{}.{}", ver, self.file_format.extension()));
        } else {
            path.push(format!("latest.{}", self.file_format.extension()));
        }
        
        Ok(path)
    }
}
```

## 2. 配置验证器

### 2.1 配置验证器

```rust
// 配置验证器
#[derive(Debug, Clone)]
pub struct ConfigValidator {
    pub schema_validator: SchemaValidator,
    pub constraint_validator: ConstraintValidator,
    pub dependency_validator: DependencyValidator,
}

impl ConfigValidator {
    pub fn new() -> Self {
        Self {
            schema_validator: SchemaValidator::new(),
            constraint_validator: ConstraintValidator::new(),
            dependency_validator: DependencyValidator::new(),
        }
    }

    // 验证配置
    pub async fn validate_config(
        &self,
        config: &Configuration,
    ) -> Result<ValidationResult, ConfigError> {
        let mut validation_result = ValidationResult::new();
        
        // 模式验证
        let schema_result = self.schema_validator.validate_schema(config).await?;
        validation_result.add_schema_result(schema_result);
        
        // 约束验证
        let constraint_result = self.constraint_validator.validate_constraints(config).await?;
        validation_result.add_constraint_result(constraint_result);
        
        // 依赖验证
        let dependency_result = self.dependency_validator.validate_dependencies(config).await?;
        validation_result.add_dependency_result(dependency_result);
        
        // 计算总体验证结果
        validation_result.calculate_overall_result();
        
        Ok(validation_result)
    }
}

// 模式验证器
#[derive(Debug, Clone)]
pub struct SchemaValidator {
    pub schema_registry: SchemaRegistry,
    pub json_schema_validator: JsonSchemaValidator,
}

impl SchemaValidator {
    pub fn new() -> Self {
        Self {
            schema_registry: SchemaRegistry::new(),
            json_schema_validator: JsonSchemaValidator::new(),
        }
    }

    // 验证模式
    pub async fn validate_schema(
        &self,
        config: &Configuration,
    ) -> Result<SchemaValidationResult, ConfigError> {
        let mut result = SchemaValidationResult::new();
        
        // 获取配置模式
        let schema = self.schema_registry.get_schema(&config.schema_id).await?;
        
        // 验证JSON模式
        let json_result = self.json_schema_validator.validate(
            &config.data,
            &schema.json_schema,
        ).await?;
        result.add_json_result(json_result);
        
        // 验证类型
        let type_result = self.validate_types(&config.data, &schema.type_definitions).await?;
        result.add_type_result(type_result);
        
        // 验证必需字段
        let required_result = self.validate_required_fields(&config.data, &schema.required_fields).await?;
        result.add_required_result(required_result);
        
        // 计算模式验证结果
        result.calculate_schema_result();
        
        Ok(result)
    }

    // 验证类型
    async fn validate_types(
        &self,
        data: &serde_json::Value,
        type_definitions: &HashMap<String, ConfigType>,
    ) -> Result<TypeValidationResult, ConfigError> {
        let mut result = TypeValidationResult::new();
        
        for (field_path, expected_type) in type_definitions {
            if let Some(value) = self.get_field_value(data, field_path).await? {
                let actual_type = self.get_value_type(&value).await?;
                
                if !self.is_type_compatible(&actual_type, expected_type).await? {
                    result.add_type_error(field_path.clone(), expected_type.clone(), actual_type);
                }
            }
        }
        
        Ok(result)
    }

    // 验证必需字段
    async fn validate_required_fields(
        &self,
        data: &serde_json::Value,
        required_fields: &[String],
    ) -> Result<RequiredFieldValidationResult, ConfigError> {
        let mut result = RequiredFieldValidationResult::new();
        
        for field in required_fields {
            if self.get_field_value(data, field).await?.is_none() {
                result.add_missing_field(field.clone());
            }
        }
        
        Ok(result)
    }
}

// 约束验证器
#[derive(Debug, Clone)]
pub struct ConstraintValidator {
    pub range_validator: RangeValidator,
    pub format_validator: FormatValidator,
    pub custom_validator: CustomValidator,
}

impl ConstraintValidator {
    pub fn new() -> Self {
        Self {
            range_validator: RangeValidator::new(),
            format_validator: FormatValidator::new(),
            custom_validator: CustomValidator::new(),
        }
    }

    // 验证约束
    pub async fn validate_constraints(
        &self,
        config: &Configuration,
    ) -> Result<ConstraintValidationResult, ConfigError> {
        let mut result = ConstraintValidationResult::new();
        
        // 验证范围约束
        let range_result = self.range_validator.validate_ranges(&config.data, &config.constraints).await?;
        result.add_range_result(range_result);
        
        // 验证格式约束
        let format_result = self.format_validator.validate_formats(&config.data, &config.constraints).await?;
        result.add_format_result(format_result);
        
        // 验证自定义约束
        let custom_result = self.custom_validator.validate_custom_constraints(&config.data, &config.constraints).await?;
        result.add_custom_result(custom_result);
        
        // 计算约束验证结果
        result.calculate_constraint_result();
        
        Ok(result)
    }
}
```

## 3. 配置加载器

### 3.1 配置加载器

```rust
// 配置加载器
#[derive(Debug, Clone)]
pub struct ConfigLoader {
    pub file_loader: FileConfigLoader,
    pub environment_loader: EnvironmentConfigLoader,
    pub remote_loader: RemoteConfigLoader,
}

impl ConfigLoader {
    pub fn new() -> Self {
        Self {
            file_loader: FileConfigLoader::new(),
            environment_loader: EnvironmentConfigLoader::new(),
            remote_loader: RemoteConfigLoader::new(),
        }
    }

    // 加载初始配置
    pub async fn load_initial_configs(
        &self,
        system_config: &SystemConfig,
    ) -> Result<Vec<Configuration>, ConfigError> {
        let mut configs = Vec::new();
        
        // 加载文件配置
        if let Some(file_configs) = &system_config.file_configs {
            let file_configs = self.file_loader.load_configs(file_configs).await?;
            configs.extend(file_configs);
        }
        
        // 加载环境配置
        if let Some(env_configs) = &system_config.environment_configs {
            let env_configs = self.environment_loader.load_configs(env_configs).await?;
            configs.extend(env_configs);
        }
        
        // 加载远程配置
        if let Some(remote_configs) = &system_config.remote_configs {
            let remote_configs = self.remote_loader.load_configs(remote_configs).await?;
            configs.extend(remote_configs);
        }
        
        Ok(configs)
    }

    // 热重载配置
    pub async fn hot_reload_configs(
        &self,
        config_paths: &[String],
    ) -> Result<Vec<Configuration>, ConfigError> {
        let mut reloaded_configs = Vec::new();
        
        for path in config_paths {
            let config = self.file_loader.load_single_config(path).await?;
            reloaded_configs.push(config);
        }
        
        Ok(reloaded_configs)
    }
}

// 文件配置加载器
#[derive(Debug, Clone)]
pub struct FileConfigLoader {
    pub supported_formats: Vec<FileFormat>,
    pub config_parser: ConfigParser,
}

impl FileConfigLoader {
    pub fn new() -> Self {
        Self {
            supported_formats: vec![FileFormat::JSON, FileFormat::YAML, FileFormat::TOML],
            config_parser: ConfigParser::new(),
        }
    }

    // 加载配置
    pub async fn load_configs(
        &self,
        file_configs: &[FileConfig],
    ) -> Result<Vec<Configuration>, ConfigError> {
        let mut configs = Vec::new();
        
        for file_config in file_configs {
            let config = self.load_single_config(&file_config.path).await?;
            configs.push(config);
        }
        
        Ok(configs)
    }

    // 加载单个配置
    pub async fn load_single_config(
        &self,
        path: &str,
    ) -> Result<Configuration, ConfigError> {
        // 检查文件格式
        let format = self.detect_file_format(path).await?;
        
        if !self.supported_formats.contains(&format) {
            return Err(ConfigError::UnsupportedFormat);
        }
        
        // 读取文件内容
        let content = tokio::fs::read_to_string(path).await
            .map_err(|e| ConfigError::FileSystemError(e.to_string()))?;
        
        // 解析配置
        let config = self.config_parser.parse_config(&content, &format).await?;
        
        Ok(config)
    }

    // 检测文件格式
    async fn detect_file_format(&self, path: &str) -> Result<FileFormat, ConfigError> {
        if path.ends_with(".json") {
            Ok(FileFormat::JSON)
        } else if path.ends_with(".yaml") || path.ends_with(".yml") {
            Ok(FileFormat::YAML)
        } else if path.ends_with(".toml") {
            Ok(FileFormat::TOML)
        } else {
            Err(ConfigError::UnknownFormat)
        }
    }
}

// 环境配置加载器
#[derive(Debug, Clone)]
pub struct EnvironmentConfigLoader {
    pub env_parser: EnvironmentParser,
}

impl EnvironmentConfigLoader {
    pub fn new() -> Self {
        Self {
            env_parser: EnvironmentParser::new(),
        }
    }

    // 加载环境配置
    pub async fn load_configs(
        &self,
        env_configs: &[EnvironmentConfig],
    ) -> Result<Vec<Configuration>, ConfigError> {
        let mut configs = Vec::new();
        
        for env_config in env_configs {
            let config = self.load_environment_config(env_config).await?;
            configs.push(config);
        }
        
        Ok(configs)
    }

    // 加载环境配置
    async fn load_environment_config(
        &self,
        env_config: &EnvironmentConfig,
    ) -> Result<Configuration, ConfigError> {
        // 解析环境变量
        let env_data = self.env_parser.parse_environment_variables(&env_config.prefix).await?;
        
        // 构建配置
        let config = Configuration {
            id: env_config.id.clone(),
            name: env_config.name.clone(),
            description: "Environment-based configuration".to_string(),
            data: env_data,
            schema_id: env_config.schema_id.clone(),
            version: "1.0.0".to_string(),
            environment: env_config.environment.clone(),
            created_at: chrono::Utc::now(),
            last_modified: chrono::Utc::now(),
        };
        
        Ok(config)
    }
}
```

## 4. 配置监听器

### 4.1 配置监听器

```rust
// 配置监听器
#[derive(Debug, Clone)]
pub struct ConfigWatcher {
    pub file_watcher: FileWatcher,
    pub change_notifier: ChangeNotifier,
    pub watcher_registry: WatcherRegistry,
}

impl ConfigWatcher {
    pub fn new() -> Self {
        Self {
            file_watcher: FileWatcher::new(),
            change_notifier: ChangeNotifier::new(),
            watcher_registry: WatcherRegistry::new(),
        }
    }

    // 开始监听
    pub async fn start_watching(
        &self,
        config: &SystemConfig,
    ) -> Result<(), ConfigError> {
        // 启动文件监听
        if let Some(watch_paths) = &config.watch_paths {
            self.file_watcher.start_watching(watch_paths).await?;
        }
        
        // 启动变化通知
        self.change_notifier.start_notification_service().await?;
        
        Ok(())
    }

    // 监听配置变化
    pub async fn watch_config(
        &self,
        config_id: &str,
        callback: ConfigChangeCallback,
    ) -> Result<ConfigWatcherHandle, ConfigError> {
        // 注册监听器
        let handle = self.watcher_registry.register_watcher(config_id, callback).await?;
        
        Ok(handle)
    }

    // 停止监听
    pub async fn stop_watching(
        &self,
        handle: &ConfigWatcherHandle,
    ) -> Result<(), ConfigError> {
        // 注销监听器
        self.watcher_registry.unregister_watcher(handle).await?;
        
        Ok(())
    }
}

// 文件监听器
#[derive(Debug, Clone)]
pub struct FileWatcher {
    pub watchers: HashMap<String, tokio::task::JoinHandle<()>>,
}

impl FileWatcher {
    pub fn new() -> Self {
        Self {
            watchers: HashMap::new(),
        }
    }

    // 开始监听文件
    pub async fn start_watching(
        &self,
        paths: &[String],
    ) -> Result<(), ConfigError> {
        for path in paths {
            let path_clone = path.clone();
            let handle = tokio::spawn(async move {
                Self::watch_file(path_clone).await;
            });
            
            self.watchers.insert(path.clone(), handle);
        }
        
        Ok(())
    }

    // 监听单个文件
    async fn watch_file(path: String) {
        use notify::{Watcher, RecursiveMode};
        use notify::recommended_watcher;
        
        let (tx, mut rx) = tokio::sync::mpsc::channel(100);
        
        let mut watcher = recommended_watcher(move |res| {
            let _ = tx.blocking_send(res);
        }).unwrap();
        
        watcher.watch(&path, RecursiveMode::NonRecursive).unwrap();
        
        while let Some(res) = rx.recv().await {
            match res {
                Ok(event) => {
                    println!("文件变化: {:?}", event);
                    // 处理文件变化事件
                }
                Err(e) => {
                    eprintln!("监听错误: {:?}", e);
                }
            }
        }
    }
}

// 变化通知器
#[derive(Debug, Clone)]
pub struct ChangeNotifier {
    pub notification_channels: HashMap<String, tokio::sync::broadcast::Sender<ConfigChangeEvent>>,
}

impl ChangeNotifier {
    pub fn new() -> Self {
        Self {
            notification_channels: HashMap::new(),
        }
    }

    // 启动通知服务
    pub async fn start_notification_service(&self) -> Result<(), ConfigError> {
        // 初始化通知通道
        // 这里可以启动一个后台任务来处理通知
        Ok(())
    }

    // 发送配置变化通知
    pub async fn notify_config_change(
        &self,
        config_id: &str,
        change_event: ConfigChangeEvent,
    ) -> Result<(), ConfigError> {
        if let Some(sender) = self.notification_channels.get(config_id) {
            let _ = sender.send(change_event);
        }
        
        Ok(())
    }

    // 订阅配置变化
    pub async fn subscribe_to_changes(
        &self,
        config_id: &str,
    ) -> Result<tokio::sync::broadcast::Receiver<ConfigChangeEvent>, ConfigError> {
        if let Some(sender) = self.notification_channels.get(config_id) {
            Ok(sender.subscribe())
        } else {
            Err(ConfigError::ConfigNotFound)
        }
    }
}
```

---

**配置管理系统实现完成** - 包含配置管理核心、配置存储、配置验证器、配置加载器、配置监听器等核心功能。
