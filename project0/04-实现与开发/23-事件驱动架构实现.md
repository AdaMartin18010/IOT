# 事件驱动架构实现

## 1. 事件总线

### 1.1 事件定义

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};
use uuid::Uuid;

/// 事件类型
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum EventType {
    DeviceCreated,
    DeviceUpdated,
    DeviceDeleted,
    DeviceStatusChanged,
    SensorDataReceived,
    AlertTriggered,
    AlertResolved,
    SystemHealthCheck,
    DataProcessed,
    UserAction,
    Custom(String),
}

/// 事件优先级
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, PartialOrd)]
pub enum EventPriority {
    Low = 1,
    Normal = 2,
    High = 3,
    Critical = 4,
}

/// 事件状态
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum EventStatus {
    Pending,
    Processing,
    Completed,
    Failed,
    Retrying,
}

/// 事件
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Event {
    pub id: String,
    pub event_type: EventType,
    pub source: String,
    pub timestamp: DateTime<Utc>,
    pub priority: EventPriority,
    pub status: EventStatus,
    pub data: serde_json::Value,
    pub metadata: HashMap<String, String>,
    pub correlation_id: Option<String>,
    pub causation_id: Option<String>,
    pub version: u32,
}

impl Event {
    pub fn new(
        event_type: EventType,
        source: String,
        data: serde_json::Value,
    ) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            event_type,
            source,
            timestamp: Utc::now(),
            priority: EventPriority::Normal,
            status: EventStatus::Pending,
            data,
            metadata: HashMap::new(),
            correlation_id: None,
            causation_id: None,
            version: 1,
        }
    }
    
    pub fn with_priority(mut self, priority: EventPriority) -> Self {
        self.priority = priority;
        self
    }
    
    pub fn with_metadata(mut self, metadata: HashMap<String, String>) -> Self {
        self.metadata = metadata;
        self
    }
    
    pub fn with_correlation_id(mut self, correlation_id: String) -> Self {
        self.correlation_id = Some(correlation_id);
        self
    }
    
    pub fn with_causation_id(mut self, causation_id: String) -> Self {
        self.causation_id = Some(causation_id);
        self
    }
}

/// 事件订阅
#[derive(Debug, Clone)]
pub struct EventSubscription {
    pub id: String,
    pub subscriber_id: String,
    pub event_types: Vec<EventType>,
    pub filters: HashMap<String, serde_json::Value>,
    pub callback_url: Option<String>,
    pub created_at: DateTime<Utc>,
    pub active: bool,
}

/// 事件处理器
#[async_trait::async_trait]
pub trait EventHandler: Send + Sync {
    async fn handle_event(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>>;
    fn get_name(&self) -> &str;
    fn get_supported_event_types(&self) -> Vec<EventType>;
}
```

### 1.2 事件总线实现

```rust
use std::sync::{Arc, RwLock};
use tokio::sync::{mpsc, broadcast};
use std::collections::HashMap;
use tokio::time::{Duration, Instant};

/// 事件总线
pub struct EventBus {
    handlers: Arc<RwLock<HashMap<String, Arc<dyn EventHandler>>>>,
    subscriptions: Arc<RwLock<HashMap<String, EventSubscription>>>,
    event_sender: mpsc::Sender<Event>,
    event_receiver: mpsc::Receiver<Event>,
    broadcast_sender: broadcast::Sender<Event>,
    event_store: Arc<dyn EventStore>,
    retry_config: RetryConfig,
}

/// 重试配置
pub struct RetryConfig {
    pub max_retries: u32,
    pub retry_delay: Duration,
    pub backoff_multiplier: f64,
}

impl Default for RetryConfig {
    fn default() -> Self {
        Self {
            max_retries: 3,
            retry_delay: Duration::from_secs(1),
            backoff_multiplier: 2.0,
        }
    }
}

impl EventBus {
    pub fn new(event_store: Arc<dyn EventStore>) -> Self {
        let (event_sender, event_receiver) = mpsc::channel(1000);
        let (broadcast_sender, _) = broadcast::channel(100);
        
        let event_bus = Self {
            handlers: Arc::new(RwLock::new(HashMap::new())),
            subscriptions: Arc::new(RwLock::new(HashMap::new())),
            event_sender,
            event_receiver,
            broadcast_sender,
            event_store,
            retry_config: RetryConfig::default(),
        };
        
        // 启动事件处理循环
        let event_bus_clone = event_bus.clone();
        tokio::spawn(async move {
            event_bus_clone.event_processing_loop().await;
        });
        
        event_bus
    }
    
    /// 发布事件
    pub async fn publish_event(&self, event: Event) -> Result<(), Box<dyn std::error::Error>> {
        // 存储事件
        self.event_store.store_event(&event).await?;
        
        // 发送到处理队列
        self.event_sender.send(event.clone()).await
            .map_err(|e| format!("Failed to send event: {}", e))?;
        
        // 广播事件
        let _ = self.broadcast_sender.send(event);
        
        Ok(())
    }
    
    /// 订阅事件
    pub async fn subscribe(&self, subscription: EventSubscription) -> Result<(), Box<dyn std::error::Error>> {
        let mut subscriptions = self.subscriptions.write().unwrap();
        subscriptions.insert(subscription.id.clone(), subscription);
        Ok(())
    }
    
    /// 取消订阅
    pub async fn unsubscribe(&self, subscription_id: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let mut subscriptions = self.subscriptions.write().unwrap();
        Ok(subscriptions.remove(subscription_id).is_some())
    }
    
    /// 注册事件处理器
    pub async fn register_handler(&self, handler: Arc<dyn EventHandler>) -> Result<(), Box<dyn std::error::Error>> {
        let mut handlers = self.handlers.write().unwrap();
        handlers.insert(handler.get_name().to_string(), handler);
        Ok(())
    }
    
    /// 取消注册事件处理器
    pub async fn unregister_handler(&self, handler_name: &str) -> Result<bool, Box<dyn std::error::Error>> {
        let mut handlers = self.handlers.write().unwrap();
        Ok(handlers.remove(handler_name).is_some())
    }
    
    /// 事件处理循环
    async fn event_processing_loop(&self) {
        while let Some(event) = self.event_receiver.recv().await {
            self.process_event(event).await;
        }
    }
    
    /// 处理单个事件
    async fn process_event(&self, event: Event) {
        let handlers = self.handlers.read().unwrap();
        let subscriptions = self.subscriptions.read().unwrap();
        
        // 查找匹配的处理器
        for handler in handlers.values() {
            if handler.get_supported_event_types().contains(&event.event_type) {
                let handler_clone = handler.clone();
                let event_clone = event.clone();
                
                // 异步处理事件
                tokio::spawn(async move {
                    Self::handle_event_with_retry(handler_clone.as_ref(), &event_clone).await;
                });
            }
        }
        
        // 处理订阅
        for subscription in subscriptions.values() {
            if subscription.active && subscription.event_types.contains(&event.event_type) {
                if let Some(callback_url) = &subscription.callback_url {
                    let event_clone = event.clone();
                    let callback_url_clone = callback_url.clone();
                    
                    tokio::spawn(async move {
                        Self::send_event_to_callback(&callback_url_clone, &event_clone).await;
                    });
                }
            }
        }
    }
    
    /// 带重试的事件处理
    async fn handle_event_with_retry(handler: &dyn EventHandler, event: &Event) {
        let mut retry_count = 0;
        let mut delay = Duration::from_secs(1);
        
        while retry_count < 3 {
            match handler.handle_event(event).await {
                Ok(_) => {
                    println!("Event {} handled successfully by {}", event.id, handler.get_name());
                    return;
                }
                Err(e) => {
                    retry_count += 1;
                    println!("Event {} handling failed by {} (attempt {}/3): {}", 
                        event.id, handler.get_name(), retry_count, e);
                    
                    if retry_count < 3 {
                        tokio::time::sleep(delay).await;
                        delay = Duration::from_secs((delay.as_secs_f64() * 2.0) as u64);
                    }
                }
            }
        }
        
        println!("Event {} handling failed after {} retries", event.id, retry_count);
    }
    
    /// 发送事件到回调URL
    async fn send_event_to_callback(callback_url: &str, event: &Event) {
        let client = reqwest::Client::new();
        
        match client.post(callback_url)
            .json(event)
            .send()
            .await
        {
            Ok(response) => {
                if response.status().is_success() {
                    println!("Event {} sent to callback {} successfully", event.id, callback_url);
                } else {
                    println!("Event {} sent to callback {} failed with status: {}", 
                        event.id, callback_url, response.status());
                }
            }
            Err(e) => {
                println!("Failed to send event {} to callback {}: {}", event.id, callback_url, e);
            }
        }
    }
    
    /// 获取事件历史
    pub async fn get_event_history(
        &self,
        event_type: Option<EventType>,
        source: Option<String>,
        start_time: Option<DateTime<Utc>>,
        end_time: Option<DateTime<Utc>>,
        limit: Option<u32>,
    ) -> Result<Vec<Event>, Box<dyn std::error::Error>> {
        self.event_store.get_events(event_type, source, start_time, end_time, limit).await
    }
    
    /// 获取事件统计
    pub async fn get_event_stats(&self) -> Result<EventStats, Box<dyn std::error::Error>> {
        self.event_store.get_event_stats().await
    }
}

/// 事件统计
pub struct EventStats {
    pub total_events: u64,
    pub events_by_type: HashMap<EventType, u64>,
    pub events_by_source: HashMap<String, u64>,
    pub events_by_status: HashMap<EventStatus, u64>,
    pub average_processing_time: Duration,
}

impl Clone for EventBus {
    fn clone(&self) -> Self {
        Self {
            handlers: self.handlers.clone(),
            subscriptions: self.subscriptions.clone(),
            event_sender: self.event_sender.clone(),
            event_receiver: self.event_receiver.clone(),
            broadcast_sender: self.broadcast_sender.clone(),
            event_store: self.event_store.clone(),
            retry_config: self.retry_config.clone(),
        }
    }
}
```

## 2. 事件存储

### 2.1 事件存储接口

```rust
use async_trait::async_trait;

/// 事件存储接口
#[async_trait]
pub trait EventStore: Send + Sync {
    async fn store_event(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>>;
    async fn get_event(&self, event_id: &str) -> Result<Option<Event>, Box<dyn std::error::Error>>;
    async fn get_events(
        &self,
        event_type: Option<EventType>,
        source: Option<String>,
        start_time: Option<DateTime<Utc>>,
        end_time: Option<DateTime<Utc>>,
        limit: Option<u32>,
    ) -> Result<Vec<Event>, Box<dyn std::error::Error>>;
    async fn get_event_stats(&self) -> Result<EventStats, Box<dyn std::error::Error>>;
    async fn delete_old_events(&self, before: DateTime<Utc>) -> Result<u64, Box<dyn std::error::Error>>;
}
```

### 2.2 内存事件存储

```rust
use std::collections::VecDeque;

/// 内存事件存储
pub struct InMemoryEventStore {
    events: Arc<RwLock<VecDeque<Event>>>,
    max_events: usize,
}

impl InMemoryEventStore {
    pub fn new(max_events: usize) -> Self {
        Self {
            events: Arc::new(RwLock::new(VecDeque::new())),
            max_events,
        }
    }
}

#[async_trait]
impl EventStore for InMemoryEventStore {
    async fn store_event(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        let mut events = self.events.write().unwrap();
        
        // 添加新事件
        events.push_back(event.clone());
        
        // 如果超过最大事件数，移除最旧的事件
        while events.len() > self.max_events {
            events.pop_front();
        }
        
        Ok(())
    }
    
    async fn get_event(&self, event_id: &str) -> Result<Option<Event>, Box<dyn std::error::Error>> {
        let events = self.events.read().unwrap();
        
        for event in events.iter() {
            if event.id == event_id {
                return Ok(Some(event.clone()));
            }
        }
        
        Ok(None)
    }
    
    async fn get_events(
        &self,
        event_type: Option<EventType>,
        source: Option<String>,
        start_time: Option<DateTime<Utc>>,
        end_time: Option<DateTime<Utc>>,
        limit: Option<u32>,
    ) -> Result<Vec<Event>, Box<dyn std::error::Error>> {
        let events = self.events.read().unwrap();
        let mut filtered_events = Vec::new();
        
        for event in events.iter() {
            // 应用过滤器
            if let Some(ref event_type_filter) = event_type {
                if event.event_type != *event_type_filter {
                    continue;
                }
            }
            
            if let Some(ref source_filter) = source {
                if event.source != *source_filter {
                    continue;
                }
            }
            
            if let Some(start_time_filter) = start_time {
                if event.timestamp < start_time_filter {
                    continue;
                }
            }
            
            if let Some(end_time_filter) = end_time {
                if event.timestamp > end_time_filter {
                    continue;
                }
            }
            
            filtered_events.push(event.clone());
        }
        
        // 按时间戳排序（最新的在前）
        filtered_events.sort_by(|a, b| b.timestamp.cmp(&a.timestamp));
        
        // 应用限制
        if let Some(limit) = limit {
            filtered_events.truncate(limit as usize);
        }
        
        Ok(filtered_events)
    }
    
    async fn get_event_stats(&self) -> Result<EventStats, Box<dyn std::error::Error>> {
        let events = self.events.read().unwrap();
        
        let mut stats = EventStats {
            total_events: events.len() as u64,
            events_by_type: HashMap::new(),
            events_by_source: HashMap::new(),
            events_by_status: HashMap::new(),
            average_processing_time: Duration::from_millis(0),
        };
        
        for event in events.iter() {
            *stats.events_by_type.entry(event.event_type.clone()).or_insert(0) += 1;
            *stats.events_by_source.entry(event.source.clone()).or_insert(0) += 1;
            *stats.events_by_status.entry(event.status.clone()).or_insert(0) += 1;
        }
        
        Ok(stats)
    }
    
    async fn delete_old_events(&self, before: DateTime<Utc>) -> Result<u64, Box<dyn std::error::Error>> {
        let mut events = self.events.write().unwrap();
        let initial_count = events.len();
        
        events.retain(|event| event.timestamp >= before);
        
        Ok((initial_count - events.len()) as u64)
    }
}
```

## 3. 事件处理器

### 3.1 设备事件处理器

```rust
use std::sync::Arc;

/// 设备事件处理器
pub struct DeviceEventHandler {
    device_repository: Arc<DeviceRepository>,
    notification_service: Arc<NotificationService>,
}

impl DeviceEventHandler {
    pub fn new(
        device_repository: Arc<DeviceRepository>,
        notification_service: Arc<NotificationService>,
    ) -> Self {
        Self {
            device_repository,
            notification_service,
        }
    }
}

#[async_trait::async_trait]
impl EventHandler for DeviceEventHandler {
    async fn handle_event(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        match event.event_type {
            EventType::DeviceCreated => {
                self.handle_device_created(event).await?;
            }
            EventType::DeviceUpdated => {
                self.handle_device_updated(event).await?;
            }
            EventType::DeviceDeleted => {
                self.handle_device_deleted(event).await?;
            }
            EventType::DeviceStatusChanged => {
                self.handle_device_status_changed(event).await?;
            }
            _ => {
                // 忽略不支持的事件类型
            }
        }
        
        Ok(())
    }
    
    fn get_name(&self) -> &str {
        "DeviceEventHandler"
    }
    
    fn get_supported_event_types(&self) -> Vec<EventType> {
        vec![
            EventType::DeviceCreated,
            EventType::DeviceUpdated,
            EventType::DeviceDeleted,
            EventType::DeviceStatusChanged,
        ]
    }
}

impl DeviceEventHandler {
    async fn handle_device_created(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        let device_data: Device = serde_json::from_value(event.data.clone())?;
        
        // 保存设备到数据库
        self.device_repository.save(&device_data).await?;
        
        // 发送通知
        self.notification_service.send_notification(
            "Device Created",
            &format!("New device '{}' has been created", device_data.name),
            NotificationType::Info,
        ).await?;
        
        println!("Device created: {}", device_data.name);
        Ok(())
    }
    
    async fn handle_device_updated(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        let device_data: Device = serde_json::from_value(event.data.clone())?;
        
        // 更新设备
        self.device_repository.update(&device_data).await?;
        
        println!("Device updated: {}", device_data.name);
        Ok(())
    }
    
    async fn handle_device_deleted(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        let device_id = event.data["device_id"].as_str().unwrap_or("");
        
        // 删除设备
        self.device_repository.delete(device_id).await?;
        
        // 发送通知
        self.notification_service.send_notification(
            "Device Deleted",
            &format!("Device '{}' has been deleted", device_id),
            NotificationType::Warning,
        ).await?;
        
        println!("Device deleted: {}", device_id);
        Ok(())
    }
    
    async fn handle_device_status_changed(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        let device_id = event.data["device_id"].as_str().unwrap_or("");
        let new_status = event.data["status"].as_str().unwrap_or("");
        
        // 更新设备状态
        self.device_repository.update_status(device_id, new_status).await?;
        
        // 如果设备离线，发送通知
        if new_status == "offline" {
            self.notification_service.send_notification(
                "Device Offline",
                &format!("Device '{}' is now offline", device_id),
                NotificationType::Warning,
            ).await?;
        }
        
        println!("Device status changed: {} -> {}", device_id, new_status);
        Ok(())
    }
}
```

### 3.2 传感器事件处理器

```rust
/// 传感器事件处理器
pub struct SensorEventHandler {
    sensor_data_repository: Arc<SensorDataRepository>,
    alert_service: Arc<AlertService>,
    data_processor: Arc<DataProcessor>,
}

impl SensorEventHandler {
    pub fn new(
        sensor_data_repository: Arc<SensorDataRepository>,
        alert_service: Arc<AlertService>,
        data_processor: Arc<DataProcessor>,
    ) -> Self {
        Self {
            sensor_data_repository,
            alert_service,
            data_processor,
        }
    }
}

#[async_trait::async_trait]
impl EventHandler for SensorEventHandler {
    async fn handle_event(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        match event.event_type {
            EventType::SensorDataReceived => {
                self.handle_sensor_data_received(event).await?;
            }
            EventType::AlertTriggered => {
                self.handle_alert_triggered(event).await?;
            }
            EventType::AlertResolved => {
                self.handle_alert_resolved(event).await?;
            }
            _ => {
                // 忽略不支持的事件类型
            }
        }
        
        Ok(())
    }
    
    fn get_name(&self) -> &str {
        "SensorEventHandler"
    }
    
    fn get_supported_event_types(&self) -> Vec<EventType> {
        vec![
            EventType::SensorDataReceived,
            EventType::AlertTriggered,
            EventType::AlertResolved,
        ]
    }
}

impl SensorEventHandler {
    async fn handle_sensor_data_received(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        let sensor_data: SensorData = serde_json::from_value(event.data.clone())?;
        
        // 保存传感器数据
        self.sensor_data_repository.save(&sensor_data).await?;
        
        // 处理数据
        self.data_processor.process_sensor_data(&sensor_data).await?;
        
        // 检查是否需要触发告警
        if let Some(alert) = self.alert_service.check_alert_conditions(&sensor_data).await? {
            // 发布告警事件
            let alert_event = Event::new(
                EventType::AlertTriggered,
                "SensorEventHandler".to_string(),
                serde_json::to_value(alert)?,
            );
            
            // 这里需要访问事件总线来发布事件
            // 简化实现，直接处理告警
            self.alert_service.create_alert(alert).await?;
        }
        
        println!("Sensor data processed: {} = {}", sensor_data.sensor_type, sensor_data.value);
        Ok(())
    }
    
    async fn handle_alert_triggered(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        let alert: Alert = serde_json::from_value(event.data.clone())?;
        
        // 创建告警
        self.alert_service.create_alert(alert).await?;
        
        println!("Alert triggered: {}", event.id);
        Ok(())
    }
    
    async fn handle_alert_resolved(&self, event: &Event) -> Result<(), Box<dyn std::error::Error>> {
        let alert_id = event.data["alert_id"].as_str().unwrap_or("");
        
        // 解决告警
        self.alert_service.resolve_alert(alert_id).await?;
        
        println!("Alert resolved: {}", alert_id);
        Ok(())
    }
}
```

## 4. 应用示例

### 4.1 事件驱动IoT系统

```rust
use std::sync::Arc;

async fn event_driven_iot_system() -> Result<(), Box<dyn std::error::Error>> {
    // 创建事件存储
    let event_store = Arc::new(InMemoryEventStore::new(10000));
    
    // 创建事件总线
    let event_bus = Arc::new(EventBus::new(event_store.clone()));
    
    // 创建依赖服务
    let device_repository = Arc::new(DeviceRepository::new());
    let sensor_data_repository = Arc::new(SensorDataRepository::new());
    let notification_service = Arc::new(NotificationService::new());
    let alert_service = Arc::new(AlertService::new());
    let data_processor = Arc::new(DataProcessor::new());
    
    // 创建事件处理器
    let device_handler = Arc::new(DeviceEventHandler::new(
        device_repository.clone(),
        notification_service.clone(),
    ));
    
    let sensor_handler = Arc::new(SensorEventHandler::new(
        sensor_data_repository.clone(),
        alert_service.clone(),
        data_processor.clone(),
    ));
    
    // 注册事件处理器
    event_bus.register_handler(device_handler).await?;
    event_bus.register_handler(sensor_handler).await?;
    
    // 创建事件订阅
    let subscription = EventSubscription {
        id: Uuid::new_v4().to_string(),
        subscriber_id: "webhook-service".to_string(),
        event_types: vec![
            EventType::AlertTriggered,
            EventType::DeviceStatusChanged,
        ],
        filters: HashMap::new(),
        callback_url: Some("http://localhost:8080/webhook".to_string()),
        created_at: Utc::now(),
        active: true,
    };
    
    event_bus.subscribe(subscription).await?;
    
    // 模拟发布事件
    simulate_iot_events(&event_bus).await?;
    
    // 启动事件监控
    start_event_monitoring(&event_bus).await?;
    
    Ok(())
}

/// 模拟IoT事件
async fn simulate_iot_events(event_bus: &Arc<EventBus>) -> Result<(), Box<dyn std::error::Error>> {
    // 创建设备事件
    let device = Device {
        id: "device-001".to_string(),
        name: "Temperature Sensor 1".to_string(),
        device_type: "sensor".to_string(),
        location: Some("Room 101".to_string()),
        status: DeviceStatus::Online,
        protocol: "mqtt".to_string(),
        connection_info: serde_json::json!({
            "broker": "mqtt.example.com",
            "topic": "sensors/temp/001"
        }),
        metadata: HashMap::new(),
        created_at: Utc::now(),
        updated_at: Utc::now(),
        last_seen: Some(Utc::now()),
        version: 1,
    };
    
    let device_created_event = Event::new(
        EventType::DeviceCreated,
        "DeviceManager".to_string(),
        serde_json::to_value(device)?,
    );
    
    event_bus.publish_event(device_created_event).await?;
    
    // 创建传感器数据事件
    let sensor_data = SensorData {
        id: "sensor-data-001".to_string(),
        device_id: "device-001".to_string(),
        sensor_type: "temperature".to_string(),
        value: 25.5,
        unit: "celsius".to_string(),
        timestamp: Utc::now(),
        quality: DataQuality::Good,
        metadata: HashMap::new(),
        created_at: Utc::now(),
    };
    
    let sensor_data_event = Event::new(
        EventType::SensorDataReceived,
        "SensorGateway".to_string(),
        serde_json::to_value(sensor_data)?,
    );
    
    event_bus.publish_event(sensor_data_event).await?;
    
    // 创建设备状态变更事件
    let status_change_event = Event::new(
        EventType::DeviceStatusChanged,
        "DeviceMonitor".to_string(),
        serde_json::json!({
            "device_id": "device-001",
            "status": "offline",
            "reason": "connection_lost"
        }),
    ).with_priority(EventPriority::High);
    
    event_bus.publish_event(status_change_event).await?;
    
    println!("Simulated IoT events published");
    Ok(())
}

/// 启动事件监控
async fn start_event_monitoring(event_bus: &Arc<EventBus>) -> Result<(), Box<dyn std::error::Error>> {
    let event_bus_clone = event_bus.clone();
    
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(Duration::from_secs(30));
        
        loop {
            interval.tick().await;
            
            // 获取事件统计
            match event_bus_clone.get_event_stats().await {
                Ok(stats) => {
                    println!("Event Statistics:");
                    println!("  Total Events: {}", stats.total_events);
                    println!("  Events by Type: {:?}", stats.events_by_type);
                    println!("  Events by Source: {:?}", stats.events_by_source);
                    println!("  Events by Status: {:?}", stats.events_by_status);
                }
                Err(e) => {
                    println!("Failed to get event stats: {}", e);
                }
            }
        }
    });
    
    Ok(())
}

/// 事件重放功能
async fn replay_events(
    event_bus: &Arc<EventBus>,
    start_time: DateTime<Utc>,
    end_time: DateTime<Utc>,
) -> Result<(), Box<dyn std::error::Error>> {
    let events = event_bus.get_event_history(None, None, Some(start_time), Some(end_time), None).await?;
    
    println!("Replaying {} events from {} to {}", events.len(), start_time, end_time);
    
    for event in events {
        // 创建新的事件ID和时间戳
        let mut replayed_event = event.clone();
        replayed_event.id = Uuid::new_v4().to_string();
        replayed_event.timestamp = Utc::now();
        replayed_event.metadata.insert("replayed".to_string(), "true".to_string());
        
        event_bus.publish_event(replayed_event).await?;
        
        // 添加延迟避免过载
        tokio::time::sleep(Duration::from_millis(100)).await;
    }
    
    println!("Event replay completed");
    Ok(())
}

/// 事件过滤器
pub struct EventFilter {
    pub event_types: Option<Vec<EventType>>,
    pub sources: Option<Vec<String>>,
    pub priority_min: Option<EventPriority>,
    pub time_range: Option<(DateTime<Utc>, DateTime<Utc>)>,
    pub metadata_filters: HashMap<String, String>,
}

impl EventFilter {
    pub fn new() -> Self {
        Self {
            event_types: None,
            sources: None,
            priority_min: None,
            time_range: None,
            metadata_filters: HashMap::new(),
        }
    }
    
    pub fn with_event_types(mut self, event_types: Vec<EventType>) -> Self {
        self.event_types = Some(event_types);
        self
    }
    
    pub fn with_sources(mut self, sources: Vec<String>) -> Self {
        self.sources = Some(sources);
        self
    }
    
    pub fn with_priority_min(mut self, priority: EventPriority) -> Self {
        self.priority_min = Some(priority);
        self
    }
    
    pub fn with_time_range(mut self, start: DateTime<Utc>, end: DateTime<Utc>) -> Self {
        self.time_range = Some((start, end));
        self
    }
    
    pub fn with_metadata_filter(mut self, key: String, value: String) -> Self {
        self.metadata_filters.insert(key, value);
        self
    }
    
    pub fn matches(&self, event: &Event) -> bool {
        // 检查事件类型
        if let Some(ref event_types) = self.event_types {
            if !event_types.contains(&event.event_type) {
                return false;
            }
        }
        
        // 检查来源
        if let Some(ref sources) = self.sources {
            if !sources.contains(&event.source) {
                return false;
            }
        }
        
        // 检查优先级
        if let Some(ref priority_min) = self.priority_min {
            if event.priority < *priority_min {
                return false;
            }
        }
        
        // 检查时间范围
        if let Some((start, end)) = self.time_range {
            if event.timestamp < start || event.timestamp > end {
                return false;
            }
        }
        
        // 检查元数据过滤器
        for (key, value) in &self.metadata_filters {
            if let Some(event_value) = event.metadata.get(key) {
                if event_value != value {
                    return false;
                }
            } else {
                return false;
            }
        }
        
        true
    }
}
```

## 5. 总结

本实现提供了完整的事件驱动架构：

1. **事件总线** - 事件发布、订阅、处理
2. **事件存储** - 事件持久化、查询、统计
3. **事件处理器** - 设备事件、传感器事件处理
4. **事件重放** - 历史事件重放功能
5. **事件过滤** - 灵活的事件过滤机制
6. **实际应用示例** - 完整的IoT事件驱动系统

这个事件驱动架构实现为IoT平台提供了松耦合、可扩展的事件处理能力。
