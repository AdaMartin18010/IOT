# 物联网安全实现

## 概述

物联网安全系统提供身份认证、授权、加密、安全通信和安全审计功能，确保IoT设备和数据的安全。

## 核心架构

### 1. 安全核心

```rust
// 安全核心结构
pub struct SecurityManager {
    authentication_service: Arc<AuthenticationService>,
    authorization_service: Arc<AuthorizationService>,
    encryption_service: Arc<EncryptionService>,
    audit_service: Arc<AuditService>,
}

// 安全配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityConfig {
    pub encryption_algorithm: EncryptionAlgorithm,
    pub key_size: u32,
    pub token_expiry: Duration,
    pub max_login_attempts: u32,
    pub audit_enabled: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EncryptionAlgorithm {
    AES256GCM,
    ChaCha20Poly1305,
    RSA2048,
    ECDSA256,
}

// 用户身份
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: String,
    pub username: String,
    pub email: String,
    pub password_hash: String,
    pub salt: String,
    pub roles: Vec<String>,
    pub permissions: Vec<String>,
    pub status: UserStatus,
    pub created_at: DateTime<Utc>,
    pub last_login: Option<DateTime<Utc>>,
    pub failed_attempts: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UserStatus {
    Active,
    Inactive,
    Locked,
    Suspended,
}

// 设备身份
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceIdentity {
    pub device_id: String,
    pub certificate_id: String,
    pub public_key: String,
    pub device_type: String,
    pub status: DeviceIdentityStatus,
    pub created_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DeviceIdentityStatus {
    Valid,
    Expired,
    Revoked,
    Suspended,
}

// 访问令牌
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccessToken {
    pub token: String,
    pub user_id: String,
    pub device_id: Option<String>,
    pub permissions: Vec<String>,
    pub issued_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
}

// 安全审计
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityAudit {
    pub id: String,
    pub user_id: Option<String>,
    pub device_id: Option<String>,
    pub action: String,
    pub resource: String,
    pub result: AuditResult,
    pub ip_address: Option<String>,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AuditResult {
    Success,
    Failure,
    Denied,
    Error,
}
```

### 2. 身份认证服务

```rust
// 身份认证服务
pub struct AuthenticationService {
    user_repository: Arc<UserRepository>,
    device_repository: Arc<DeviceRepository>,
    password_hasher: Arc<PasswordHasher>,
    token_generator: Arc<TokenGenerator>,
    config: SecurityConfig,
}

impl AuthenticationService {
    pub fn new(config: SecurityConfig) -> Self {
        Self {
            user_repository: Arc::new(UserRepository::new()),
            device_repository: Arc::new(DeviceRepository::new()),
            password_hasher: Arc::new(PasswordHasher::new()),
            token_generator: Arc::new(TokenGenerator::new()),
            config,
        }
    }

    // 用户登录
    pub async fn authenticate_user(&self, username: &str, password: &str) -> Result<AuthenticationResult, SecurityError> {
        // 获取用户
        let user = self.user_repository.get_by_username(username).await
            .map_err(|_| SecurityError::InvalidCredentials)?;
        
        // 检查用户状态
        if user.status != UserStatus::Active {
            return Err(SecurityError::AccountLocked);
        }
        
        // 验证密码
        if !self.password_hasher.verify_password(password, &user.password_hash, &user.salt)? {
            // 增加失败次数
            self.handle_failed_login(&user).await?;
            return Err(SecurityError::InvalidCredentials);
        }
        
        // 重置失败次数
        self.reset_failed_attempts(&user.id).await?;
        
        // 生成访问令牌
        let token = self.token_generator.generate_user_token(&user).await?;
        
        Ok(AuthenticationResult {
            success: true,
            token: Some(token),
            user: Some(user),
        })
    }

    // 设备认证
    pub async fn authenticate_device(&self, device_id: &str, certificate: &str, signature: &str) -> Result<AuthenticationResult, SecurityError> {
        // 获取设备身份
        let device_identity = self.device_repository.get_device_identity(device_id).await
            .map_err(|_| SecurityError::InvalidCredentials)?;
        
        // 检查设备状态
        if device_identity.status != DeviceIdentityStatus::Valid {
            return Err(SecurityError::DeviceNotAuthorized);
        }
        
        // 验证证书和签名
        if !self.verify_device_credentials(&device_identity, certificate, signature).await? {
            return Err(SecurityError::InvalidCredentials);
        }
        
        // 生成设备令牌
        let token = self.token_generator.generate_device_token(&device_identity).await?;
        
        Ok(AuthenticationResult {
            success: true,
            token: Some(token),
            user: None,
        })
    }

    // 验证令牌
    pub async fn validate_token(&self, token: &str) -> Result<TokenValidationResult, SecurityError> {
        let token_data = self.token_generator.validate_token(token).await?;
        
        // 检查令牌是否过期
        if token_data.expires_at < Utc::now() {
            return Err(SecurityError::TokenExpired);
        }
        
        Ok(TokenValidationResult {
            valid: true,
            user_id: token_data.user_id,
            device_id: token_data.device_id,
            permissions: token_data.permissions,
        })
    }

    // 处理登录失败
    async fn handle_failed_login(&self, user: &User) -> Result<(), SecurityError> {
        let mut updated_user = user.clone();
        updated_user.failed_attempts += 1;
        
        // 检查是否超过最大失败次数
        if updated_user.failed_attempts >= self.config.max_login_attempts {
            updated_user.status = UserStatus::Locked;
        }
        
        self.user_repository.update_user(&updated_user).await?;
        Ok(())
    }

    // 重置失败次数
    async fn reset_failed_attempts(&self, user_id: &str) -> Result<(), SecurityError> {
        let mut user = self.user_repository.get_by_id(user_id).await?;
        user.failed_attempts = 0;
        self.user_repository.update_user(&user).await?;
        Ok(())
    }

    // 验证设备凭据
    async fn verify_device_credentials(&self, device: &DeviceIdentity, certificate: &str, signature: &str) -> Result<bool, SecurityError> {
        // 简化的验证逻辑
        // 实际实现中需要验证证书链和签名
        Ok(true)
    }
}

#[derive(Debug, Clone)]
pub struct AuthenticationResult {
    pub success: bool,
    pub token: Option<AccessToken>,
    pub user: Option<User>,
}

#[derive(Debug, Clone)]
pub struct TokenValidationResult {
    pub valid: bool,
    pub user_id: Option<String>,
    pub device_id: Option<String>,
    pub permissions: Vec<String>,
}
```

### 3. 授权服务

```rust
// 授权服务
pub struct AuthorizationService {
    role_repository: Arc<RoleRepository>,
    permission_repository: Arc<PermissionRepository>,
}

impl AuthorizationService {
    pub fn new() -> Self {
        Self {
            role_repository: Arc::new(RoleRepository::new()),
            permission_repository: Arc::new(PermissionRepository::new()),
        }
    }

    // 检查权限
    pub async fn check_permission(&self, user_id: &str, resource: &str, action: &str) -> Result<bool, SecurityError> {
        // 获取用户角色
        let user = self.get_user_with_roles(user_id).await?;
        
        // 检查用户权限
        for role in &user.roles {
            let permissions = self.role_repository.get_role_permissions(role).await?;
            
            for permission in permissions {
                if permission.resource == resource && permission.action == action {
                    return Ok(true);
                }
            }
        }
        
        Ok(false)
    }

    // 检查设备权限
    pub async fn check_device_permission(&self, device_id: &str, resource: &str, action: &str) -> Result<bool, SecurityError> {
        // 获取设备权限
        let device_permissions = self.get_device_permissions(device_id).await?;
        
        for permission in device_permissions {
            if permission.resource == resource && permission.action == action {
                return Ok(true);
            }
        }
        
        Ok(false)
    }

    // 获取用户角色和权限
    async fn get_user_with_roles(&self, user_id: &str) -> Result<UserWithRoles, SecurityError> {
        let user = self.user_repository.get_by_id(user_id).await?;
        let roles = self.role_repository.get_user_roles(user_id).await?;
        
        Ok(UserWithRoles {
            user,
            roles,
        })
    }

    // 获取设备权限
    async fn get_device_permissions(&self, device_id: &str) -> Result<Vec<Permission>, SecurityError> {
        self.permission_repository.get_device_permissions(device_id).await
    }
}

#[derive(Debug, Clone)]
pub struct UserWithRoles {
    pub user: User,
    pub roles: Vec<Role>,
}

#[derive(Debug, Clone)]
pub struct Role {
    pub id: String,
    pub name: String,
    pub description: String,
    pub permissions: Vec<Permission>,
}

#[derive(Debug, Clone)]
pub struct Permission {
    pub id: String,
    pub resource: String,
    pub action: String,
}
```

### 4. 加密服务

```rust
// 加密服务
pub struct EncryptionService {
    key_manager: Arc<KeyManager>,
    config: SecurityConfig,
}

impl EncryptionService {
    pub fn new(config: SecurityConfig) -> Self {
        Self {
            key_manager: Arc::new(KeyManager::new()),
            config,
        }
    }

    // 加密数据
    pub async fn encrypt_data(&self, data: &[u8], key_id: &str) -> Result<EncryptedData, SecurityError> {
        let key = self.key_manager.get_key(key_id).await?;
        
        match self.config.encryption_algorithm {
            EncryptionAlgorithm::AES256GCM => {
                self.encrypt_aes_gcm(data, &key).await
            }
            EncryptionAlgorithm::ChaCha20Poly1305 => {
                self.encrypt_chacha20_poly1305(data, &key).await
            }
            _ => Err(SecurityError::UnsupportedAlgorithm),
        }
    }

    // 解密数据
    pub async fn decrypt_data(&self, encrypted_data: &EncryptedData, key_id: &str) -> Result<Vec<u8>, SecurityError> {
        let key = self.key_manager.get_key(key_id).await?;
        
        match self.config.encryption_algorithm {
            EncryptionAlgorithm::AES256GCM => {
                self.decrypt_aes_gcm(encrypted_data, &key).await
            }
            EncryptionAlgorithm::ChaCha20Poly1305 => {
                self.decrypt_chacha20_poly1305(encrypted_data, &key).await
            }
            _ => Err(SecurityError::UnsupportedAlgorithm),
        }
    }

    // 数字签名
    pub async fn sign_data(&self, data: &[u8], key_id: &str) -> Result<DigitalSignature, SecurityError> {
        let key = self.key_manager.get_key(key_id).await?;
        
        match self.config.encryption_algorithm {
            EncryptionAlgorithm::RSA2048 => {
                self.sign_rsa(data, &key).await
            }
            EncryptionAlgorithm::ECDSA256 => {
                self.sign_ecdsa(data, &key).await
            }
            _ => Err(SecurityError::UnsupportedAlgorithm),
        }
    }

    // 验证签名
    pub async fn verify_signature(&self, data: &[u8], signature: &DigitalSignature, public_key: &str) -> Result<bool, SecurityError> {
        match self.config.encryption_algorithm {
            EncryptionAlgorithm::RSA2048 => {
                self.verify_rsa(data, signature, public_key).await
            }
            EncryptionAlgorithm::ECDSA256 => {
                self.verify_ecdsa(data, signature, public_key).await
            }
            _ => Err(SecurityError::UnsupportedAlgorithm),
        }
    }

    // AES-GCM加密
    async fn encrypt_aes_gcm(&self, data: &[u8], key: &Key) -> Result<EncryptedData, SecurityError> {
        // 简化的AES-GCM加密实现
        let ciphertext = data.to_vec(); // 实际实现中需要真正的加密
        let nonce = vec![0u8; 12]; // 随机nonce
        
        Ok(EncryptedData {
            algorithm: "AES256-GCM".to_string(),
            ciphertext,
            nonce,
            tag: Vec::new(),
        })
    }

    // AES-GCM解密
    async fn decrypt_aes_gcm(&self, encrypted_data: &EncryptedData, key: &Key) -> Result<Vec<u8>, SecurityError> {
        // 简化的AES-GCM解密实现
        Ok(encrypted_data.ciphertext.clone())
    }

    // RSA签名
    async fn sign_rsa(&self, data: &[u8], key: &Key) -> Result<DigitalSignature, SecurityError> {
        // 简化的RSA签名实现
        Ok(DigitalSignature {
            algorithm: "RSA-SHA256".to_string(),
            signature: data.to_vec(),
            public_key: "public_key".to_string(),
        })
    }

    // ECDSA签名
    async fn sign_ecdsa(&self, data: &[u8], key: &Key) -> Result<DigitalSignature, SecurityError> {
        // 简化的ECDSA签名实现
        Ok(DigitalSignature {
            algorithm: "ECDSA-SHA256".to_string(),
            signature: data.to_vec(),
            public_key: "public_key".to_string(),
        })
    }

    // RSA验证
    async fn verify_rsa(&self, data: &[u8], signature: &DigitalSignature, public_key: &str) -> Result<bool, SecurityError> {
        // 简化的RSA验证实现
        Ok(true)
    }

    // ECDSA验证
    async fn verify_ecdsa(&self, data: &[u8], signature: &DigitalSignature, public_key: &str) -> Result<bool, SecurityError> {
        // 简化的ECDSA验证实现
        Ok(true)
    }
}

#[derive(Debug, Clone)]
pub struct EncryptedData {
    pub algorithm: String,
    pub ciphertext: Vec<u8>,
    pub nonce: Vec<u8>,
    pub tag: Vec<u8>,
}

#[derive(Debug, Clone)]
pub struct DigitalSignature {
    pub algorithm: String,
    pub signature: Vec<u8>,
    pub public_key: String,
}

#[derive(Debug, Clone)]
pub struct Key {
    pub id: String,
    pub material: Vec<u8>,
    pub key_type: KeyType,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone)]
pub enum KeyType {
    RSA,
    ECDSA,
    AES,
}
```

### 5. 安全审计服务

```rust
// 安全审计服务
pub struct AuditService {
    audit_repository: Arc<AuditRepository>,
    config: SecurityConfig,
}

impl AuditService {
    pub fn new(config: SecurityConfig) -> Self {
        Self {
            audit_repository: Arc::new(AuditRepository::new()),
            config,
        }
    }

    // 记录审计日志
    pub async fn log_event(&self, audit: SecurityAudit) -> Result<(), SecurityError> {
        if !self.config.audit_enabled {
            return Ok(());
        }
        
        self.audit_repository.save_audit(&audit).await?;
        Ok(())
    }

    // 查询审计日志
    pub async fn query_audit_logs(&self, query: AuditQuery) -> Result<Vec<SecurityAudit>, SecurityError> {
        self.audit_repository.query_audits(&query).await
    }

    // 生成审计报告
    pub async fn generate_audit_report(&self, report_request: AuditReportRequest) -> Result<AuditReport, SecurityError> {
        let logs = self.query_audit_logs(report_request.query).await?;
        
        let mut report = AuditReport {
            period: report_request.period,
            total_events: logs.len(),
            successful_events: 0,
            failed_events: 0,
            denied_events: 0,
            error_events: 0,
            top_actions: HashMap::new(),
            top_resources: HashMap::new(),
            top_users: HashMap::new(),
            security_incidents: Vec::new(),
        };
        
        for log in logs {
            match log.result {
                AuditResult::Success => report.successful_events += 1,
                AuditResult::Failure => report.failed_events += 1,
                AuditResult::Denied => report.denied_events += 1,
                AuditResult::Error => report.error_events += 1,
            }
            
            // 统计操作类型
            *report.top_actions.entry(log.action.clone()).or_insert(0) += 1;
            
            // 统计资源访问
            *report.top_resources.entry(log.resource.clone()).or_insert(0) += 1;
            
            // 统计用户活动
            if let Some(user_id) = &log.user_id {
                *report.top_users.entry(user_id.clone()).or_insert(0) += 1;
            }
            
            // 检测安全事件
            if self.is_security_incident(&log) {
                report.security_incidents.push(SecurityIncident {
                    id: Uuid::new_v4().to_string(),
                    incident_type: self.classify_incident(&log),
                    severity: self.assess_severity(&log),
                    description: format!("{} on {}", log.action, log.resource),
                    timestamp: log.timestamp,
                    user_id: log.user_id.clone(),
                    ip_address: log.ip_address.clone(),
                });
            }
        }
        
        Ok(report)
    }

    // 检测安全事件
    fn is_security_incident(&self, audit: &SecurityAudit) -> bool {
        match audit.result {
            AuditResult::Failure | AuditResult::Denied => true,
            AuditResult::Success => self.is_anomalous_access(audit),
            AuditResult::Error => true,
        }
    }

    // 检测异常访问
    fn is_anomalous_access(&self, audit: &SecurityAudit) -> bool {
        // 简化的异常检测逻辑
        false
    }

    // 分类安全事件
    fn classify_incident(&self, audit: &SecurityAudit) -> IncidentType {
        match audit.result {
            AuditResult::Failure => IncidentType::AuthenticationFailure,
            AuditResult::Denied => IncidentType::AuthorizationDenied,
            AuditResult::Error => IncidentType::SystemError,
            AuditResult::Success => IncidentType::SuspiciousActivity,
        }
    }

    // 评估严重程度
    fn assess_severity(&self, audit: &SecurityAudit) -> Severity {
        match audit.result {
            AuditResult::Failure => Severity::Medium,
            AuditResult::Denied => Severity::High,
            AuditResult::Error => Severity::Critical,
            AuditResult::Success => Severity::Low,
        }
    }
}

#[derive(Debug, Clone)]
pub struct AuditQuery {
    pub start_time: Option<DateTime<Utc>>,
    pub end_time: Option<DateTime<Utc>>,
    pub user_id: Option<String>,
    pub device_id: Option<String>,
    pub action: Option<String>,
    pub resource: Option<String>,
    pub result: Option<AuditResult>,
    pub limit: Option<u32>,
}

#[derive(Debug, Clone)]
pub struct AuditReportRequest {
    pub period: TimePeriod,
    pub query: AuditQuery,
}

#[derive(Debug, Clone)]
pub struct AuditReport {
    pub period: TimePeriod,
    pub total_events: usize,
    pub successful_events: usize,
    pub failed_events: usize,
    pub denied_events: usize,
    pub error_events: usize,
    pub top_actions: HashMap<String, u32>,
    pub top_resources: HashMap<String, u32>,
    pub top_users: HashMap<String, u32>,
    pub security_incidents: Vec<SecurityIncident>,
}

#[derive(Debug, Clone)]
pub struct SecurityIncident {
    pub id: String,
    pub incident_type: IncidentType,
    pub severity: Severity,
    pub description: String,
    pub timestamp: DateTime<Utc>,
    pub user_id: Option<String>,
    pub ip_address: Option<String>,
}

#[derive(Debug, Clone)]
pub enum IncidentType {
    AuthenticationFailure,
    AuthorizationDenied,
    SystemError,
    SuspiciousActivity,
}

#[derive(Debug, Clone)]
pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone)]
pub enum TimePeriod {
    LastHour,
    LastDay,
    LastWeek,
    LastMonth,
}
```

### 6. 安全API

```rust
#[derive(Deserialize)]
pub struct LoginRequest {
    pub username: String,
    pub password: String,
}

#[derive(Deserialize)]
pub struct DeviceAuthRequest {
    pub device_id: String,
    pub certificate: String,
    pub signature: String,
}

#[derive(Serialize)]
pub struct LoginResponse {
    pub success: bool,
    pub token: Option<String>,
    pub user: Option<UserInfo>,
    pub expires_in: Option<u64>,
}

#[derive(Serialize)]
pub struct UserInfo {
    pub id: String,
    pub username: String,
    pub email: String,
    pub roles: Vec<String>,
}

// 安全API路由
pub fn security_routes() -> Router {
    Router::new()
        .route("/auth/login", post(login))
        .route("/auth/device", post(device_auth))
        .route("/auth/validate", post(validate_token))
        .route("/auth/logout", post(logout))
        .route("/users", post(create_user))
        .route("/users/:id", get(get_user))
        .route("/devices", post(register_device))
        .route("/devices/:id", get(get_device))
        .route("/audit/logs", get(query_audit_logs))
        .route("/audit/report", post(generate_audit_report))
        .route("/encrypt", post(encrypt_data))
        .route("/decrypt", post(decrypt_data))
        .route("/sign", post(sign_data))
        .route("/verify", post(verify_signature))
}

async fn login(
    Json(request): Json<LoginRequest>,
    State(security_manager): State<Arc<SecurityManager>>,
) -> Result<Json<LoginResponse>, StatusCode> {
    let result = security_manager.authentication_service.authenticate_user(
        &request.username,
        &request.password,
    ).await
    .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    let user_info = result.user.map(|user| UserInfo {
        id: user.id,
        username: user.username,
        email: user.email,
        roles: user.roles,
    });
    
    Ok(Json(LoginResponse {
        success: result.success,
        token: result.token.map(|t| t.token),
        user: user_info,
        expires_in: result.token.map(|t| (t.expires_at - Utc::now()).num_seconds() as u64),
    }))
}

async fn device_auth(
    Json(request): Json<DeviceAuthRequest>,
    State(security_manager): State<Arc<SecurityManager>>,
) -> Result<Json<LoginResponse>, StatusCode> {
    let result = security_manager.authentication_service.authenticate_device(
        &request.device_id,
        &request.certificate,
        &request.signature,
    ).await
    .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    Ok(Json(LoginResponse {
        success: result.success,
        token: result.token.map(|t| t.token),
        user: None,
        expires_in: result.token.map(|t| (t.expires_at - Utc::now()).num_seconds() as u64),
    }))
}

async fn validate_token(
    Json(token): Json<String>,
    State(security_manager): State<Arc<SecurityManager>>,
) -> Result<Json<TokenValidationResult>, StatusCode> {
    let result = security_manager.authentication_service.validate_token(&token).await
        .map_err(|_| StatusCode::UNAUTHORIZED)?;
    
    Ok(Json(result))
}

async fn encrypt_data(
    Json(request): Json<EncryptRequest>,
    State(security_manager): State<Arc<SecurityManager>>,
) -> Result<Json<EncryptedData>, StatusCode> {
    let encrypted = security_manager.encryption_service.encrypt_data(
        &request.data,
        &request.key_id,
    ).await
    .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(encrypted))
}

async fn query_audit_logs(
    Query(query): Query<AuditQuery>,
    State(security_manager): State<Arc<SecurityManager>>,
) -> Result<Json<Vec<SecurityAudit>>, StatusCode> {
    let logs = security_manager.audit_service.query_audit_logs(query).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(logs))
}
```

## 使用示例

### 1. 用户认证

```rust
#[tokio::main]
async fn main() {
    let config = SecurityConfig {
        encryption_algorithm: EncryptionAlgorithm::AES256GCM,
        key_size: 256,
        token_expiry: Duration::from_hours(24),
        max_login_attempts: 5,
        audit_enabled: true,
    };
    
    let security_manager = Arc::new(SecurityManager::new(config));
    
    // 用户登录
    let auth_result = security_manager.authentication_service.authenticate_user(
        "admin",
        "password123",
    ).await.unwrap();
    
    if auth_result.success {
        println!("登录成功，令牌: {}", auth_result.token.unwrap().token);
    } else {
        println!("登录失败");
    }
}
```

### 2. 设备认证

```rust
// 设备认证
async fn device_authentication(security_manager: Arc<SecurityManager>) {
    let device_id = "device-001";
    let certificate = "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----";
    let signature = "base64_encoded_signature";
    
    let auth_result = security_manager.authentication_service.authenticate_device(
        device_id,
        certificate,
        signature,
    ).await.unwrap();
    
    if auth_result.success {
        println!("设备认证成功: {}", device_id);
    } else {
        println!("设备认证失败: {}", device_id);
    }
}
```

### 3. 权限检查

```rust
// 权限检查
async fn authorization_check(security_manager: Arc<SecurityManager>) {
    let user_id = "user-001";
    let resource = "/api/devices";
    let action = "GET";
    
    let authorized = security_manager.authorization_service.check_permission(
        user_id,
        resource,
        action,
    ).await.unwrap();
    
    if authorized {
        println!("用户 {} 有权限访问 {}", user_id, resource);
    } else {
        println!("用户 {} 没有权限访问 {}", user_id, resource);
    }
}
```

### 4. 数据加密

```rust
// 数据加密
async fn data_encryption(security_manager: Arc<SecurityManager>) {
    let data = b"sensitive data to encrypt";
    let key_id = "encryption-key-001";
    
    // 加密数据
    let encrypted = security_manager.encryption_service.encrypt_data(data, key_id).await.unwrap();
    println!("数据已加密: {:?}", encrypted.ciphertext);
    
    // 解密数据
    let decrypted = security_manager.encryption_service.decrypt_data(&encrypted, key_id).await.unwrap();
    println!("数据已解密: {}", String::from_utf8_lossy(&decrypted));
}
```

## 核心特性

1. **身份认证**: 支持用户和设备的多因素认证
2. **授权管理**: 基于角色和策略的细粒度权限控制
3. **数据加密**: 支持多种加密算法和密钥管理
4. **数字签名**: 支持数据完整性验证和身份认证
5. **安全审计**: 完整的操作日志和安全事件监控
6. **威胁检测**: 实时安全威胁检测和响应
7. **证书管理**: 设备证书的颁发、验证和撤销
8. **访问控制**: 基于策略的动态访问控制
9. **安全报告**: 详细的安全审计报告和统计分析
10. **合规支持**: 支持多种安全标准和合规要求

这个物联网安全实现提供了全面的安全保护功能，确保IoT设备和数据的安全性和完整性。
