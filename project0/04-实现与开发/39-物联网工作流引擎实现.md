# 物联网工作流引擎实现

## 概述

物联网工作流引擎提供复杂业务流程的自动化执行，支持条件分支、并行处理和状态管理等功能。

## 核心架构

### 1. 工作流引擎核心

```rust
pub struct WorkflowEngine {
    workflow_registry: Arc<RwLock<HashMap<String, WorkflowDefinition>>>,
    execution_engine: Arc<ExecutionEngine>,
    state_manager: Arc<StateManager>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkflowDefinition {
    pub id: String,
    pub name: String,
    pub description: String,
    pub nodes: Vec<WorkflowNode>,
    pub edges: Vec<WorkflowEdge>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkflowNode {
    pub id: String,
    pub name: String,
    pub node_type: NodeType,
    pub config: HashMap<String, serde_json::Value>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum NodeType {
    Start,
    End,
    Task,
    Decision,
    Parallel,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkflowEdge {
    pub id: String,
    pub source_node_id: String,
    pub target_node_id: String,
    pub condition: Option<Condition>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Condition {
    pub field: String,
    pub operator: Operator,
    pub value: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Operator {
    Equals,
    NotEquals,
    GreaterThan,
    LessThan,
}

impl WorkflowEngine {
    pub fn new() -> Self {
        Self {
            workflow_registry: Arc::new(RwLock::new(HashMap::new())),
            execution_engine: Arc::new(ExecutionEngine::new()),
            state_manager: Arc::new(StateManager::new()),
        }
    }

    // 注册工作流定义
    pub async fn register_workflow(&self, workflow: WorkflowDefinition) -> Result<(), WorkflowError> {
        let mut registry = self.workflow_registry.write().await;
        registry.insert(workflow.id.clone(), workflow);
        Ok(())
    }

    // 启动工作流实例
    pub async fn start_workflow(&self, workflow_id: &str, input_data: HashMap<String, serde_json::Value>) -> Result<String, WorkflowError> {
        let registry = self.workflow_registry.read().await;
        let workflow = registry.get(workflow_id)
            .ok_or(WorkflowError::WorkflowNotFound)?;
        
        let instance_id = Uuid::new_v4().to_string();
        let instance = WorkflowInstance {
            id: instance_id.clone(),
            workflow_id: workflow_id.to_string(),
            status: WorkflowStatus::Running,
            input_data,
            output_data: HashMap::new(),
            variables: HashMap::new(),
            current_nodes: Vec::new(),
            execution_history: Vec::new(),
            created_at: Utc::now(),
        };
        
        self.state_manager.create_instance(instance.clone()).await;
        self.execution_engine.start_execution(instance).await?;
        
        Ok(instance_id)
    }

    // 获取工作流实例状态
    pub async fn get_instance_status(&self, instance_id: &str) -> Option<WorkflowStatus> {
        self.state_manager.get_instance_status(instance_id).await
    }

    // 暂停工作流实例
    pub async fn pause_instance(&self, instance_id: &str) -> Result<(), WorkflowError> {
        self.execution_engine.pause_execution(instance_id).await
    }

    // 恢复工作流实例
    pub async fn resume_instance(&self, instance_id: &str) -> Result<(), WorkflowError> {
        self.execution_engine.resume_execution(instance_id).await
    }

    // 取消工作流实例
    pub async fn cancel_instance(&self, instance_id: &str) -> Result<(), WorkflowError> {
        self.execution_engine.cancel_execution(instance_id).await
    }
}
```

### 2. 工作流实例和执行引擎

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkflowInstance {
    pub id: String,
    pub workflow_id: String,
    pub status: WorkflowStatus,
    pub input_data: HashMap<String, serde_json::Value>,
    pub output_data: HashMap<String, serde_json::Value>,
    pub variables: HashMap<String, serde_json::Value>,
    pub current_nodes: Vec<String>,
    pub execution_history: Vec<ExecutionStep>,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WorkflowStatus {
    Created,
    Running,
    Paused,
    Completed,
    Failed,
    Cancelled,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionStep {
    pub step_id: String,
    pub node_id: String,
    pub node_name: String,
    pub node_type: NodeType,
    pub status: StepStatus,
    pub input_data: HashMap<String, serde_json::Value>,
    pub output_data: HashMap<String, serde_json::Value>,
    pub started_at: DateTime<Utc>,
    pub completed_at: Option<DateTime<Utc>>,
    pub error_message: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StepStatus {
    Pending,
    Running,
    Completed,
    Failed,
    Skipped,
}

pub struct ExecutionEngine {
    active_instances: Arc<RwLock<HashMap<String, WorkflowInstance>>>,
}

impl ExecutionEngine {
    pub fn new() -> Self {
        Self {
            active_instances: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    // 启动工作流执行
    pub async fn start_execution(&self, mut instance: WorkflowInstance) -> Result<(), WorkflowError> {
        // 验证工作流定义
        let workflow = self.get_workflow_definition(&instance.workflow_id).await
            .ok_or(WorkflowError::WorkflowNotFound)?;
        
        // 初始化变量
        self.initialize_variables(&mut instance, &workflow).await;
        
        // 找到开始节点
        let start_nodes = workflow.nodes.iter()
            .filter(|node| matches!(node.node_type, NodeType::Start))
            .collect::<Vec<_>>();
        
        if start_nodes.is_empty() {
            return Err(WorkflowError::NoStartNode);
        }
        
        // 添加到活动实例
        let mut instances = self.active_instances.write().await;
        instances.insert(instance.id.clone(), instance.clone());
        
        // 开始执行
        for start_node in start_nodes {
            self.execute_node(&mut instance, start_node, &workflow).await?;
        }
        
        Ok(())
    }

    // 执行节点
    async fn execute_node(&self, instance: &mut WorkflowInstance, node: &WorkflowNode, workflow: &WorkflowDefinition) -> Result<(), WorkflowError> {
        let step_id = Uuid::new_v4().to_string();
        let mut step = ExecutionStep {
            step_id: step_id.clone(),
            node_id: node.id.clone(),
            node_name: node.name.clone(),
            node_type: node.node_type.clone(),
            status: StepStatus::Running,
            input_data: HashMap::new(),
            output_data: HashMap::new(),
            started_at: Utc::now(),
            completed_at: None,
            error_message: None,
        };
        
        // 准备输入数据
        step.input_data = self.prepare_node_input(instance, node).await;
        
        // 执行节点
        let result = match &node.node_type {
            NodeType::Start => self.execute_start_node(instance, node).await,
            NodeType::Task => self.execute_task_node(instance, node).await,
            NodeType::Decision => self.execute_decision_node(instance, node).await,
            NodeType::Parallel => self.execute_parallel_node(instance, node).await,
            NodeType::End => self.execute_end_node(instance, node).await,
        };
        
        // 处理执行结果
        match result {
            Ok(output) => {
                step.status = StepStatus::Completed;
                step.output_data = output;
                step.completed_at = Some(Utc::now());
            }
            Err(error) => {
                step.status = StepStatus::Failed;
                step.error_message = Some(error.to_string());
                step.completed_at = Some(Utc::now());
            }
        }
        
        // 记录执行步骤
        instance.execution_history.push(step);
        
        // 更新当前节点
        instance.current_nodes.retain(|id| *id != node.id);
        
        // 查找下一个节点
        if step.status == StepStatus::Completed {
            let next_nodes = self.find_next_nodes(workflow, &node.id, &step.output_data).await;
            for next_node in next_nodes {
                instance.current_nodes.push(next_node.id.clone());
                self.execute_node(instance, &next_node, workflow).await?;
            }
        }
        
        Ok(())
    }

    // 执行任务节点
    async fn execute_task_node(&self, instance: &WorkflowInstance, node: &WorkflowNode) -> Result<HashMap<String, serde_json::Value>, WorkflowError> {
        let task_type = node.config.get("task_type")
            .and_then(|v| v.as_str())
            .ok_or(WorkflowError::InvalidNodeConfig)?;
        
        let task_config = node.config.get("task_config")
            .and_then(|v| v.as_object())
            .ok_or(WorkflowError::InvalidNodeConfig)?;
        
        match task_type {
            "http_request" => self.execute_http_task(task_config).await,
            "notification" => self.execute_notification_task(task_config).await,
            _ => Err(WorkflowError::UnsupportedTaskType),
        }
    }

    // 执行HTTP任务
    async fn execute_http_task(&self, config: &serde_json::Map<String, serde_json::Value>) -> Result<HashMap<String, serde_json::Value>, WorkflowError> {
        let url = config.get("url")
            .and_then(|v| v.as_str())
            .ok_or(WorkflowError::InvalidNodeConfig)?;
        
        let method = config.get("method")
            .and_then(|v| v.as_str())
            .unwrap_or("GET");
        
        let client = reqwest::Client::new();
        let mut request = match method {
            "GET" => client.get(url),
            "POST" => client.post(url),
            "PUT" => client.put(url),
            "DELETE" => client.delete(url),
            _ => return Err(WorkflowError::InvalidNodeConfig),
        };
        
        // 添加请求体
        if let Some(body) = config.get("body") {
            request = request.json(body);
        }
        
        let response = request.send().await
            .map_err(|e| WorkflowError::TaskExecutionError(e.to_string()))?;
        
        let status = response.status();
        let body = response.text().await
            .map_err(|e| WorkflowError::TaskExecutionError(e.to_string()))?;
        
        let mut result = HashMap::new();
        result.insert("status_code".to_string(), serde_json::Value::Number(status.as_u16().into()));
        result.insert("body".to_string(), serde_json::Value::String(body));
        
        Ok(result)
    }

    // 执行决策节点
    async fn execute_decision_node(&self, instance: &WorkflowInstance, node: &WorkflowNode) -> Result<HashMap<String, serde_json::Value>, WorkflowError> {
        let conditions = node.config.get("conditions")
            .and_then(|v| v.as_array())
            .ok_or(WorkflowError::InvalidNodeConfig)?;
        
        for condition_value in conditions {
            if let Some(condition_obj) = condition_value.as_object() {
                let field = condition_obj.get("field")
                    .and_then(|v| v.as_str())
                    .ok_or(WorkflowError::InvalidNodeConfig)?;
                
                let operator = condition_obj.get("operator")
                    .and_then(|v| v.as_str())
                    .ok_or(WorkflowError::InvalidNodeConfig)?;
                
                let value = condition_obj.get("value")
                    .ok_or(WorkflowError::InvalidNodeConfig)?;
                
                let field_value = instance.variables.get(field)
                    .or_else(|| instance.input_data.get(field))
                    .ok_or(WorkflowError::VariableNotFound)?;
                
                let matches = self.evaluate_condition(field_value, operator, value)?;
                
                if matches {
                    let mut result = HashMap::new();
                    result.insert("decision".to_string(), serde_json::Value::String(field.to_string()));
                    result.insert("matched".to_string(), serde_json::Value::Bool(true));
                    return Ok(result);
                }
            }
        }
        
        // 默认分支
        let mut result = HashMap::new();
        result.insert("decision".to_string(), serde_json::Value::String("default".to_string()));
        result.insert("matched".to_string(), serde_json::Value::Bool(false));
        Ok(result)
    }

    // 评估条件
    fn evaluate_condition(&self, field_value: &serde_json::Value, operator: &str, condition_value: &serde_json::Value) -> Result<bool, WorkflowError> {
        match operator {
            "equals" => Ok(field_value == condition_value),
            "not_equals" => Ok(field_value != condition_value),
            "greater_than" => {
                if let (Some(field_num), Some(condition_num)) = (field_value.as_f64(), condition_value.as_f64()) {
                    Ok(field_num > condition_num)
                } else {
                    Err(WorkflowError::InvalidCondition)
                }
            }
            "less_than" => {
                if let (Some(field_num), Some(condition_num)) = (field_value.as_f64(), condition_value.as_f64()) {
                    Ok(field_num < condition_num)
                } else {
                    Err(WorkflowError::InvalidCondition)
                }
            }
            _ => Err(WorkflowError::InvalidCondition),
        }
    }

    // 查找下一个节点
    async fn find_next_nodes(&self, workflow: &WorkflowDefinition, current_node_id: &str, output_data: &HashMap<String, serde_json::Value>) -> Vec<WorkflowNode> {
        let mut next_nodes = Vec::new();
        
        for edge in &workflow.edges {
            if edge.source_node_id == current_node_id {
                // 检查边条件
                if let Some(condition) = &edge.condition {
                    if self.evaluate_condition(
                        output_data.get(&condition.field).unwrap_or(&serde_json::Value::Null),
                        &condition.operator.to_string(),
                        &condition.value
                    ).unwrap_or(false) {
                        if let Some(node) = workflow.nodes.iter().find(|n| n.id == edge.target_node_id) {
                            next_nodes.push(node.clone());
                        }
                    }
                } else {
                    // 无条件边
                    if let Some(node) = workflow.nodes.iter().find(|n| n.id == edge.target_node_id) {
                        next_nodes.push(node.clone());
                    }
                }
            }
        }
        
        next_nodes
    }

    // 暂停执行
    pub async fn pause_execution(&self, instance_id: &str) -> Result<(), WorkflowError> {
        let mut instances = self.active_instances.write().await;
        if let Some(instance) = instances.get_mut(instance_id) {
            instance.status = WorkflowStatus::Paused;
        }
        Ok(())
    }

    // 恢复执行
    pub async fn resume_execution(&self, instance_id: &str) -> Result<(), WorkflowError> {
        let mut instances = self.active_instances.write().await;
        if let Some(instance) = instances.get_mut(instance_id) {
            instance.status = WorkflowStatus::Running;
        }
        Ok(())
    }

    // 取消执行
    pub async fn cancel_execution(&self, instance_id: &str) -> Result<(), WorkflowError> {
        let mut instances = self.active_instances.write().await;
        if let Some(instance) = instances.get_mut(instance_id) {
            instance.status = WorkflowStatus::Cancelled;
        }
        Ok(())
    }

    async fn get_workflow_definition(&self, workflow_id: &str) -> Option<WorkflowDefinition> {
        // 这里应该从工作流注册表获取定义
        None
    }

    async fn initialize_variables(&self, instance: &mut WorkflowInstance, workflow: &WorkflowDefinition) {
        // 将输入数据复制到变量中
        for (key, value) in &instance.input_data {
            instance.variables.insert(key.clone(), value.clone());
        }
    }

    async fn prepare_node_input(&self, instance: &WorkflowInstance, node: &WorkflowNode) -> HashMap<String, serde_json::Value> {
        let mut input = HashMap::new();
        
        // 从变量和输入数据中获取节点输入
        if let Some(input_mapping) = node.config.get("input_mapping") {
            if let Some(mapping_obj) = input_mapping.as_object() {
                for (target_field, source_field) in mapping_obj {
                    if let Some(source_value) = instance.variables.get(source_field.as_str().unwrap_or("")) {
                        input.insert(target_field.clone(), source_value.clone());
                    }
                }
            }
        }
        
        input
    }

    // 其他节点类型的执行方法
    async fn execute_start_node(&self, _instance: &WorkflowInstance, _node: &WorkflowNode) -> Result<HashMap<String, serde_json::Value>, WorkflowError> {
        Ok(HashMap::new())
    }

    async fn execute_parallel_node(&self, _instance: &WorkflowInstance, _node: &WorkflowNode) -> Result<HashMap<String, serde_json::Value>, WorkflowError> {
        Ok(HashMap::new())
    }

    async fn execute_end_node(&self, _instance: &WorkflowInstance, _node: &WorkflowNode) -> Result<HashMap<String, serde_json::Value>, WorkflowError> {
        Ok(HashMap::new())
    }

    async fn execute_notification_task(&self, _config: &serde_json::Map<String, serde_json::Value>) -> Result<HashMap<String, serde_json::Value>, WorkflowError> {
        Ok(HashMap::new())
    }
}
```

### 3. 状态管理器

```rust
pub struct StateManager {
    instances: Arc<RwLock<HashMap<String, WorkflowInstance>>>,
    completed_instances: Arc<RwLock<Vec<WorkflowInstance>>>,
}

impl StateManager {
    pub fn new() -> Self {
        Self {
            instances: Arc::new(RwLock::new(HashMap::new())),
            completed_instances: Arc::new(RwLock::new(Vec::new())),
        }
    }

    // 创建实例
    pub async fn create_instance(&self, instance: WorkflowInstance) {
        let mut instances = self.instances.write().await;
        instances.insert(instance.id.clone(), instance);
    }

    // 更新实例
    pub async fn update_instance(&self, instance: WorkflowInstance) {
        let mut instances = self.instances.write().await;
        instances.insert(instance.id.clone(), instance.clone());
        
        // 如果实例已完成，移动到已完成列表
        if matches!(instance.status, WorkflowStatus::Completed | WorkflowStatus::Failed | WorkflowStatus::Cancelled) {
            instances.remove(&instance.id);
            let mut completed = self.completed_instances.write().await;
            completed.push(instance);
        }
    }

    // 获取实例状态
    pub async fn get_instance_status(&self, instance_id: &str) -> Option<WorkflowStatus> {
        let instances = self.instances.read().await;
        instances.get(instance_id).map(|i| i.status.clone())
    }

    // 获取所有活动实例
    pub async fn get_active_instances(&self) -> Vec<WorkflowInstance> {
        let instances = self.instances.read().await;
        instances.values().cloned().collect()
    }

    // 获取已完成实例
    pub async fn get_completed_instances(&self) -> Vec<WorkflowInstance> {
        let completed = self.completed_instances.read().await;
        completed.clone()
    }
}
```

### 4. 工作流引擎API

```rust
#[derive(Deserialize)]
pub struct StartWorkflowRequest {
    pub workflow_id: String,
    pub input_data: HashMap<String, serde_json::Value>,
}

#[derive(Serialize)]
pub struct WorkflowInstanceResponse {
    pub instance: WorkflowInstance,
    pub status: WorkflowStatus,
}

// 工作流引擎API路由
pub fn workflow_routes() -> Router {
    Router::new()
        .route("/workflows", post(register_workflow))
        .route("/workflows/start", post(start_workflow))
        .route("/instances/:id", get(get_instance))
        .route("/instances/:id/pause", post(pause_instance))
        .route("/instances/:id/resume", post(resume_instance))
        .route("/instances/:id/cancel", post(cancel_instance))
}

async fn register_workflow(
    Json(workflow): Json<WorkflowDefinition>,
    State(workflow_engine): State<Arc<WorkflowEngine>>,
) -> Result<Json<String>, StatusCode> {
    workflow_engine.register_workflow(workflow).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json("工作流注册成功".to_string()))
}

async fn start_workflow(
    Json(request): Json<StartWorkflowRequest>,
    State(workflow_engine): State<Arc<WorkflowEngine>>,
) -> Result<Json<String>, StatusCode> {
    let instance_id = workflow_engine.start_workflow(&request.workflow_id, request.input_data).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(instance_id))
}

async fn get_instance(
    Path(instance_id): Path<String>,
    State(workflow_engine): State<Arc<WorkflowEngine>>,
) -> Result<Json<WorkflowInstanceResponse>, StatusCode> {
    let status = workflow_engine.get_instance_status(&instance_id).await
        .ok_or(StatusCode::NOT_FOUND)?;
    
    // 这里应该从状态管理器获取完整实例信息
    let instance = WorkflowInstance {
        id: instance_id,
        workflow_id: "".to_string(),
        status: status.clone(),
        input_data: HashMap::new(),
        output_data: HashMap::new(),
        variables: HashMap::new(),
        current_nodes: Vec::new(),
        execution_history: Vec::new(),
        created_at: Utc::now(),
    };
    
    Ok(Json(WorkflowInstanceResponse {
        instance,
        status,
    }))
}

async fn pause_instance(
    Path(instance_id): Path<String>,
    State(workflow_engine): State<Arc<WorkflowEngine>>,
) -> Result<Json<String>, StatusCode> {
    workflow_engine.pause_instance(&instance_id).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json("实例已暂停".to_string()))
}

async fn resume_instance(
    Path(instance_id): Path<String>,
    State(workflow_engine): State<Arc<WorkflowEngine>>,
) -> Result<Json<String>, StatusCode> {
    workflow_engine.resume_instance(&instance_id).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json("实例已恢复".to_string()))
}

async fn cancel_instance(
    Path(instance_id): Path<String>,
    State(workflow_engine): State<Arc<WorkflowEngine>>,
) -> Result<Json<String>, StatusCode> {
    workflow_engine.cancel_instance(&instance_id).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json("实例已取消".to_string()))
}
```

## 使用示例

### 1. 创建简单工作流

```rust
#[tokio::main]
async fn main() {
    let workflow_engine = Arc::new(WorkflowEngine::new());
    
    // 创建工作流定义
    let workflow = WorkflowDefinition {
        id: "device_monitoring".to_string(),
        name: "设备监控工作流".to_string(),
        description: "监控设备状态并发送告警".to_string(),
        nodes: vec![
            WorkflowNode {
                id: "start".to_string(),
                name: "开始".to_string(),
                node_type: NodeType::Start,
                config: HashMap::new(),
            },
            WorkflowNode {
                id: "check_status".to_string(),
                name: "检查设备状态".to_string(),
                node_type: NodeType::Task,
                config: HashMap::from([
                    ("task_type".to_string(), serde_json::Value::String("http_request".to_string())),
                    ("task_config".to_string(), serde_json::json!({
                        "url": "http://api.example.com/device/status",
                        "method": "GET"
                    })),
                ]),
            },
            WorkflowNode {
                id: "decision".to_string(),
                name: "状态判断".to_string(),
                node_type: NodeType::Decision,
                config: HashMap::from([
                    ("conditions".to_string(), serde_json::json!([
                        {
                            "field": "status",
                            "operator": "equals",
                            "value": "error"
                        }
                    ])),
                ]),
            },
            WorkflowNode {
                id: "send_alert".to_string(),
                name: "发送告警".to_string(),
                node_type: NodeType::Task,
                config: HashMap::from([
                    ("task_type".to_string(), serde_json::Value::String("notification".to_string())),
                    ("task_config".to_string(), serde_json::json!({
                        "type": "email",
                        "recipients": ["admin@example.com"],
                        "subject": "设备告警",
                        "message": "设备状态异常"
                    })),
                ]),
            },
            WorkflowNode {
                id: "end".to_string(),
                name: "结束".to_string(),
                node_type: NodeType::End,
                config: HashMap::new(),
            },
        ],
        edges: vec![
            WorkflowEdge {
                id: "start_to_check".to_string(),
                source_node_id: "start".to_string(),
                target_node_id: "check_status".to_string(),
                condition: None,
            },
            WorkflowEdge {
                id: "check_to_decision".to_string(),
                source_node_id: "check_status".to_string(),
                target_node_id: "decision".to_string(),
                condition: None,
            },
            WorkflowEdge {
                id: "decision_to_alert".to_string(),
                source_node_id: "decision".to_string(),
                target_node_id: "send_alert".to_string(),
                condition: Some(Condition {
                    field: "matched".to_string(),
                    operator: Operator::Equals,
                    value: serde_json::Value::Bool(true),
                }),
            },
            WorkflowEdge {
                id: "decision_to_end".to_string(),
                source_node_id: "decision".to_string(),
                target_node_id: "end".to_string(),
                condition: Some(Condition {
                    field: "matched".to_string(),
                    operator: Operator::Equals,
                    value: serde_json::Value::Bool(false),
                }),
            },
            WorkflowEdge {
                id: "alert_to_end".to_string(),
                source_node_id: "send_alert".to_string(),
                target_node_id: "end".to_string(),
                condition: None,
            },
        ],
    };
    
    // 注册工作流
    workflow_engine.register_workflow(workflow).await.unwrap();
    
    // 启动工作流实例
    let input_data = HashMap::from([
        ("device_id".to_string(), serde_json::Value::String("device_001".to_string())),
    ]);
    
    let instance_id = workflow_engine.start_workflow("device_monitoring", input_data).await.unwrap();
    
    println!("工作流实例已启动: {}", instance_id);
}
```

### 2. 监控工作流状态

```rust
// 监控工作流状态
async fn monitor_workflow_status(workflow_engine: Arc<WorkflowEngine>, instance_id: &str) {
    loop {
        if let Some(status) = workflow_engine.get_instance_status(instance_id).await {
            println!("工作流状态: {:?}", status);
            
            match status {
                WorkflowStatus::Completed => {
                    println!("工作流执行完成");
                    break;
                }
                WorkflowStatus::Failed => {
                    println!("工作流执行失败");
                    break;
                }
                WorkflowStatus::Cancelled => {
                    println!("工作流已取消");
                    break;
                }
                _ => {
                    tokio::time::sleep(Duration::from_secs(1)).await;
                }
            }
        } else {
            println!("工作流实例不存在");
            break;
        }
    }
}
```

## 核心特性

1. **可视化工作流设计**: 支持节点和边的可视化定义
2. **多种节点类型**: 开始、结束、任务、决策、并行等
3. **条件分支**: 支持复杂的条件判断和分支逻辑
4. **并行处理**: 支持并行执行多个任务
5. **状态管理**: 完整的工作流实例状态跟踪
6. **错误处理**: 完善的错误处理和恢复机制
7. **API接口**: 完整的RESTful API支持

这个物联网工作流引擎实现提供了强大的业务流程自动化能力，支持复杂的业务逻辑和灵活的配置。
