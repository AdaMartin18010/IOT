# 物联网规则引擎实现

## 概述

物联网规则引擎提供灵活的规则定义、条件评估、动作执行和规则管理功能，支持复杂的业务逻辑处理。

## 核心架构

### 1. 规则引擎核心

```rust
pub struct RuleEngine {
    rules: Arc<RwLock<HashMap<String, Rule>>>,
    action_executor: Arc<ActionExecutor>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Rule {
    pub id: String,
    pub name: String,
    pub description: String,
    pub conditions: Vec<Condition>,
    pub actions: Vec<Action>,
    pub priority: u32,
    pub enabled: bool,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Condition {
    pub field: String,
    pub operator: ConditionOperator,
    pub value: ConditionValue,
    pub logical_operator: LogicalOperator,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConditionOperator {
    Equals,
    NotEquals,
    GreaterThan,
    LessThan,
    Contains,
    In,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConditionValue {
    String(String),
    Number(f64),
    Boolean(bool),
    Array(Vec<ConditionValue>),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogicalOperator {
    And,
    Or,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Action {
    pub id: String,
    pub action_type: ActionType,
    pub parameters: HashMap<String, ActionValue>,
    pub delay: Option<Duration>,
    pub retry_count: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ActionType {
    SendNotification,
    UpdateDevice,
    TriggerAlert,
    ExecuteScript,
    CallAPI,
    LogEvent,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ActionValue {
    String(String),
    Number(f64),
    Boolean(bool),
}

impl RuleEngine {
    pub fn new() -> Self {
        Self {
            rules: Arc::new(RwLock::new(HashMap::new())),
            action_executor: Arc::new(ActionExecutor::new()),
        }
    }

    // 添加规则
    pub async fn add_rule(&self, rule: Rule) -> Result<(), RuleError> {
        let mut rules = self.rules.write().await;
        
        if rules.contains_key(&rule.id) {
            return Err(RuleError::RuleAlreadyExists);
        }
        
        rules.insert(rule.id.clone(), rule);
        Ok(())
    }

    // 处理事件
    pub async fn process_event(&self, event: RuleEvent) -> Result<Vec<ActionResult>, RuleError> {
        let rules = self.rules.read().await;
        let mut results = Vec::new();
        
        // 按优先级排序规则
        let mut sorted_rules: Vec<&Rule> = rules.values()
            .filter(|rule| rule.enabled)
            .collect();
        sorted_rules.sort_by(|a, b| b.priority.cmp(&a.priority));
        
        for rule in sorted_rules {
            if self.evaluate_conditions(&rule.conditions, &event).await? {
                let action_results = self.execute_actions(&rule.actions, &event).await?;
                results.extend(action_results);
            }
        }
        
        Ok(results)
    }

    // 评估条件
    async fn evaluate_conditions(&self, conditions: &[Condition], event: &RuleEvent) -> Result<bool, RuleError> {
        if conditions.is_empty() {
            return Ok(true);
        }
        
        let mut result = self.evaluate_condition(&conditions[0], event).await?;
        
        for i in 1..conditions.len() {
            let condition_result = self.evaluate_condition(&conditions[i], event).await?;
            
            match conditions[i].logical_operator {
                LogicalOperator::And => result = result && condition_result,
                LogicalOperator::Or => result = result || condition_result,
            }
        }
        
        Ok(result)
    }

    // 评估单个条件
    async fn evaluate_condition(&self, condition: &Condition, event: &RuleEvent) -> Result<bool, RuleError> {
        let field_value = self.get_field_value(&condition.field, event).await?;
        
        match &condition.operator {
            ConditionOperator::Equals => {
                Ok(self.compare_values(&field_value, &condition.value) == std::cmp::Ordering::Equal)
            }
            ConditionOperator::NotEquals => {
                Ok(self.compare_values(&field_value, &condition.value) != std::cmp::Ordering::Equal)
            }
            ConditionOperator::GreaterThan => {
                Ok(self.compare_values(&field_value, &condition.value) == std::cmp::Ordering::Greater)
            }
            ConditionOperator::LessThan => {
                Ok(self.compare_values(&field_value, &condition.value) == std::cmp::Ordering::Less)
            }
            ConditionOperator::Contains => {
                if let (ConditionValue::String(field_str), ConditionValue::String(value_str)) = (&field_value, &condition.value) {
                    Ok(field_str.contains(value_str))
                } else {
                    Ok(false)
                }
            }
            ConditionOperator::In => {
                if let ConditionValue::Array(array) = &condition.value {
                    Ok(array.contains(&field_value))
                } else {
                    Ok(false)
                }
            }
        }
    }

    // 获取字段值
    async fn get_field_value(&self, field: &str, event: &RuleEvent) -> Result<ConditionValue, RuleError> {
        match field {
            "event.type" => Ok(ConditionValue::String(event.event_type.clone())),
            "event.source" => Ok(ConditionValue::String(event.source.clone())),
            "data.temperature" => {
                if let Some(temp) = event.data.get("temperature") {
                    Ok(ConditionValue::Number(temp.parse::<f64>().unwrap_or(0.0)))
                } else {
                    Ok(ConditionValue::String("0".to_string()))
                }
            }
            "data.humidity" => {
                if let Some(humidity) = event.data.get("humidity") {
                    Ok(ConditionValue::Number(humidity.parse::<f64>().unwrap_or(0.0)))
                } else {
                    Ok(ConditionValue::String("0".to_string()))
                }
            }
            _ => {
                if let Some(value) = event.data.get(field) {
                    Ok(ConditionValue::String(value.clone()))
                } else {
                    Ok(ConditionValue::String("".to_string()))
                }
            }
        }
    }

    // 比较值
    fn compare_values(&self, a: &ConditionValue, b: &ConditionValue) -> std::cmp::Ordering {
        match (a, b) {
            (ConditionValue::Number(a_num), ConditionValue::Number(b_num)) => {
                a_num.partial_cmp(b_num).unwrap_or(std::cmp::Ordering::Equal)
            }
            (ConditionValue::String(a_str), ConditionValue::String(b_str)) => {
                a_str.cmp(b_str)
            }
            _ => std::cmp::Ordering::Equal,
        }
    }

    // 执行动作
    async fn execute_actions(&self, actions: &[Action], event: &RuleEvent) -> Result<Vec<ActionResult>, RuleError> {
        let mut results = Vec::new();
        
        for action in actions {
            let result = self.action_executor.execute(action, event).await?;
            results.push(result);
        }
        
        Ok(results)
    }
}
```

### 2. 动作执行器

```rust
pub struct ActionExecutor {
    notification_service: Arc<NotificationService>,
    device_manager: Arc<DeviceManager>,
    alert_service: Arc<AlertService>,
}

impl ActionExecutor {
    pub fn new() -> Self {
        Self {
            notification_service: Arc::new(NotificationService::new()),
            device_manager: Arc::new(DeviceManager::new()),
            alert_service: Arc::new(AlertService::new()),
        }
    }

    // 执行动作
    pub async fn execute(&self, action: &Action, event: &RuleEvent) -> Result<ActionResult, RuleError> {
        let start_time = Utc::now();
        
        // 处理延迟
        if let Some(delay) = action.delay {
            tokio::time::sleep(delay).await;
        }
        
        let result = match &action.action_type {
            ActionType::SendNotification => {
                self.execute_notification_action(action, event).await
            }
            ActionType::UpdateDevice => {
                self.execute_device_action(action, event).await
            }
            ActionType::TriggerAlert => {
                self.execute_alert_action(action, event).await
            }
            ActionType::ExecuteScript => {
                self.execute_script_action(action, event).await
            }
            ActionType::CallAPI => {
                self.execute_api_action(action, event).await
            }
            ActionType::LogEvent => {
                self.execute_log_action(action, event).await
            }
        };
        
        let execution_time = Utc::now();
        
        match result {
            Ok(success) => Ok(ActionResult {
                action_id: action.id.clone(),
                success,
                result: Some("动作执行成功".to_string()),
                error: None,
                execution_time,
            }),
            Err(error) => {
                // 重试逻辑
                if action.retry_count > 0 {
                    return self.retry_action(action, event, action.retry_count).await;
                }
                
                Ok(ActionResult {
                    action_id: action.id.clone(),
                    success: false,
                    result: None,
                    error: Some(error.to_string()),
                    execution_time,
                })
            }
        }
    }

    // 执行通知动作
    async fn execute_notification_action(&self, action: &Action, event: &RuleEvent) -> Result<bool, RuleError> {
        let message = self.get_parameter_value(&action.parameters, "message")
            .unwrap_or_else(|| format!("规则触发: {}", event.event_type));
        
        let recipients = self.get_parameter_value(&action.parameters, "recipients")
            .unwrap_or_else(|| "admin".to_string());
        
        self.notification_service.send_notification(&message, &recipients).await
            .map_err(|e| RuleError::ActionExecutionFailed(e.to_string()))?;
        
        Ok(true)
    }

    // 执行设备动作
    async fn execute_device_action(&self, action: &Action, event: &RuleEvent) -> Result<bool, RuleError> {
        let device_id = self.get_parameter_value(&action.parameters, "device_id")
            .ok_or_else(|| RuleError::MissingParameter("device_id".to_string()))?;
        
        let property = self.get_parameter_value(&action.parameters, "property")
            .ok_or_else(|| RuleError::MissingParameter("property".to_string()))?;
        
        let value = self.get_parameter_value(&action.parameters, "value")
            .ok_or_else(|| RuleError::MissingParameter("value".to_string()))?;
        
        self.device_manager.update_device_property(&device_id, &property, &value).await
            .map_err(|e| RuleError::ActionExecutionFailed(e.to_string()))?;
        
        Ok(true)
    }

    // 执行告警动作
    async fn execute_alert_action(&self, action: &Action, event: &RuleEvent) -> Result<bool, RuleError> {
        let alert_type = self.get_parameter_value(&action.parameters, "type")
            .unwrap_or_else(|| "warning".to_string());
        
        let message = self.get_parameter_value(&action.parameters, "message")
            .unwrap_or_else(|| format!("规则触发告警: {}", event.event_type));
        
        let severity = self.get_parameter_value(&action.parameters, "severity")
            .unwrap_or_else(|| "medium".to_string());
        
        self.alert_service.create_alert(&alert_type, &message, &severity).await
            .map_err(|e| RuleError::ActionExecutionFailed(e.to_string()))?;
        
        Ok(true)
    }

    // 重试动作
    async fn retry_action(&self, action: &Action, event: &RuleEvent, retry_count: u32) -> Result<ActionResult, RuleError> {
        let mut last_error = None;
        
        for _attempt in 1..=retry_count {
            tokio::time::sleep(Duration::from_secs(5)).await;
            
            match self.execute(action, event).await {
                Ok(result) if result.success => {
                    return Ok(result);
                }
                Ok(result) => {
                    last_error = result.error;
                }
                Err(error) => {
                    last_error = Some(error.to_string());
                }
            }
        }
        
        Ok(ActionResult {
            action_id: action.id.clone(),
            success: false,
            result: None,
            error: last_error,
            execution_time: Utc::now(),
        })
    }

    // 获取参数值
    fn get_parameter_value(&self, parameters: &HashMap<String, ActionValue>, key: &str) -> Option<String> {
        parameters.get(key).and_then(|value| {
            match value {
                ActionValue::String(s) => Some(s.clone()),
                ActionValue::Number(n) => Some(n.to_string()),
                ActionValue::Boolean(b) => Some(b.to_string()),
            }
        })
    }
}
```

### 3. 事件处理

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleEvent {
    pub id: String,
    pub event_type: String,
    pub source: String,
    pub timestamp: DateTime<Utc>,
    pub data: HashMap<String, String>,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActionResult {
    pub action_id: String,
    pub success: bool,
    pub result: Option<String>,
    pub error: Option<String>,
    pub execution_time: DateTime<Utc>,
}

pub struct EventProcessor {
    event_queue: Arc<RwLock<VecDeque<RuleEvent>>>,
    rule_engine: Arc<RuleEngine>,
}

impl EventProcessor {
    pub fn new(rule_engine: Arc<RuleEngine>) -> Self {
        Self {
            event_queue: Arc::new(RwLock::new(VecDeque::new())),
            rule_engine,
        }
    }

    // 启动事件处理器
    pub async fn start(&self) {
        let event_queue = self.event_queue.clone();
        let rule_engine = self.rule_engine.clone();
        
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_millis(100));
            
            loop {
                interval.tick().await;
                
                let mut queue = event_queue.write().await;
                if let Some(event) = queue.pop_front() {
                    drop(queue);
                    
                    if let Ok(results) = rule_engine.process_event(event).await {
                        for result in results {
                            if result.success {
                                println!("动作执行成功: {}", result.action_id);
                            } else {
                                println!("动作执行失败: {} - {:?}", result.action_id, result.error);
                            }
                        }
                    }
                }
            }
        });
    }

    // 添加事件到队列
    pub async fn add_event(&self, event: RuleEvent) {
        let mut queue = self.event_queue.write().await;
        queue.push_back(event);
    }
}
```

### 4. 规则引擎API

```rust
#[derive(Deserialize)]
pub struct CreateRuleRequest {
    pub name: String,
    pub description: String,
    pub conditions: Vec<Condition>,
    pub actions: Vec<Action>,
    pub priority: u32,
}

#[derive(Serialize)]
pub struct RuleResponse {
    pub rule: Rule,
    pub compiled: bool,
}

// 规则引擎API路由
pub fn rule_engine_routes() -> Router {
    Router::new()
        .route("/rules", post(create_rule))
        .route("/rules", get(list_rules))
        .route("/rules/:id", get(get_rule))
        .route("/rules/:id", put(update_rule))
        .route("/rules/:id", delete(delete_rule))
        .route("/events", post(process_event))
        .route("/test", post(test_rule))
}

async fn create_rule(
    Json(request): Json<CreateRuleRequest>,
    State(rule_engine): State<Arc<RuleEngine>>,
) -> Result<Json<RuleResponse>, StatusCode> {
    let rule = Rule {
        id: Uuid::new_v4().to_string(),
        name: request.name,
        description: request.description,
        conditions: request.conditions,
        actions: request.actions,
        priority: request.priority,
        enabled: true,
        created_at: Utc::now(),
    };

    rule_engine.add_rule(rule.clone()).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(RuleResponse {
        rule,
        compiled: true,
    }))
}

async fn process_event(
    Json(event): Json<RuleEvent>,
    State(rule_engine): State<Arc<RuleEngine>>,
) -> Result<Json<Vec<ActionResult>>, StatusCode> {
    let results = rule_engine.process_event(event).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(results))
}
```

## 使用示例

### 1. 创建温度监控规则

```rust
#[tokio::main]
async fn main() {
    let rule_engine = Arc::new(RuleEngine::new());
    
    // 创建温度过高告警规则
    let temperature_rule = Rule {
        id: "temp-alert".to_string(),
        name: "温度过高告警".to_string(),
        description: "当温度超过30度时发送告警".to_string(),
        conditions: vec![
            Condition {
                field: "data.temperature".to_string(),
                operator: ConditionOperator::GreaterThan,
                value: ConditionValue::Number(30.0),
                logical_operator: LogicalOperator::And,
            },
        ],
        actions: vec![
            Action {
                id: "send-alert".to_string(),
                action_type: ActionType::TriggerAlert,
                parameters: HashMap::from([
                    ("type".to_string(), ActionValue::String("temperature_alert".to_string())),
                    ("message".to_string(), ActionValue::String("温度过高: {temperature}°C".to_string())),
                    ("severity".to_string(), ActionValue::String("high".to_string())),
                ]),
                delay: None,
                retry_count: 3,
            },
        ],
        priority: 100,
        enabled: true,
        created_at: Utc::now(),
    };

    rule_engine.add_rule(temperature_rule).await.unwrap();
    println!("温度监控规则创建成功");
}
```

### 2. 处理传感器事件

```rust
// 处理传感器事件
async fn process_sensor_event(rule_engine: Arc<RuleEngine>) {
    let sensor_event = RuleEvent {
        id: Uuid::new_v4().to_string(),
        event_type: "sensor_data".to_string(),
        source: "temperature_sensor_001".to_string(),
        timestamp: Utc::now(),
        data: HashMap::from([
            ("temperature".to_string(), "35.5".to_string()),
            ("humidity".to_string(), "60.0".to_string()),
            ("status".to_string(), "normal".to_string()),
        ]),
        metadata: HashMap::new(),
    };

    let results = rule_engine.process_event(sensor_event).await.unwrap();
    
    for result in results {
        if result.success {
            println!("规则动作执行成功: {}", result.action_id);
        } else {
            println!("规则动作执行失败: {} - {:?}", result.action_id, result.error);
        }
    }
}
```

## 核心特性

1. **灵活规则定义**: 支持复杂的条件和动作组合
2. **条件评估**: 多种操作符、逻辑运算符支持
3. **动作执行**: 多种动作类型、重试机制
4. **事件处理**: 异步事件处理、批量处理
5. **优先级管理**: 规则优先级排序
6. **规则管理**: 规则的增删改查、启用禁用
7. **测试支持**: 规则测试、调试功能

这个物联网规则引擎实现提供了强大的业务逻辑处理能力，支持复杂的规则定义和自动化操作。
