# 语义映射引擎实现

## 1. 本体对齐算法

### 1.1 字符串相似度算法

```rust
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use rayon::prelude::*;

/// 字符串相似度算法
pub struct StringSimilarity {
    algorithms: Vec<SimilarityAlgorithm>,
}

#[derive(Debug, Clone)]
pub enum SimilarityAlgorithm {
    Levenshtein,
    JaroWinkler,
    Cosine,
    Jaccard,
    Soundex,
}

impl StringSimilarity {
    pub fn new() -> Self {
        Self {
            algorithms: vec![
                SimilarityAlgorithm::Levenshtein,
                SimilarityAlgorithm::JaroWinkler,
                SimilarityAlgorithm::Cosine,
                SimilarityAlgorithm::Jaccard,
                SimilarityAlgorithm::Soundex,
            ],
        }
    }

    /// 计算编辑距离
    pub fn levenshtein_distance(&self, s1: &str, s2: &str) -> f64 {
        let len1 = s1.chars().count();
        let len2 = s2.chars().count();
        
        if len1 == 0 { return len2 as f64; }
        if len2 == 0 { return len1 as f64; }
        
        let mut matrix = vec![vec![0; len2 + 1]; len1 + 1];
        
        for i in 0..=len1 {
            matrix[i][0] = i;
        }
        for j in 0..=len2 {
            matrix[0][j] = j;
        }
        
        for (i, c1) in s1.chars().enumerate() {
            for (j, c2) in s2.chars().enumerate() {
                let cost = if c1 == c2 { 0 } else { 1 };
                matrix[i + 1][j + 1] = (matrix[i][j + 1] + 1)
                    .min(matrix[i + 1][j] + 1)
                    .min(matrix[i][j] + cost);
            }
        }
        
        let distance = matrix[len1][len2] as f64;
        let max_len = len1.max(len2) as f64;
        1.0 - (distance / max_len)
    }

    /// 计算Jaro-Winkler相似度
    pub fn jaro_winkler_similarity(&self, s1: &str, s2: &str) -> f64 {
        if s1 == s2 { return 1.0; }
        if s1.is_empty() || s2.is_empty() { return 0.0; }
        
        let match_distance = ((s1.len().max(s2.len()) / 2) - 1).max(0);
        let mut s1_matches = vec![false; s1.len()];
        let mut s2_matches = vec![false; s2.len()];
        
        let mut matches = 0;
        let mut transpositions = 0;
        
        // 查找匹配字符
        for (i, c1) in s1.chars().enumerate() {
            let start = i.saturating_sub(match_distance);
            let end = (i + match_distance + 1).min(s2.len());
            
            for j in start..end {
                if !s2_matches[j] && c1 == s2.chars().nth(j).unwrap() {
                    s1_matches[i] = true;
                    s2_matches[j] = true;
                    matches += 1;
                    break;
                }
            }
        }
        
        if matches == 0 { return 0.0; }
        
        // 计算转置
        let mut k = 0;
        for (i, matched) in s1_matches.iter().enumerate() {
            if *matched {
                while !s2_matches[k] {
                    k += 1;
                }
                if s1.chars().nth(i).unwrap() != s2.chars().nth(k).unwrap() {
                    transpositions += 1;
                }
                k += 1;
            }
        }
        
        let jaro = (matches as f64 / s1.len() as f64 + 
                   matches as f64 / s2.len() as f64 + 
                   (matches as f64 - transpositions as f64 / 2.0) / matches as f64) / 3.0;
        
        // Winkler修正
        let prefix_length = s1.chars().zip(s2.chars())
            .take_while(|(c1, c2)| c1 == c2)
            .count()
            .min(4);
        
        jaro + 0.1 * prefix_length as f64 * (1.0 - jaro)
    }

    /// 计算余弦相似度
    pub fn cosine_similarity(&self, s1: &str, s2: &str) -> f64 {
        let words1 = self.tokenize(s1);
        let words2 = self.tokenize(s2);
        
        let mut word_freq1 = HashMap::new();
        let mut word_freq2 = HashMap::new();
        
        for word in &words1 {
            *word_freq1.entry(word.clone()).or_insert(0) += 1;
        }
        for word in &words2 {
            *word_freq2.entry(word.clone()).or_insert(0) += 1;
        }
        
        let all_words: std::collections::HashSet<_> = word_freq1.keys()
            .chain(word_freq2.keys())
            .collect();
        
        let mut dot_product = 0.0;
        let mut norm1 = 0.0;
        let mut norm2 = 0.0;
        
        for word in all_words {
            let freq1 = *word_freq1.get(word).unwrap_or(&0) as f64;
            let freq2 = *word_freq2.get(word).unwrap_or(&0) as f64;
            
            dot_product += freq1 * freq2;
            norm1 += freq1 * freq1;
            norm2 += freq2 * freq2;
        }
        
        if norm1 == 0.0 || norm2 == 0.0 {
            return 0.0;
        }
        
        dot_product / (norm1.sqrt() * norm2.sqrt())
    }

    /// 计算Jaccard相似度
    pub fn jaccard_similarity(&self, s1: &str, s2: &str) -> f64 {
        let words1: std::collections::HashSet<_> = self.tokenize(s1).into_iter().collect();
        let words2: std::collections::HashSet<_> = self.tokenize(s2).into_iter().collect();
        
        let intersection = words1.intersection(&words2).count();
        let union = words1.union(&words2).count();
        
        if union == 0 { return 0.0; }
        intersection as f64 / union as f64
    }

    /// 计算Soundex编码
    pub fn soundex(&self, s: &str) -> String {
        if s.is_empty() { return String::new(); }
        
        let mut result = String::new();
        let mut last_code = None;
        
        // 第一个字符
        if let Some(first_char) = s.chars().next() {
            result.push(first_char.to_ascii_uppercase());
        }
        
        for c in s.chars().skip(1) {
            let code = match c.to_ascii_lowercase() {
                'b' | 'f' | 'p' | 'v' => Some('1'),
                'c' | 'g' | 'j' | 'k' | 'q' | 's' | 'x' | 'z' => Some('2'),
                'd' | 't' => Some('3'),
                'l' => Some('4'),
                'm' | 'n' => Some('5'),
                'r' => Some('6'),
                _ => None,
            };
            
            if let Some(current_code) = code {
                if Some(current_code) != last_code {
                    result.push(current_code);
                    last_code = Some(current_code);
                }
            }
        }
        
        // 填充到4位
        while result.len() < 4 {
            result.push('0');
        }
        
        result[..4].to_string()
    }

    /// 分词
    fn tokenize(&self, text: &str) -> Vec<String> {
        text.to_lowercase()
            .split_whitespace()
            .map(|s| s.to_string())
            .collect()
    }

    /// 计算综合相似度
    pub fn calculate_similarity(&self, s1: &str, s2: &str) -> f64 {
        let mut similarities = Vec::new();
        
        for algorithm in &self.algorithms {
            let similarity = match algorithm {
                SimilarityAlgorithm::Levenshtein => self.levenshtein_distance(s1, s2),
                SimilarityAlgorithm::JaroWinkler => self.jaro_winkler_similarity(s1, s2),
                SimilarityAlgorithm::Cosine => self.cosine_similarity(s1, s2),
                SimilarityAlgorithm::Jaccard => self.jaccard_similarity(s1, s2),
                SimilarityAlgorithm::Soundex => {
                    if self.soundex(s1) == self.soundex(s2) { 1.0 } else { 0.0 }
                },
            };
            similarities.push(similarity);
        }
        
        // 加权平均
        similarities.iter().sum::<f64>() / similarities.len() as f64
    }
}
```

### 1.2 本体概念映射

```rust
/// 本体概念
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OntologyConcept {
    pub id: String,
    pub label: String,
    pub description: Option<String>,
    pub synonyms: Vec<String>,
    pub properties: HashMap<String, String>,
    pub parent_concepts: Vec<String>,
    pub child_concepts: Vec<String>,
}

/// 概念映射
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConceptMapping {
    pub source_concept: String,
    pub target_concept: String,
    pub similarity_score: f64,
    pub mapping_type: MappingType,
    pub confidence: f64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MappingType {
    Exact,      // 完全匹配
    Subsumption, // 包含关系
    Overlap,    // 部分重叠
    Related,    // 相关概念
}

/// 本体映射引擎
pub struct OntologyMapper {
    similarity_calculator: StringSimilarity,
    concepts: HashMap<String, OntologyConcept>,
    mappings: Vec<ConceptMapping>,
    threshold: f64,
}

impl OntologyMapper {
    pub fn new(threshold: f64) -> Self {
        Self {
            similarity_calculator: StringSimilarity::new(),
            concepts: HashMap::new(),
            mappings: Vec::new(),
            threshold,
        }
    }

    /// 添加概念
    pub fn add_concept(&mut self, concept: OntologyConcept) {
        self.concepts.insert(concept.id.clone(), concept);
    }

    /// 自动映射概念
    pub fn auto_map_concepts(&mut self) -> Vec<ConceptMapping> {
        let mut new_mappings = Vec::new();
        let concept_ids: Vec<String> = self.concepts.keys().cloned().collect();
        
        // 并行计算所有概念对之间的相似度
        let mappings: Vec<ConceptMapping> = concept_ids.par_iter()
            .flat_map(|source_id| {
                let source_concept = &self.concepts[source_id];
                concept_ids.iter()
                    .filter(|target_id| source_id != *target_id)
                    .map(|target_id| {
                        let target_concept = &self.concepts[target_id];
                        self.calculate_concept_similarity(source_concept, target_concept)
                    })
                    .filter(|mapping| mapping.similarity_score >= self.threshold)
                    .collect::<Vec<_>>()
            })
            .collect();
        
        new_mappings.extend(mappings);
        self.mappings.extend(new_mappings.clone());
        new_mappings
    }

    /// 计算概念相似度
    fn calculate_concept_similarity(&self, source: &OntologyConcept, target: &OntologyConcept) -> ConceptMapping {
        let mut scores = Vec::new();
        
        // 标签相似度
        let label_similarity = self.similarity_calculator.calculate_similarity(&source.label, &target.label);
        scores.push(label_similarity);
        
        // 描述相似度
        if let (Some(desc1), Some(desc2)) = (&source.description, &target.description) {
            let desc_similarity = self.similarity_calculator.calculate_similarity(desc1, desc2);
            scores.push(desc_similarity);
        }
        
        // 同义词相似度
        let synonym_similarity = self.calculate_synonym_similarity(&source.synonyms, &target.synonyms);
        scores.push(synonym_similarity);
        
        // 属性相似度
        let property_similarity = self.calculate_property_similarity(&source.properties, &target.properties);
        scores.push(property_similarity);
        
        // 层次结构相似度
        let hierarchy_similarity = self.calculate_hierarchy_similarity(source, target);
        scores.push(hierarchy_similarity);
        
        let average_score = scores.iter().sum::<f64>() / scores.len() as f64;
        
        let mapping_type = if average_score >= 0.95 {
            MappingType::Exact
        } else if average_score >= 0.8 {
            MappingType::Subsumption
        } else if average_score >= 0.6 {
            MappingType::Overlap
        } else {
            MappingType::Related
        };
        
        ConceptMapping {
            source_concept: source.id.clone(),
            target_concept: target.id.clone(),
            similarity_score: average_score,
            mapping_type,
            confidence: average_score,
        }
    }

    /// 计算同义词相似度
    fn calculate_synonym_similarity(&self, synonyms1: &[String], synonyms2: &[String]) -> f64 {
        if synonyms1.is_empty() && synonyms2.is_empty() {
            return 1.0;
        }
        if synonyms1.is_empty() || synonyms2.is_empty() {
            return 0.0;
        }
        
        let mut max_similarities = Vec::new();
        
        for syn1 in synonyms1 {
            let mut similarities = Vec::new();
            for syn2 in synonyms2 {
                similarities.push(self.similarity_calculator.calculate_similarity(syn1, syn2));
            }
            if let Some(&max_sim) = similarities.iter().max_by(|a, b| a.partial_cmp(b).unwrap()) {
                max_similarities.push(max_sim);
            }
        }
        
        if max_similarities.is_empty() { 0.0 } else {
            max_similarities.iter().sum::<f64>() / max_similarities.len() as f64
        }
    }

    /// 计算属性相似度
    fn calculate_property_similarity(&self, props1: &HashMap<String, String>, props2: &HashMap<String, String>) -> f64 {
        if props1.is_empty() && props2.is_empty() {
            return 1.0;
        }
        if props1.is_empty() || props2.is_empty() {
            return 0.0;
        }
        
        let keys1: std::collections::HashSet<_> = props1.keys().collect();
        let keys2: std::collections::HashSet<_> = props2.keys().collect();
        
        let intersection = keys1.intersection(&keys2).count();
        let union = keys1.union(&keys2).count();
        
        if union == 0 { return 0.0; }
        
        let key_similarity = intersection as f64 / union as f64;
        
        // 计算共同属性的值相似度
        let mut value_similarities = Vec::new();
        for key in keys1.intersection(&keys2) {
            if let (Some(val1), Some(val2)) = (props1.get(key), props2.get(key)) {
                value_similarities.push(self.similarity_calculator.calculate_similarity(val1, val2));
            }
        }
        
        let value_similarity = if value_similarities.is_empty() {
            0.0
        } else {
            value_similarities.iter().sum::<f64>() / value_similarities.len() as f64
        };
        
        (key_similarity + value_similarity) / 2.0
    }

    /// 计算层次结构相似度
    fn calculate_hierarchy_similarity(&self, source: &OntologyConcept, target: &OntologyConcept) -> f64 {
        let mut scores = Vec::new();
        
        // 父概念相似度
        for parent1 in &source.parent_concepts {
            for parent2 in &target.parent_concepts {
                if let (Some(concept1), Some(concept2)) = (self.concepts.get(parent1), self.concepts.get(parent2)) {
                    let parent_similarity = self.similarity_calculator.calculate_similarity(&concept1.label, &concept2.label);
                    scores.push(parent_similarity);
                }
            }
        }
        
        // 子概念相似度
        for child1 in &source.child_concepts {
            for child2 in &target.child_concepts {
                if let (Some(concept1), Some(concept2)) = (self.concepts.get(child1), self.concepts.get(child2)) {
                    let child_similarity = self.similarity_calculator.calculate_similarity(&concept1.label, &concept2.label);
                    scores.push(child_similarity);
                }
            }
        }
        
        if scores.is_empty() { 0.0 } else {
            scores.iter().sum::<f64>() / scores.len() as f64
        }
    }

    /// 获取映射
    pub fn get_mappings(&self) -> &[ConceptMapping] {
        &self.mappings
    }

    /// 根据源概念获取映射
    pub fn get_mappings_by_source(&self, source_id: &str) -> Vec<&ConceptMapping> {
        self.mappings.iter()
            .filter(|mapping| mapping.source_concept == source_id)
            .collect()
    }

    /// 根据目标概念获取映射
    pub fn get_mappings_by_target(&self, target_id: &str) -> Vec<&ConceptMapping> {
        self.mappings.iter()
            .filter(|mapping| mapping.target_concept == target_id)
            .collect()
    }
}
```

## 2. 语义转换引擎

### 2.1 数据格式转换

```rust
/// 数据格式
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DataFormat {
    JSON,
    XML,
    CSV,
    ProtocolBuffer,
    Avro,
    Parquet,
    YAML,
    TOML,
}

/// 数据转换器
pub struct DataConverter {
    converters: HashMap<(DataFormat, DataFormat), Box<dyn FormatConverter>>,
}

/// 格式转换器接口
pub trait FormatConverter: Send + Sync {
    fn convert(&self, data: &[u8], source_format: DataFormat, target_format: DataFormat) -> Result<Vec<u8>, Box<dyn std::error::Error>>;
}

impl DataConverter {
    pub fn new() -> Self {
        let mut converters = HashMap::new();
        
        // 注册转换器
        converters.insert((DataFormat::JSON, DataFormat::XML), Box::new(JsonToXmlConverter));
        converters.insert((DataFormat::XML, DataFormat::JSON), Box::new(XmlToJsonConverter));
        converters.insert((DataFormat::JSON, DataFormat::CSV), Box::new(JsonToCsvConverter));
        converters.insert((DataFormat::CSV, DataFormat::JSON), Box::new(CsvToJsonConverter));
        
        Self { converters }
    }

    /// 转换数据格式
    pub fn convert(&self, data: &[u8], source_format: DataFormat, target_format: DataFormat) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        if source_format == target_format {
            return Ok(data.to_vec());
        }
        
        if let Some(converter) = self.converters.get(&(source_format.clone(), target_format.clone())) {
            converter.convert(data, source_format, target_format)
        } else {
            Err(format!("No converter available from {:?} to {:?}", source_format, target_format).into())
        }
    }
}

/// JSON到XML转换器
pub struct JsonToXmlConverter;

impl FormatConverter for JsonToXmlConverter {
    fn convert(&self, data: &[u8], _source_format: DataFormat, _target_format: DataFormat) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let json_value: serde_json::Value = serde_json::from_slice(data)?;
        let xml_string = self.json_to_xml(&json_value, "root")?;
        Ok(xml_string.into_bytes())
    }
}

impl JsonToXmlConverter {
    fn json_to_xml(&self, value: &serde_json::Value, root_name: &str) -> Result<String, Box<dyn std::error::Error>> {
        match value {
            serde_json::Value::Object(map) => {
                let mut xml = format!("<{}>", root_name);
                for (key, val) in map {
                    xml.push_str(&self.json_to_xml(val, key)?);
                }
                xml.push_str(&format!("</{}>", root_name));
                Ok(xml)
            }
            serde_json::Value::Array(arr) => {
                let mut xml = format!("<{}>", root_name);
                for item in arr {
                    xml.push_str(&self.json_to_xml(item, "item")?);
                }
                xml.push_str(&format!("</{}>", root_name));
                Ok(xml)
            }
            serde_json::Value::String(s) => {
                Ok(format!("<{}>{}</{}>", root_name, s, root_name))
            }
            serde_json::Value::Number(n) => {
                Ok(format!("<{}>{}</{}>", root_name, n, root_name))
            }
            serde_json::Value::Bool(b) => {
                Ok(format!("<{}>{}</{}>", root_name, b, root_name))
            }
            serde_json::Value::Null => {
                Ok(format!("<{}/>", root_name))
            }
        }
    }
}

/// XML到JSON转换器
pub struct XmlToJsonConverter;

impl FormatConverter for XmlToJsonConverter {
    fn convert(&self, data: &[u8], _source_format: DataFormat, _target_format: DataFormat) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let xml_string = String::from_utf8(data.to_vec())?;
        let json_value = self.xml_to_json(&xml_string)?;
        let json_bytes = serde_json::to_vec(&json_value)?;
        Ok(json_bytes)
    }
}

impl XmlToJsonConverter {
    fn xml_to_json(&self, xml: &str) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        // 简化的XML到JSON转换
        // 实际实现应该使用XML解析库
        let mut json = serde_json::Map::new();
        json.insert("content".to_string(), serde_json::Value::String(xml.to_string()));
        Ok(serde_json::Value::Object(json))
    }
}

/// JSON到CSV转换器
pub struct JsonToCsvConverter;

impl FormatConverter for JsonToCsvConverter {
    fn convert(&self, data: &[u8], _source_format: DataFormat, _target_format: DataFormat) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let json_value: serde_json::Value = serde_json::from_slice(data)?;
        let csv_string = self.json_to_csv(&json_value)?;
        Ok(csv_string.into_bytes())
    }
}

impl JsonToCsvConverter {
    fn json_to_csv(&self, value: &serde_json::Value) -> Result<String, Box<dyn std::error::Error>> {
        match value {
            serde_json::Value::Array(arr) => {
                if arr.is_empty() {
                    return Ok(String::new());
                }
                
                let mut csv = String::new();
                
                // 提取列名
                if let Some(first_item) = arr.first() {
                    if let serde_json::Value::Object(map) = first_item {
                        let headers: Vec<String> = map.keys().cloned().collect();
                        csv.push_str(&headers.join(","));
                        csv.push('\n');
                        
                        // 添加数据行
                        for item in arr {
                            if let serde_json::Value::Object(map) = item {
                                let row: Vec<String> = headers.iter()
                                    .map(|header| map.get(header)
                                        .map(|v| v.to_string().trim_matches('"').to_string())
                                        .unwrap_or_default())
                                    .collect();
                                csv.push_str(&row.join(","));
                                csv.push('\n');
                            }
                        }
                    }
                }
                
                Ok(csv)
            }
            _ => Err("JSON value must be an array of objects".into()),
        }
    }
}

/// CSV到JSON转换器
pub struct CsvToJsonConverter;

impl FormatConverter for CsvToJsonConverter {
    fn convert(&self, data: &[u8], _source_format: DataFormat, _target_format: DataFormat) -> Result<Vec<u8>, Box<dyn std::error::Error>> {
        let csv_string = String::from_utf8(data.to_vec())?;
        let json_value = self.csv_to_json(&csv_string)?;
        let json_bytes = serde_json::to_vec(&json_value)?;
        Ok(json_bytes)
    }
}

impl CsvToJsonConverter {
    fn csv_to_json(&self, csv: &str) -> Result<serde_json::Value, Box<dyn std::error::Error>> {
        let lines: Vec<&str> = csv.lines().collect();
        if lines.is_empty() {
            return Ok(serde_json::Value::Array(vec![]));
        }
        
        let headers: Vec<String> = lines[0].split(',').map(|s| s.to_string()).collect();
        let mut json_array = Vec::new();
        
        for line in lines.iter().skip(1) {
            let values: Vec<&str> = line.split(',').collect();
            let mut json_object = serde_json::Map::new();
            
            for (i, header) in headers.iter().enumerate() {
                let value = values.get(i).unwrap_or(&"");
                json_object.insert(header.clone(), serde_json::Value::String(value.to_string()));
            }
            
            json_array.push(serde_json::Value::Object(json_object));
        }
        
        Ok(serde_json::Value::Array(json_array))
    }
}
```

## 3. 应用示例

### 3.1 IoT设备语义映射

```rust
use crate::semantic::{OntologyMapper, OntologyConcept, DataConverter, DataFormat};

fn semantic_mapping_example() -> Result<(), Box<dyn std::error::Error>> {
    // 创建本体映射器
    let mut mapper = OntologyMapper::new(0.7);
    
    // 添加OPC UA概念
    let opcua_temperature = OntologyConcept {
        id: "opcua:temperature".to_string(),
        label: "Temperature".to_string(),
        description: Some("Temperature measurement".to_string()),
        synonyms: vec!["temp".to_string(), "thermal".to_string()],
        properties: {
            let mut props = HashMap::new();
            props.insert("unit".to_string(), "Celsius".to_string());
            props.insert("range".to_string(), "-40 to 85".to_string());
            props
        },
        parent_concepts: vec!["opcua:sensor".to_string()],
        child_concepts: vec![],
    };
    
    let opcua_humidity = OntologyConcept {
        id: "opcua:humidity".to_string(),
        label: "Humidity".to_string(),
        description: Some("Humidity measurement".to_string()),
        synonyms: vec!["moisture".to_string(), "relative_humidity".to_string()],
        properties: {
            let mut props = HashMap::new();
            props.insert("unit".to_string(), "Percent".to_string());
            props.insert("range".to_string(), "0 to 100".to_string());
            props
        },
        parent_concepts: vec!["opcua:sensor".to_string()],
        child_concepts: vec![],
    };
    
    // 添加WoT概念
    let wot_temperature = OntologyConcept {
        id: "wot:temperature".to_string(),
        label: "Temperature".to_string(),
        description: Some("Temperature property".to_string()),
        synonyms: vec!["temp".to_string(), "thermal".to_string()],
        properties: {
            let mut props = HashMap::new();
            props.insert("unit".to_string(), "Celsius".to_string());
            props.insert("type".to_string(), "number".to_string());
            props
        },
        parent_concepts: vec!["wot:property".to_string()],
        child_concepts: vec![],
    };
    
    let wot_humidity = OntologyConcept {
        id: "wot:humidity".to_string(),
        label: "Humidity".to_string(),
        description: Some("Humidity property".to_string()),
        synonyms: vec!["moisture".to_string(), "relative_humidity".to_string()],
        properties: {
            let mut props = HashMap::new();
            props.insert("unit".to_string(), "Percent".to_string());
            props.insert("type".to_string(), "number".to_string());
            props
        },
        parent_concepts: vec!["wot:property".to_string()],
        child_concepts: vec![],
    };
    
    // 添加概念到映射器
    mapper.add_concept(opcua_temperature);
    mapper.add_concept(opcua_humidity);
    mapper.add_concept(wot_temperature);
    mapper.add_concept(wot_humidity);
    
    // 执行自动映射
    let mappings = mapper.auto_map_concepts();
    
    println!("发现的概念映射:");
    for mapping in &mappings {
        println!("{} -> {} (相似度: {:.3}, 类型: {:?})", 
            mapping.source_concept, 
            mapping.target_concept, 
            mapping.similarity_score, 
            mapping.mapping_type);
    }
    
    // 数据格式转换示例
    let converter = DataConverter::new();
    
    // JSON数据
    let json_data = r#"[
        {"device_id": "sensor_001", "temperature": 23.5, "humidity": 65.2},
        {"device_id": "sensor_002", "temperature": 24.1, "humidity": 62.8}
    ]"#.as_bytes();
    
    // 转换为XML
    let xml_data = converter.convert(json_data, DataFormat::JSON, DataFormat::XML)?;
    println!("\nJSON转XML:");
    println!("{}", String::from_utf8_lossy(&xml_data));
    
    // 转换为CSV
    let csv_data = converter.convert(json_data, DataFormat::JSON, DataFormat::CSV)?;
    println!("\nJSON转CSV:");
    println!("{}", String::from_utf8_lossy(&csv_data));
    
    Ok(())
}
```

## 4. 总结

本实现提供了：

1. **多种字符串相似度算法** - 编辑距离、Jaro-Winkler、余弦相似度等
2. **本体概念映射** - 自动发现概念间的语义关系
3. **数据格式转换** - JSON、XML、CSV等格式间的转换
4. **可扩展架构** - 易于添加新的相似度算法和转换器
5. **实际应用示例** - IoT设备语义映射场景

这个语义映射引擎为IoT系统提供了强大的语义理解和数据转换能力，实现了不同标准间的语义互操作。
