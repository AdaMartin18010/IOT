# 物联网规则引擎实现

## 概述

物联网规则引擎提供基于条件的自动化决策和执行能力，支持复杂规则链、条件评估、动作执行和规则管理。

## 核心架构

### 1. 规则引擎核心

```rust
// 规则引擎核心结构
pub struct RuleEngine {
    rules: Arc<RwLock<HashMap<String, Rule>>>,
    rule_chains: Arc<RwLock<HashMap<String, RuleChain>>>,
    condition_evaluator: Box<dyn ConditionEvaluator>,
    action_executor: Box<dyn ActionExecutor>,
    event_bus: Arc<EventBus>,
    cache: Arc<RedisCache>,
}

// 规则定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Rule {
    pub id: String,
    pub name: String,
    pub description: String,
    pub enabled: bool,
    pub priority: u32,
    pub conditions: Vec<Condition>,
    pub actions: Vec<Action>,
    pub metadata: HashMap<String, String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

// 规则链定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RuleChain {
    pub id: String,
    pub name: String,
    pub description: String,
    pub rules: Vec<String>, // 规则ID列表
    pub execution_mode: ExecutionMode,
    pub enabled: bool,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExecutionMode {
    Sequential, // 顺序执行
    Parallel,   // 并行执行
    Conditional, // 条件执行
}

// 条件定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Condition {
    pub id: String,
    pub condition_type: ConditionType,
    pub operator: Operator,
    pub left_operand: Operand,
    pub right_operand: Operand,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConditionType {
    Simple,
    Complex,
    TimeBased,
    DeviceBased,
    DataBased,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Operator {
    Equals,
    NotEquals,
    GreaterThan,
    LessThan,
    GreaterThanOrEqual,
    LessThanOrEqual,
    Contains,
    NotContains,
    StartsWith,
    EndsWith,
    In,
    NotIn,
    Between,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Operand {
    Literal(LiteralValue),
    Variable(String),
    Function(FunctionCall),
    Expression(Expression),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LiteralValue {
    String(String),
    Number(f64),
    Boolean(bool),
    Array(Vec<LiteralValue>),
    Null,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCall {
    pub function_name: String,
    pub arguments: Vec<Operand>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Expression {
    pub expression: String,
    pub variables: HashMap<String, String>,
}

// 动作定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Action {
    pub id: String,
    pub action_type: ActionType,
    pub parameters: HashMap<String, ActionParameter>,
    pub retry_config: RetryConfig,
    pub timeout: Duration,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ActionType {
    DeviceControl,
    Notification,
    DataTransformation,
    API,
    Script,
    Custom(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ActionParameter {
    String(String),
    Number(f64),
    Boolean(bool),
    Object(HashMap<String, ActionParameter>),
    Array(Vec<ActionParameter>),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RetryConfig {
    pub max_retries: u32,
    pub retry_delay: Duration,
    pub backoff_multiplier: f64,
}

// 规则执行上下文
#[derive(Debug, Clone)]
pub struct RuleContext {
    pub rule_id: String,
    pub event_data: HashMap<String, serde_json::Value>,
    pub device_data: HashMap<String, DeviceData>,
    pub timestamp: DateTime<Utc>,
    pub variables: HashMap<String, serde_json::Value>,
}

// 规则执行结果
#[derive(Debug, Clone)]
pub struct RuleExecutionResult {
    pub rule_id: String,
    pub executed: bool,
    pub conditions_met: bool,
    pub actions_executed: Vec<String>,
    pub execution_time: Duration,
    pub errors: Vec<String>,
    pub context: RuleContext,
}
```

### 2. 条件评估器

```rust
// 条件评估器接口
pub trait ConditionEvaluator: Send + Sync {
    fn evaluate(&self, condition: &Condition, context: &RuleContext) -> Result<bool, RuleEngineError>;
    fn evaluate_all(&self, conditions: &[Condition], context: &RuleContext) -> Result<bool, RuleEngineError>;
}

// 默认条件评估器
pub struct DefaultConditionEvaluator {
    function_registry: HashMap<String, Box<dyn Function>>,
}

impl ConditionEvaluator for DefaultConditionEvaluator {
    fn evaluate(&self, condition: &Condition, context: &RuleContext) -> Result<bool, RuleEngineError> {
        let left_value = self.evaluate_operand(&condition.left_operand, context)?;
        let right_value = self.evaluate_operand(&condition.right_operand, context)?;
        
        self.compare_values(left_value, right_value, &condition.operator)
    }
    
    fn evaluate_all(&self, conditions: &[Condition], context: &RuleContext) -> Result<bool, RuleEngineError> {
        for condition in conditions {
            if !self.evaluate(condition, context)? {
                return Ok(false);
            }
        }
        Ok(true)
    }
}

impl DefaultConditionEvaluator {
    fn evaluate_operand(&self, operand: &Operand, context: &RuleContext) -> Result<serde_json::Value, RuleEngineError> {
        match operand {
            Operand::Literal(literal) => Ok(self.literal_to_json(literal)),
            Operand::Variable(var_name) => {
                context.variables.get(var_name)
                    .or_else(|| context.event_data.get(var_name))
                    .cloned()
                    .ok_or(RuleEngineError::VariableNotFound(var_name.clone()))
            }
            Operand::Function(func_call) => self.evaluate_function(func_call, context),
            Operand::Expression(expr) => self.evaluate_expression(expr, context),
        }
    }
    
    fn compare_values(&self, left: serde_json::Value, right: serde_json::Value, operator: &Operator) -> Result<bool, RuleEngineError> {
        match operator {
            Operator::Equals => Ok(left == right),
            Operator::NotEquals => Ok(left != right),
            Operator::GreaterThan => {
                let left_num = left.as_f64().ok_or(RuleEngineError::InvalidOperandType)?;
                let right_num = right.as_f64().ok_or(RuleEngineError::InvalidOperandType)?;
                Ok(left_num > right_num)
            }
            Operator::LessThan => {
                let left_num = left.as_f64().ok_or(RuleEngineError::InvalidOperandType)?;
                let right_num = right.as_f64().ok_or(RuleEngineError::InvalidOperandType)?;
                Ok(left_num < right_num)
            }
            Operator::Contains => {
                let left_str = left.as_str().ok_or(RuleEngineError::InvalidOperandType)?;
                let right_str = right.as_str().ok_or(RuleEngineError::InvalidOperandType)?;
                Ok(left_str.contains(right_str))
            }
            Operator::In => {
                let right_array = right.as_array().ok_or(RuleEngineError::InvalidOperandType)?;
                Ok(right_array.contains(&left))
            }
            Operator::Between => {
                let value = left.as_f64().ok_or(RuleEngineError::InvalidOperandType)?;
                let right_array = right.as_array().ok_or(RuleEngineError::InvalidOperandType)?;
                if right_array.len() != 2 {
                    return Err(RuleEngineError::InvalidOperandType);
                }
                let min = right_array[0].as_f64().ok_or(RuleEngineError::InvalidOperandType)?;
                let max = right_array[1].as_f64().ok_or(RuleEngineError::InvalidOperandType)?;
                Ok(value >= min && value <= max)
            }
            _ => Err(RuleEngineError::UnsupportedOperator),
        }
    }
    
    fn evaluate_function(&self, func_call: &FunctionCall, context: &RuleContext) -> Result<serde_json::Value, RuleEngineError> {
        let function = self.function_registry.get(&func_call.function_name)
            .ok_or(RuleEngineError::FunctionNotFound(func_call.function_name.clone()))?;
        
        let args: Result<Vec<serde_json::Value>, _> = func_call.arguments.iter()
            .map(|arg| self.evaluate_operand(arg, context))
            .collect();
        
        function.execute(&args?)
    }
    
    fn literal_to_json(&self, literal: &LiteralValue) -> serde_json::Value {
        match literal {
            LiteralValue::String(s) => json!(s),
            LiteralValue::Number(n) => json!(n),
            LiteralValue::Boolean(b) => json!(b),
            LiteralValue::Array(arr) => {
                let json_array: Vec<serde_json::Value> = arr.iter()
                    .map(|v| self.literal_to_json(v))
                    .collect();
                json!(json_array)
            }
            LiteralValue::Null => json!(null),
        }
    }
}

// 函数接口
pub trait Function: Send + Sync {
    fn execute(&self, arguments: &[serde_json::Value]) -> Result<serde_json::Value, RuleEngineError>;
    fn get_name(&self) -> &str;
}

// 内置函数实现
pub struct MathFunction {
    name: String,
    operation: MathOperation,
}

#[derive(Debug, Clone)]
pub enum MathOperation {
    Add,
    Subtract,
    Multiply,
    Divide,
    Modulo,
    Power,
    Abs,
    Round,
    Floor,
    Ceil,
}

impl Function for MathFunction {
    fn execute(&self, arguments: &[serde_json::Value]) -> Result<serde_json::Value, RuleEngineError> {
        match self.operation {
            MathOperation::Add => {
                let sum: f64 = arguments.iter()
                    .filter_map(|arg| arg.as_f64())
                    .sum();
                Ok(json!(sum))
            }
            MathOperation::Multiply => {
                let product: f64 = arguments.iter()
                    .filter_map(|arg| arg.as_f64())
                    .product();
                Ok(json!(product))
            }
            MathOperation::Abs => {
                let value = arguments.get(0)
                    .and_then(|arg| arg.as_f64())
                    .ok_or(RuleEngineError::InvalidArguments)?;
                Ok(json!(value.abs()))
            }
            _ => Err(RuleEngineError::UnsupportedFunction),
        }
    }
    
    fn get_name(&self) -> &str {
        &self.name
    }
}
```

### 3. 动作执行器

```rust
// 动作执行器接口
pub trait ActionExecutor: Send + Sync {
    fn execute(&self, action: &Action, context: &RuleContext) -> Result<ActionExecutionResult, RuleEngineError>;
    fn execute_all(&self, actions: &[Action], context: &RuleContext) -> Result<Vec<ActionExecutionResult>, RuleEngineError>;
}

// 默认动作执行器
pub struct DefaultActionExecutor {
    device_controller: Arc<DeviceController>,
    notification_service: Arc<NotificationService>,
    api_client: Arc<ApiClient>,
    script_engine: Arc<ScriptEngine>,
}

impl ActionExecutor for DefaultActionExecutor {
    fn execute(&self, action: &Action, context: &RuleContext) -> Result<ActionExecutionResult, RuleEngineError> {
        let start_time = Instant::now();
        
        let result = match &action.action_type {
            ActionType::DeviceControl => self.execute_device_control(action, context),
            ActionType::Notification => self.execute_notification(action, context),
            ActionType::API => self.execute_api_call(action, context),
            ActionType::Script => self.execute_script(action, context),
            _ => Err(RuleEngineError::UnsupportedActionType),
        };
        
        let execution_time = start_time.elapsed();
        
        Ok(ActionExecutionResult {
            action_id: action.id.clone(),
            success: result.is_ok(),
            result: result.ok(),
            error: result.err().map(|e| e.to_string()),
            execution_time,
            retry_count: 0,
        })
    }
    
    fn execute_all(&self, actions: &[Action], context: &RuleContext) -> Result<Vec<ActionExecutionResult>, RuleEngineError> {
        let mut results = Vec::new();
        
        for action in actions {
            let result = self.execute(action, context)?;
            results.push(result);
        }
        
        Ok(results)
    }
}

impl DefaultActionExecutor {
    async fn execute_device_control(&self, action: &Action, context: &RuleContext) -> Result<serde_json::Value, RuleEngineError> {
        let device_id = action.parameters.get("device_id")
            .and_then(|p| p.as_string())
            .ok_or(RuleEngineError::MissingParameter("device_id".to_string()))?;
        
        let command = action.parameters.get("command")
            .and_then(|p| p.as_string())
            .ok_or(RuleEngineError::MissingParameter("command".to_string()))?;
        
        let parameters = action.parameters.get("parameters")
            .and_then(|p| p.as_object())
            .cloned()
            .unwrap_or_default();
        
        let result = self.device_controller.send_command(device_id, command, parameters).await?;
        Ok(json!(result))
    }
    
    async fn execute_notification(&self, action: &Action, context: &RuleContext) -> Result<serde_json::Value, RuleEngineError> {
        let message = action.parameters.get("message")
            .and_then(|p| p.as_string())
            .ok_or(RuleEngineError::MissingParameter("message".to_string()))?;
        
        let recipients = action.parameters.get("recipients")
            .and_then(|p| p.as_array())
            .ok_or(RuleEngineError::MissingParameter("recipients".to_string()))?;
        
        let notification_type = action.parameters.get("type")
            .and_then(|p| p.as_string())
            .unwrap_or("email");
        
        let result = self.notification_service.send_notification(
            message,
            recipients,
            notification_type,
        ).await?;
        
        Ok(json!(result))
    }
    
    async fn execute_api_call(&self, action: &Action, context: &RuleContext) -> Result<serde_json::Value, RuleEngineError> {
        let url = action.parameters.get("url")
            .and_then(|p| p.as_string())
            .ok_or(RuleEngineError::MissingParameter("url".to_string()))?;
        
        let method = action.parameters.get("method")
            .and_then(|p| p.as_string())
            .unwrap_or("GET");
        
        let headers = action.parameters.get("headers")
            .and_then(|p| p.as_object())
            .cloned()
            .unwrap_or_default();
        
        let body = action.parameters.get("body")
            .cloned();
        
        let result = self.api_client.request(url, method, headers, body).await?;
        Ok(json!(result))
    }
    
    async fn execute_script(&self, action: &Action, context: &RuleContext) -> Result<serde_json::Value, RuleEngineError> {
        let script = action.parameters.get("script")
            .and_then(|p| p.as_string())
            .ok_or(RuleEngineError::MissingParameter("script".to_string()))?;
        
        let variables = context.variables.clone();
        
        let result = self.script_engine.execute(script, variables).await?;
        Ok(json!(result))
    }
}

#[derive(Debug, Clone)]
pub struct ActionExecutionResult {
    pub action_id: String,
    pub success: bool,
    pub result: Option<serde_json::Value>,
    pub error: Option<String>,
    pub execution_time: Duration,
    pub retry_count: u32,
}
```

### 4. 规则引擎实现

```rust
impl RuleEngine {
    pub fn new() -> Self {
        Self {
            rules: Arc::new(RwLock::new(HashMap::new())),
            rule_chains: Arc::new(RwLock::new(HashMap::new())),
            condition_evaluator: Box::new(DefaultConditionEvaluator::new()),
            action_executor: Box::new(DefaultActionExecutor::new()),
            event_bus: Arc::new(EventBus::new()),
            cache: Arc::new(RedisCache::new()),
        }
    }

    // 添加规则
    pub async fn add_rule(&self, rule: Rule) -> Result<(), RuleEngineError> {
        let mut rules = self.rules.write().await;
        rules.insert(rule.id.clone(), rule);
        Ok(())
    }

    // 执行规则
    pub async fn execute_rule(&self, rule_id: &str, context: RuleContext) -> Result<RuleExecutionResult, RuleEngineError> {
        let rules = self.rules.read().await;
        let rule = rules.get(rule_id)
            .ok_or(RuleEngineError::RuleNotFound(rule_id.to_string()))?;
        
        if !rule.enabled {
            return Ok(RuleExecutionResult {
                rule_id: rule_id.to_string(),
                executed: false,
                conditions_met: false,
                actions_executed: Vec::new(),
                execution_time: Duration::from_millis(0),
                errors: vec!["Rule is disabled".to_string()],
                context,
            });
        }
        
        let start_time = Instant::now();
        
        // 评估条件
        let conditions_met = self.condition_evaluator.evaluate_all(&rule.conditions, &context)?;
        
        let mut actions_executed = Vec::new();
        let mut errors = Vec::new();
        
        if conditions_met {
            // 执行动作
            for action in &rule.actions {
                match self.action_executor.execute(action, &context).await {
                    Ok(result) => {
                        if result.success {
                            actions_executed.push(action.id.clone());
                        } else {
                            errors.push(format!("Action {} failed: {:?}", action.id, result.error));
                        }
                    }
                    Err(e) => {
                        errors.push(format!("Action {} error: {}", action.id, e));
                    }
                }
            }
        }
        
        let execution_time = start_time.elapsed();
        
        Ok(RuleExecutionResult {
            rule_id: rule_id.to_string(),
            executed: true,
            conditions_met,
            actions_executed,
            execution_time,
            errors,
            context,
        })
    }

    // 执行规则链
    pub async fn execute_rule_chain(&self, chain_id: &str, context: RuleContext) -> Result<Vec<RuleExecutionResult>, RuleEngineError> {
        let chains = self.rule_chains.read().await;
        let chain = chains.get(chain_id)
            .ok_or(RuleEngineError::RuleChainNotFound(chain_id.to_string()))?;
        
        if !chain.enabled {
            return Err(RuleEngineError::RuleChainDisabled(chain_id.to_string()));
        }
        
        let mut results = Vec::new();
        
        match chain.execution_mode {
            ExecutionMode::Sequential => {
                for rule_id in &chain.rules {
                    let result = self.execute_rule(rule_id, context.clone()).await?;
                    results.push(result);
                }
            }
            ExecutionMode::Parallel => {
                let mut tasks = Vec::new();
                for rule_id in &chain.rules {
                    let rule_id = rule_id.clone();
                    let context = context.clone();
                    let engine = self.clone();
                    tasks.push(tokio::spawn(async move {
                        engine.execute_rule(&rule_id, context).await
                    }));
                }
                
                for task in tasks {
                    match task.await {
                        Ok(Ok(result)) => results.push(result),
                        Ok(Err(e)) => return Err(e),
                        Err(e) => return Err(RuleEngineError::TaskExecutionError(e.to_string())),
                    }
                }
            }
            ExecutionMode::Conditional => {
                for rule_id in &chain.rules {
                    let result = self.execute_rule(rule_id, context.clone()).await?;
                    results.push(result.clone());
                    
                    // 如果规则执行失败，停止执行
                    if !result.conditions_met || !result.errors.is_empty() {
                        break;
                    }
                }
            }
        }
        
        Ok(results)
    }

    // 处理事件
    pub async fn handle_event(&self, event: &Event) -> Result<Vec<RuleExecutionResult>, RuleEngineError> {
        let rules = self.rules.read().await;
        let mut results = Vec::new();
        
        // 找到匹配的规则
        for rule in rules.values() {
            if !rule.enabled {
                continue;
            }
            
            // 创建执行上下文
            let context = RuleContext {
                rule_id: rule.id.clone(),
                event_data: event.data.clone(),
                device_data: HashMap::new(), // 从事件中提取设备数据
                timestamp: event.timestamp,
                variables: HashMap::new(),
            };
            
            // 执行规则
            let result = self.execute_rule(&rule.id, context).await?;
            if result.executed {
                results.push(result);
            }
        }
        
        Ok(results)
    }
}
```

### 5. 规则引擎API

```rust
#[derive(Deserialize)]
pub struct CreateRuleRequest {
    pub name: String,
    pub description: String,
    pub conditions: Vec<CreateConditionRequest>,
    pub actions: Vec<CreateActionRequest>,
    pub priority: u32,
}

#[derive(Deserialize)]
pub struct CreateConditionRequest {
    pub condition_type: ConditionType,
    pub operator: Operator,
    pub left_operand: Operand,
    pub right_operand: Operand,
}

#[derive(Deserialize)]
pub struct CreateActionRequest {
    pub action_type: ActionType,
    pub parameters: HashMap<String, ActionParameter>,
    pub retry_config: Option<RetryConfig>,
    pub timeout: Option<Duration>,
}

#[derive(Serialize)]
pub struct RuleResponse {
    pub rule: Rule,
    pub execution_stats: RuleExecutionStats,
}

#[derive(Serialize)]
pub struct RuleExecutionStats {
    pub total_executions: u64,
    pub successful_executions: u64,
    pub failed_executions: u64,
    pub average_execution_time: Duration,
    pub last_execution: Option<DateTime<Utc>>,
}

// 规则引擎API路由
pub fn rule_engine_routes() -> Router {
    Router::new()
        .route("/rules", post(create_rule))
        .route("/rules", get(list_rules))
        .route("/rules/:id", get(get_rule))
        .route("/rules/:id", put(update_rule))
        .route("/rules/:id", delete(delete_rule))
        .route("/rules/:id/execute", post(execute_rule))
        .route("/rule-chains", post(create_rule_chain))
        .route("/rule-chains/:id/execute", post(execute_rule_chain))
        .route("/events", post(handle_event))
}

async fn create_rule(
    Json(request): Json<CreateRuleRequest>,
    State(rule_engine): State<Arc<RuleEngine>>,
) -> Result<Json<RuleResponse>, StatusCode> {
    let conditions: Result<Vec<Condition>, _> = request.conditions.into_iter()
        .enumerate()
        .map(|(i, c)| Ok(Condition {
            id: format!("condition-{}", i),
            condition_type: c.condition_type,
            operator: c.operator,
            left_operand: c.left_operand,
            right_operand: c.right_operand,
            metadata: HashMap::new(),
        }))
        .collect();
    
    let actions: Result<Vec<Action>, _> = request.actions.into_iter()
        .enumerate()
        .map(|(i, a)| Ok(Action {
            id: format!("action-{}", i),
            action_type: a.action_type,
            parameters: a.parameters,
            retry_config: a.retry_config.unwrap_or(RetryConfig {
                max_retries: 3,
                retry_delay: Duration::from_secs(1),
                backoff_multiplier: 2.0,
            }),
            timeout: a.timeout.unwrap_or(Duration::from_secs(30)),
            metadata: HashMap::new(),
        }))
        .collect();
    
    let rule = Rule {
        id: Uuid::new_v4().to_string(),
        name: request.name,
        description: request.description,
        enabled: true,
        priority: request.priority,
        conditions: conditions.map_err(|_| StatusCode::BAD_REQUEST)?,
        actions: actions.map_err(|_| StatusCode::BAD_REQUEST)?,
        metadata: HashMap::new(),
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };

    rule_engine.add_rule(rule.clone()).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;

    Ok(Json(RuleResponse {
        rule,
        execution_stats: RuleExecutionStats {
            total_executions: 0,
            successful_executions: 0,
            failed_executions: 0,
            average_execution_time: Duration::from_millis(0),
            last_execution: None,
        },
    }))
}

async fn execute_rule(
    Path(rule_id): Path<String>,
    Json(event_data): Json<HashMap<String, serde_json::Value>>,
    State(rule_engine): State<Arc<RuleEngine>>,
) -> Result<Json<RuleExecutionResult>, StatusCode> {
    let context = RuleContext {
        rule_id: rule_id.clone(),
        event_data,
        device_data: HashMap::new(),
        timestamp: Utc::now(),
        variables: HashMap::new(),
    };
    
    let result = rule_engine.execute_rule(&rule_id, context).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(result))
}
```

## 使用示例

### 1. 创建温度监控规则

```rust
#[tokio::main]
async fn main() {
    let rule_engine = Arc::new(RuleEngine::new());
    
    // 创建温度过高告警规则
    let temperature_rule = Rule {
        id: "temp-alert-rule".to_string(),
        name: "温度过高告警".to_string(),
        description: "当温度超过30度时发送告警".to_string(),
        enabled: true,
        priority: 1,
        conditions: vec![
            Condition {
                id: "temp-condition".to_string(),
                condition_type: ConditionType::DataBased,
                operator: Operator::GreaterThan,
                left_operand: Operand::Variable("temperature".to_string()),
                right_operand: Operand::Literal(LiteralValue::Number(30.0)),
                metadata: HashMap::new(),
            }
        ],
        actions: vec![
            Action {
                id: "send-alert".to_string(),
                action_type: ActionType::Notification,
                parameters: HashMap::from([
                    ("message".to_string(), ActionParameter::String("温度过高告警: 当前温度 {temperature}°C".to_string())),
                    ("recipients".to_string(), ActionParameter::Array(vec![
                        ActionParameter::String("admin@example.com".to_string()),
                    ])),
                    ("type".to_string(), ActionParameter::String("email".to_string())),
                ]),
                retry_config: RetryConfig {
                    max_retries: 3,
                    retry_delay: Duration::from_secs(5),
                    backoff_multiplier: 2.0,
                },
                timeout: Duration::from_secs(30),
                metadata: HashMap::new(),
            },
            Action {
                id: "turn-on-fan".to_string(),
                action_type: ActionType::DeviceControl,
                parameters: HashMap::from([
                    ("device_id".to_string(), ActionParameter::String("fan-001".to_string())),
                    ("command".to_string(), ActionParameter::String("turn_on".to_string())),
                    ("parameters".to_string(), ActionParameter::Object(HashMap::from([
                        ("speed".to_string(), ActionParameter::Number(80.0)),
                    ]))),
                ]),
                retry_config: RetryConfig {
                    max_retries: 2,
                    retry_delay: Duration::from_secs(2),
                    backoff_multiplier: 1.5,
                },
                timeout: Duration::from_secs(10),
                metadata: HashMap::new(),
            }
        ],
        metadata: HashMap::new(),
        created_at: Utc::now(),
        updated_at: Utc::now(),
    };
    
    rule_engine.add_rule(temperature_rule).await.unwrap();
    println!("温度监控规则创建成功");
}
```

### 2. 执行规则

```rust
// 执行规则
async fn execute_temperature_rule(rule_engine: Arc<RuleEngine>) {
    let event_data = HashMap::from([
        ("temperature".to_string(), json!(35.5)),
        ("humidity".to_string(), json!(65.0)),
        ("device_id".to_string(), json!("sensor-001")),
    ]);
    
    let context = RuleContext {
        rule_id: "temp-alert-rule".to_string(),
        event_data,
        device_data: HashMap::new(),
        timestamp: Utc::now(),
        variables: HashMap::new(),
    };
    
    let result = rule_engine.execute_rule("temp-alert-rule", context).await.unwrap();
    
    println!("规则执行结果:");
    println!("执行成功: {}", result.executed);
    println!("条件满足: {}", result.conditions_met);
    println!("执行动作: {:?}", result.actions_executed);
    println!("执行时间: {:?}", result.execution_time);
    if !result.errors.is_empty() {
        println!("错误: {:?}", result.errors);
    }
}
```

### 3. 创建规则链

```rust
// 创建规则链
async fn create_rule_chain(rule_engine: Arc<RuleEngine>) {
    let rule_chain = RuleChain {
        id: "environment-monitoring".to_string(),
        name: "环境监控规则链".to_string(),
        description: "监控环境参数并执行相应动作".to_string(),
        rules: vec![
            "temp-alert-rule".to_string(),
            "humidity-alert-rule".to_string(),
            "air-quality-rule".to_string(),
        ],
        execution_mode: ExecutionMode::Sequential,
        enabled: true,
        metadata: HashMap::new(),
    };
    
    let mut chains = rule_engine.rule_chains.write().await;
    chains.insert(rule_chain.id.clone(), rule_chain);
    
    println!("环境监控规则链创建成功");
}
```

## 核心特性

1. **灵活条件评估**: 支持多种操作符和数据类型
2. **多种动作类型**: 设备控制、通知、API调用、脚本执行
3. **规则链支持**: 顺序、并行、条件执行模式
4. **重试机制**: 可配置的重试策略
5. **事件驱动**: 基于事件的规则触发
6. **函数支持**: 内置和自定义函数
7. **变量系统**: 动态变量绑定
8. **API接口**: RESTful API支持
9. **执行统计**: 规则执行性能监控
10. **错误处理**: 完善的错误处理和日志记录

这个物联网规则引擎实现提供了强大的自动化决策和执行能力，支持复杂的业务逻辑和设备控制。
