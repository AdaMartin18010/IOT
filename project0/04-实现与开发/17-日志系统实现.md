# 日志系统实现

## 概述

日志系统是IoT系统的重要组成部分，提供结构化日志记录、多级别日志、异步写入、日志轮转等功能。本文档提供基于Rust和Go的日志系统实现。

## 核心架构

### 1. 日志级别和结构定义

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use chrono::{DateTime, Utc};

/// 日志级别枚举
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum LogLevel {
    Trace = 0,
    Debug = 1,
    Info = 2,
    Warn = 3,
    Error = 4,
    Fatal = 5,
}

impl LogLevel {
    pub fn from_str(s: &str) -> Option<Self> {
        match s.to_lowercase().as_str() {
            "trace" => Some(LogLevel::Trace),
            "debug" => Some(LogLevel::Debug),
            "info" => Some(LogLevel::Info),
            "warn" | "warning" => Some(LogLevel::Warn),
            "error" => Some(LogLevel::Error),
            "fatal" => Some(LogLevel::Fatal),
            _ => None,
        }
    }

    pub fn to_string(&self) -> &'static str {
        match self {
            LogLevel::Trace => "TRACE",
            LogLevel::Debug => "DEBUG",
            LogLevel::Info => "INFO",
            LogLevel::Warn => "WARN",
            LogLevel::Error => "ERROR",
            LogLevel::Fatal => "FATAL",
        }
    }
}

/// 日志记录结构
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogRecord {
    pub timestamp: DateTime<Utc>,
    pub level: LogLevel,
    pub target: String,
    pub message: String,
    pub fields: HashMap<String, serde_json::Value>,
    pub file: Option<String>,
    pub line: Option<u32>,
    pub thread_id: Option<u64>,
}

/// 日志配置
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogConfig {
    pub level: LogLevel,
    pub format: LogFormat,
    pub outputs: Vec<LogOutput>,
    pub max_file_size: u64,
    pub max_files: u32,
    pub buffer_size: usize,
}

/// 日志格式
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogFormat {
    Json,
    Text,
    Custom(String),
}

/// 日志输出目标
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum LogOutput {
    Console,
    File(String),
    Network(String),
    Database(String),
}
```

### 2. 日志记录器

```rust
use tokio::sync::mpsc;
use std::sync::Arc;
use tokio::sync::RwLock;
use std::fs::OpenOptions;
use std::io::Write;

/// 日志记录器
pub struct Logger {
    config: Arc<RwLock<LogConfig>>,
    sender: mpsc::Sender<LogRecord>,
    handlers: Vec<Box<dyn LogHandler>>,
    buffer: Vec<LogRecord>,
    buffer_size: usize,
}

impl Logger {
    pub fn new(config: LogConfig) -> Self {
        let (sender, receiver) = mpsc::channel(1000);
        let config = Arc::new(RwLock::new(config));
        
        let mut logger = Self {
            config: Arc::clone(&config),
            sender,
            handlers: Vec::new(),
            buffer: Vec::new(),
            buffer_size: config.buffer_size,
        };

        // 初始化处理器
        logger.init_handlers().await;
        
        // 启动异步处理
        let config = Arc::clone(&config);
        tokio::spawn(async move {
            logger.process_logs(receiver, config).await;
        });

        logger
    }

    /// 初始化日志处理器
    async fn init_handlers(&mut self) {
        let config = self.config.read().await;
        
        for output in &config.outputs {
            match output {
                LogOutput::Console => {
                    self.handlers.push(Box::new(ConsoleHandler::new()));
                }
                LogOutput::File(path) => {
                    if let Ok(handler) = FileHandler::new(path.clone()).await {
                        self.handlers.push(Box::new(handler));
                    }
                }
                LogOutput::Network(url) => {
                    if let Ok(handler) = NetworkHandler::new(url.clone()).await {
                        self.handlers.push(Box::new(handler));
                    }
                }
                LogOutput::Database(conn_str) => {
                    if let Ok(handler) = DatabaseHandler::new(conn_str.clone()).await {
                        self.handlers.push(Box::new(handler));
                    }
                }
            }
        }
    }

    /// 记录日志
    pub async fn log(&self, level: LogLevel, target: &str, message: &str, fields: HashMap<String, serde_json::Value>) {
        let config = self.config.read().await;
        
        // 检查日志级别
        if level < config.level {
            return;
        }

        let record = LogRecord {
            timestamp: Utc::now(),
            level,
            target: target.to_string(),
            message: message.to_string(),
            fields,
            file: None, // 可以通过宏获取
            line: None,  // 可以通过宏获取
            thread_id: Some(std::thread::current().id().as_u64().get()),
        };

        if let Err(e) = self.sender.send(record).await {
            eprintln!("发送日志记录失败: {}", e);
        }
    }

    /// 异步处理日志
    async fn process_logs(&self, mut receiver: mpsc::Receiver<LogRecord>, config: Arc<RwLock<LogConfig>>) {
        while let Some(record) = receiver.recv().await {
            let config = config.read().await;
            
            // 格式化日志
            let formatted = self.format_log(&record, &config.format);
            
            // 发送到所有处理器
            for handler in &self.handlers {
                if let Err(e) = handler.write(&formatted).await {
                    eprintln!("写入日志失败: {}", e);
                }
            }
        }
    }

    /// 格式化日志
    fn format_log(&self, record: &LogRecord, format: &LogFormat) -> String {
        match format {
            LogFormat::Json => {
                serde_json::to_string(record).unwrap_or_else(|_| "{}".to_string())
            }
            LogFormat::Text => {
                format!(
                    "[{}] {} {}: {}",
                    record.timestamp.format("%Y-%m-%d %H:%M:%S%.3f"),
                    record.level.to_string(),
                    record.target,
                    record.message
                )
            }
            LogFormat::Custom(_) => {
                // 自定义格式实现
                format!(
                    "[{}] {} {}: {}",
                    record.timestamp.format("%Y-%m-%d %H:%M:%S%.3f"),
                    record.level.to_string(),
                    record.target,
                    record.message
                )
            }
        }
    }

    /// 便捷方法
    pub async fn trace(&self, target: &str, message: &str) {
        self.log(LogLevel::Trace, target, message, HashMap::new()).await;
    }

    pub async fn debug(&self, target: &str, message: &str) {
        self.log(LogLevel::Debug, target, message, HashMap::new()).await;
    }

    pub async fn info(&self, target: &str, message: &str) {
        self.log(LogLevel::Info, target, message, HashMap::new()).await;
    }

    pub async fn warn(&self, target: &str, message: &str) {
        self.log(LogLevel::Warn, target, message, HashMap::new()).await;
    }

    pub async fn error(&self, target: &str, message: &str) {
        self.log(LogLevel::Error, target, message, HashMap::new()).await;
    }

    pub async fn fatal(&self, target: &str, message: &str) {
        self.log(LogLevel::Fatal, target, message, HashMap::new()).await;
    }
}
```

### 3. 日志处理器接口

```rust
use async_trait::async_trait;

/// 日志处理器接口
#[async_trait]
pub trait LogHandler: Send + Sync {
    async fn write(&self, message: &str) -> Result<(), Box<dyn std::error::Error>>;
    fn get_name(&self) -> &str;
}

/// 控制台处理器
pub struct ConsoleHandler;

impl ConsoleHandler {
    pub fn new() -> Self {
        Self
    }
}

#[async_trait]
impl LogHandler for ConsoleHandler {
    async fn write(&self, message: &str) -> Result<(), Box<dyn std::error::Error>> {
        println!("{}", message);
        Ok(())
    }

    fn get_name(&self) -> &str {
        "console"
    }
}

/// 文件处理器
pub struct FileHandler {
    path: String,
    file: Arc<RwLock<std::fs::File>>,
    max_size: u64,
    max_files: u32,
    current_size: Arc<RwLock<u64>>,
}

impl FileHandler {
    pub async fn new(path: String) -> Result<Self, Box<dyn std::error::Error>> {
        let file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&path)?;
        
        let metadata = file.metadata()?;
        let current_size = metadata.len();

        Ok(Self {
            path,
            file: Arc::new(RwLock::new(file)),
            max_size: 10 * 1024 * 1024, // 10MB
            max_files: 5,
            current_size: Arc::new(RwLock::new(current_size)),
        })
    }

    async fn rotate_if_needed(&self) -> Result<(), Box<dyn std::error::Error>> {
        let mut current_size = self.current_size.write().await;
        
        if *current_size >= self.max_size {
            self.rotate_files().await?;
            *current_size = 0;
        }
        
        Ok(())
    }

    async fn rotate_files(&self) -> Result<(), Box<dyn std::error::Error>> {
        // 简单的文件轮转实现
        for i in (1..self.max_files).rev() {
            let old_path = format!("{}.{}", self.path, i - 1);
            let new_path = format!("{}.{}", self.path, i);
            
            if std::path::Path::new(&old_path).exists() {
                std::fs::rename(&old_path, &new_path)?;
            }
        }
        
        // 重命名当前文件
        let backup_path = format!("{}.1", self.path);
        std::fs::rename(&self.path, &backup_path)?;
        
        // 创建新文件
        let new_file = OpenOptions::new()
            .create(true)
            .append(true)
            .open(&self.path)?;
        
        {
            let mut file = self.file.write().await;
            *file = new_file;
        }
        
        Ok(())
    }
}

#[async_trait]
impl LogHandler for FileHandler {
    async fn write(&self, message: &str) -> Result<(), Box<dyn std::error::Error>> {
        // 检查是否需要轮转
        self.rotate_if_needed().await?;
        
        let mut file = self.file.write().await;
        writeln!(file, "{}", message)?;
        file.flush()?;
        
        // 更新文件大小
        let mut current_size = self.current_size.write().await;
        *current_size += message.len() as u64 + 1; // +1 for newline
        
        Ok(())
    }

    fn get_name(&self) -> &str {
        "file"
    }
}

/// 网络处理器
pub struct NetworkHandler {
    url: String,
    client: reqwest::Client,
}

impl NetworkHandler {
    pub async fn new(url: String) -> Result<Self, Box<dyn std::error::Error>> {
        let client = reqwest::Client::new();
        
        Ok(Self {
            url,
            client,
        })
    }
}

#[async_trait]
impl LogHandler for NetworkHandler {
    async fn write(&self, message: &str) -> Result<(), Box<dyn std::error::Error>> {
        let response = self.client
            .post(&self.url)
            .json(&serde_json::json!({
                "message": message,
                "timestamp": Utc::now().to_rfc3339(),
            }))
            .send()
            .await?;
        
        if !response.status().is_success() {
            return Err(format!("HTTP错误: {}", response.status()).into());
        }
        
        Ok(())
    }

    fn get_name(&self) -> &str {
        "network"
    }
}

/// 数据库处理器
pub struct DatabaseHandler {
    connection_string: String,
}

impl DatabaseHandler {
    pub async fn new(conn_str: String) -> Result<Self, Box<dyn std::error::Error>> {
        Ok(Self {
            connection_string: conn_str,
        })
    }
}

#[async_trait]
impl LogHandler for DatabaseHandler {
    async fn write(&self, message: &str) -> Result<(), Box<dyn std::error::Error>> {
        // 实现数据库写入逻辑
        // 这里可以连接到数据库并插入日志记录
        Ok(())
    }

    fn get_name(&self) -> &str {
        "database"
    }
}
```

## Go实现

### 1. 日志级别和结构定义2

```go
package logger

import (
    "encoding/json"
    "fmt"
    "strings"
    "time"
)

// LogLevel 日志级别
type LogLevel int

const (
    LogLevelTrace LogLevel = iota
    LogLevelDebug
    LogLevelInfo
    LogLevelWarn
    LogLevelError
    LogLevelFatal
)

func (l LogLevel) String() string {
    switch l {
    case LogLevelTrace:
        return "TRACE"
    case LogLevelDebug:
        return "DEBUG"
    case LogLevelInfo:
        return "INFO"
    case LogLevelWarn:
        return "WARN"
    case LogLevelError:
        return "ERROR"
    case LogLevelFatal:
        return "FATAL"
    default:
        return "UNKNOWN"
    }
}

func LogLevelFromString(s string) (LogLevel, error) {
    switch strings.ToLower(s) {
    case "trace":
        return LogLevelTrace, nil
    case "debug":
        return LogLevelDebug, nil
    case "info":
        return LogLevelInfo, nil
    case "warn", "warning":
        return LogLevelWarn, nil
    case "error":
        return LogLevelError, nil
    case "fatal":
        return LogLevelFatal, nil
    default:
        return LogLevelInfo, fmt.Errorf("unknown log level: %s", s)
    }
}

// LogRecord 日志记录
type LogRecord struct {
    Timestamp time.Time              `json:"timestamp"`
    Level     LogLevel              `json:"level"`
    Target    string                `json:"target"`
    Message   string                `json:"message"`
    Fields    map[string]interface{} `json:"fields"`
    File      string                `json:"file,omitempty"`
    Line      int                   `json:"line,omitempty"`
    ThreadID  uint64                `json:"thread_id,omitempty"`
}

// LogFormat 日志格式
type LogFormat string

const (
    LogFormatJSON LogFormat = "json"
    LogFormatText LogFormat = "text"
)

// LogOutput 日志输出目标
type LogOutput struct {
    Type string `json:"type"`
    Path string `json:"path,omitempty"`
    URL  string `json:"url,omitempty"`
}

// LogConfig 日志配置
type LogConfig struct {
    Level       LogLevel    `json:"level"`
    Format      LogFormat   `json:"format"`
    Outputs     []LogOutput `json:"outputs"`
    MaxFileSize uint64      `json:"max_file_size"`
    MaxFiles    uint32      `json:"max_files"`
    BufferSize  int         `json:"buffer_size"`
}
```

### 2. 日志记录器2

```go
import (
    "sync"
    "context"
)

// Logger 日志记录器
type Logger struct {
    config   *LogConfig
    handlers []LogHandler
    recordCh chan LogRecord
    wg       sync.WaitGroup
    ctx      context.Context
    cancel   context.CancelFunc
}

// NewLogger 创建日志记录器
func NewLogger(config LogConfig) *Logger {
    ctx, cancel := context.WithCancel(context.Background())
    
    logger := &Logger{
        config:   &config,
        handlers: make([]LogHandler, 0),
        recordCh: make(chan LogRecord, config.BufferSize),
        ctx:      ctx,
        cancel:   cancel,
    }
    
    // 初始化处理器
    logger.initHandlers()
    
    // 启动异步处理
    logger.wg.Add(1)
    go logger.processLogs()
    
    return logger
}

// initHandlers 初始化日志处理器
func (l *Logger) initHandlers() {
    for _, output := range l.config.Outputs {
        switch output.Type {
        case "console":
            l.handlers = append(l.handlers, NewConsoleHandler())
        case "file":
            if handler, err := NewFileHandler(output.Path, l.config.MaxFileSize, l.config.MaxFiles); err == nil {
                l.handlers = append(l.handlers, handler)
            }
        case "network":
            if handler, err := NewNetworkHandler(output.URL); err == nil {
                l.handlers = append(l.handlers, handler)
            }
        case "database":
            if handler, err := NewDatabaseHandler(output.Path); err == nil {
                l.handlers = append(l.handlers, handler)
            }
        }
    }
}

// Log 记录日志
func (l *Logger) Log(level LogLevel, target, message string, fields map[string]interface{}) {
    // 检查日志级别
    if level < l.config.Level {
        return
    }
    
    record := LogRecord{
        Timestamp: time.Now(),
        Level:     level,
        Target:    target,
        Message:   message,
        Fields:    fields,
    }
    
    select {
    case l.recordCh <- record:
    default:
        // 通道已满，丢弃日志
    }
}

// processLogs 异步处理日志
func (l *Logger) processLogs() {
    defer l.wg.Done()
    
    for {
        select {
        case record := <-l.recordCh:
            l.writeLog(record)
        case <-l.ctx.Done():
            return
        }
    }
}

// writeLog 写入日志
func (l *Logger) writeLog(record LogRecord) {
    formatted := l.formatLog(record)
    
    for _, handler := range l.handlers {
        if err := handler.Write(formatted); err != nil {
            fmt.Printf("写入日志失败: %v\n", err)
        }
    }
}

// formatLog 格式化日志
func (l *Logger) formatLog(record LogRecord) string {
    switch l.config.Format {
    case LogFormatJSON:
        if data, err := json.Marshal(record); err == nil {
            return string(data)
        }
        return "{}"
    case LogFormatText:
        return fmt.Sprintf(
            "[%s] %s %s: %s",
            record.Timestamp.Format("2006-01-02 15:04:05.000"),
            record.Level.String(),
            record.Target,
            record.Message,
        )
    default:
        return fmt.Sprintf(
            "[%s] %s %s: %s",
            record.Timestamp.Format("2006-01-02 15:04:05.000"),
            record.Level.String(),
            record.Target,
            record.Message,
        )
    }
}

// 便捷方法
func (l *Logger) Trace(target, message string) {
    l.Log(LogLevelTrace, target, message, nil)
}

func (l *Logger) Debug(target, message string) {
    l.Log(LogLevelDebug, target, message, nil)
}

func (l *Logger) Info(target, message string) {
    l.Log(LogLevelInfo, target, message, nil)
}

func (l *Logger) Warn(target, message string) {
    l.Log(LogLevelWarn, target, message, nil)
}

func (l *Logger) Error(target, message string) {
    l.Log(LogLevelError, target, message, nil)
}

func (l *Logger) Fatal(target, message string) {
    l.Log(LogLevelFatal, target, message, nil)
}

// Close 关闭日志记录器
func (l *Logger) Close() {
    l.cancel()
    l.wg.Wait()
    close(l.recordCh)
}
```

### 3. 日志处理器接口2

```go
// LogHandler 日志处理器接口
type LogHandler interface {
    Write(message string) error
    GetName() string
}

// ConsoleHandler 控制台处理器
type ConsoleHandler struct{}

func NewConsoleHandler() *ConsoleHandler {
    return &ConsoleHandler{}
}

func (h *ConsoleHandler) Write(message string) error {
    fmt.Println(message)
    return nil
}

func (h *ConsoleHandler) GetName() string {
    return "console"
}

// FileHandler 文件处理器
type FileHandler struct {
    path       string
    file       *os.File
    maxSize    uint64
    maxFiles   uint32
    currentSize uint64
    mu         sync.Mutex
}

func NewFileHandler(path string, maxSize uint64, maxFiles uint32) (*FileHandler, error) {
    file, err := os.OpenFile(path, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    if err != nil {
        return nil, err
    }
    
    info, err := file.Stat()
    if err != nil {
        file.Close()
        return nil, err
    }
    
    return &FileHandler{
        path:        path,
        file:        file,
        maxSize:     maxSize,
        maxFiles:    maxFiles,
        currentSize: uint64(info.Size()),
    }, nil
}

func (h *FileHandler) Write(message string) error {
    h.mu.Lock()
    defer h.mu.Unlock()
    
    // 检查是否需要轮转
    if h.currentSize >= h.maxSize {
        if err := h.rotateFiles(); err != nil {
            return err
        }
    }
    
    data := []byte(message + "\n")
    _, err := h.file.Write(data)
    if err != nil {
        return err
    }
    
    h.currentSize += uint64(len(data))
    return h.file.Sync()
}

func (h *FileHandler) rotateFiles() error {
    // 关闭当前文件
    h.file.Close()
    
    // 轮转文件
    for i := int(h.maxFiles) - 1; i > 0; i-- {
        oldPath := fmt.Sprintf("%s.%d", h.path, i-1)
        newPath := fmt.Sprintf("%s.%d", h.path, i)
        
        if _, err := os.Stat(oldPath); err == nil {
            os.Rename(oldPath, newPath)
        }
    }
    
    // 重命名当前文件
    backupPath := fmt.Sprintf("%s.1", h.path)
    os.Rename(h.path, backupPath)
    
    // 创建新文件
    file, err := os.OpenFile(h.path, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)
    if err != nil {
        return err
    }
    
    h.file = file
    h.currentSize = 0
    return nil
}

func (h *FileHandler) GetName() string {
    return "file"
}

// NetworkHandler 网络处理器
type NetworkHandler struct {
    url    string
    client *http.Client
}

func NewNetworkHandler(url string) (*NetworkHandler, error) {
    return &NetworkHandler{
        url:    url,
        client: &http.Client{Timeout: 5 * time.Second},
    }, nil
}

func (h *NetworkHandler) Write(message string) error {
    data := map[string]interface{}{
        "message":   message,
        "timestamp": time.Now().Format(time.RFC3339),
    }
    
    jsonData, err := json.Marshal(data)
    if err != nil {
        return err
    }
    
    resp, err := h.client.Post(h.url, "application/json", bytes.NewBuffer(jsonData))
    if err != nil {
        return err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return fmt.Errorf("HTTP错误: %d", resp.StatusCode)
    }
    
    return nil
}

func (h *NetworkHandler) GetName() string {
    return "network"
}

// DatabaseHandler 数据库处理器
type DatabaseHandler struct {
    connectionString string
}

func NewDatabaseHandler(connStr string) (*DatabaseHandler, error) {
    return &DatabaseHandler{
        connectionString: connStr,
    }, nil
}

func (h *DatabaseHandler) Write(message string) error {
    // 实现数据库写入逻辑
    return nil
}

func (h *DatabaseHandler) GetName() string {
    return "database"
}
```

## 使用示例

### Rust示例

```rust
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 创建日志配置
    let config = LogConfig {
        level: LogLevel::Info,
        format: LogFormat::Json,
        outputs: vec![
            LogOutput::Console,
            LogOutput::File("app.log".to_string()),
        ],
        max_file_size: 10 * 1024 * 1024, // 10MB
        max_files: 5,
        buffer_size: 1000,
    };
    
    // 创建日志记录器
    let logger = Logger::new(config).await;
    
    // 记录不同级别的日志
    logger.info("main", "应用程序启动").await;
    logger.debug("main", "调试信息").await;
    logger.warn("main", "警告信息").await;
    logger.error("main", "错误信息").await;
    
    // 记录带字段的日志
    let mut fields = HashMap::new();
    fields.insert("user_id".to_string(), serde_json::Value::String("123".to_string()));
    fields.insert("action".to_string(), serde_json::Value::String("login".to_string()));
    
    logger.log(LogLevel::Info, "auth", "用户登录", fields).await;
    
    // 等待一段时间让日志处理完成
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    Ok(())
}
```

### Go示例

```go
func main() {
    // 创建日志配置
    config := LogConfig{
        Level:   LogLevelInfo,
        Format:  LogFormatJSON,
        Outputs: []LogOutput{
            {Type: "console"},
            {Type: "file", Path: "app.log"},
        },
        MaxFileSize: 10 * 1024 * 1024, // 10MB
        MaxFiles:    5,
        BufferSize:  1000,
    }
    
    // 创建日志记录器
    logger := NewLogger(config)
    defer logger.Close()
    
    // 记录不同级别的日志
    logger.Info("main", "应用程序启动")
    logger.Debug("main", "调试信息")
    logger.Warn("main", "警告信息")
    logger.Error("main", "错误信息")
    
    // 记录带字段的日志
    fields := map[string]interface{}{
        "user_id": "123",
        "action":  "login",
    }
    
    logger.Log(LogLevelInfo, "auth", "用户登录", fields)
    
    // 等待一段时间让日志处理完成
    time.Sleep(time.Second)
}
```

## 总结

日志系统提供了：

1. **多级别日志**：支持Trace、Debug、Info、Warn、Error、Fatal级别
2. **多种格式**：JSON和文本格式支持
3. **多输出目标**：控制台、文件、网络、数据库
4. **异步处理**：高性能异步日志写入
5. **日志轮转**：自动文件轮转和大小控制
6. **结构化日志**：支持字段和元数据
7. **跨语言支持**：Rust和Go双语言实现

这个实现为IoT系统提供了功能完整、性能优异的日志记录基础，支持复杂的日志需求和分布式环境。
