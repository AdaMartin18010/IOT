# 物联网数据同步实现

## 概述

物联网数据同步系统提供设备数据、配置信息的多向同步功能，支持增量同步、实时同步和冲突解决。

## 核心架构

### 1. 数据同步核心

```rust
pub struct DataSyncSystem {
    sync_manager: Arc<SyncManager>,
    conflict_resolver: Arc<ConflictResolver>,
    data_sources: Arc<RwLock<HashMap<String, Box<dyn DataSource>>>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncTask {
    pub id: String,
    pub source_id: String,
    pub target_id: String,
    pub sync_type: SyncType,
    pub data_type: DataType,
    pub status: SyncStatus,
    pub created_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SyncType {
    Full,           // 全量同步
    Incremental,    // 增量同步
    RealTime,       // 实时同步
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DataType {
    DeviceData,     // 设备数据
    Configuration,  // 配置信息
    Status,         // 状态信息
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SyncStatus {
    Pending,
    Running,
    Completed,
    Failed,
}

impl DataSyncSystem {
    pub fn new() -> Self {
        Self {
            sync_manager: Arc::new(SyncManager::new()),
            conflict_resolver: Arc::new(ConflictResolver::new()),
            data_sources: Arc::new(RwLock::new(HashMap::new())),
        }
    }

    // 注册数据源
    pub async fn register_data_source(&self, id: String, source: Box<dyn DataSource>) {
        let mut sources = self.data_sources.write().await;
        sources.insert(id, source);
    }

    // 执行同步任务
    pub async fn execute_sync(&self, task: SyncTask) -> Result<SyncResult, SyncError> {
        let source = self.get_data_source(&task.source_id).await?;
        let target = self.get_data_source(&task.target_id).await?;
        
        self.sync_manager.update_task_status(&task.id, SyncStatus::Running).await;
        
        let result = match task.sync_type {
            SyncType::Full => self.full_sync(source, target, &task).await,
            SyncType::Incremental => self.incremental_sync(source, target, &task).await,
            SyncType::RealTime => self.realtime_sync(source, target, &task).await,
        };
        
        let final_status = if result.is_ok() { SyncStatus::Completed } else { SyncStatus::Failed };
        self.sync_manager.update_task_status(&task.id, final_status).await;
        
        result
    }

    // 全量同步
    async fn full_sync(&self, source: Box<dyn DataSource>, target: Box<dyn DataSource>, task: &SyncTask) -> Result<SyncResult, SyncError> {
        let start_time = Utc::now();
        let source_data = source.read_data(&task.data_type, None).await?;
        target.write_data(&task.data_type, source_data.clone()).await?;
        
        Ok(SyncResult {
            task_id: task.id.clone(),
            records_synced: source_data.len(),
            start_time,
            end_time: Utc::now(),
            success: true,
        })
    }

    // 增量同步
    async fn incremental_sync(&self, source: Box<dyn DataSource>, target: Box<dyn DataSource>, task: &SyncTask) -> Result<SyncResult, SyncError> {
        let start_time = Utc::now();
        let last_sync = target.get_last_sync_timestamp(&task.data_type).await?;
        
        let filter = DataFilter {
            start_time: last_sync,
            end_time: None,
            limit: None,
        };
        
        let incremental_data = source.read_data(&task.data_type, Some(filter)).await?;
        
        if !incremental_data.is_empty() {
            target.write_data(&task.data_type, incremental_data.clone()).await?;
        }
        
        target.update_sync_timestamp(&task.data_type, start_time).await?;
        
        Ok(SyncResult {
            task_id: task.id.clone(),
            records_synced: incremental_data.len(),
            start_time,
            end_time: Utc::now(),
            success: true,
        })
    }

    // 实时同步
    async fn realtime_sync(&self, source: Box<dyn DataSource>, target: Box<dyn DataSource>, task: &SyncTask) -> Result<SyncResult, SyncError> {
        let start_time = Utc::now();
        let mut records_synced = 0;
        
        // 订阅数据变更事件
        let mut event_stream = self.subscribe_to_events(&task.data_type).await;
        
        while let Some(event) = event_stream.next().await {
            let record = self.convert_event_to_record(event).await?;
            target.write_data(&task.data_type, vec![record]).await?;
            records_synced += 1;
        }
        
        Ok(SyncResult {
            task_id: task.id.clone(),
            records_synced,
            start_time,
            end_time: Utc::now(),
            success: true,
        })
    }

    async fn get_data_source(&self, source_id: &str) -> Result<Box<dyn DataSource>, SyncError> {
        let sources = self.data_sources.read().await;
        sources.get(source_id)
            .cloned()
            .ok_or(SyncError::DataSourceNotFound)
    }
}
```

### 2. 数据源接口

```rust
pub trait DataSource: Send + Sync {
    async fn read_data(&self, data_type: &DataType, filter: Option<DataFilter>) -> Result<Vec<DataRecord>, SyncError>;
    async fn write_data(&self, data_type: &DataType, records: Vec<DataRecord>) -> Result<(), SyncError>;
    async fn get_last_sync_timestamp(&self, data_type: &DataType) -> Result<Option<DateTime<Utc>>, SyncError>;
    async fn update_sync_timestamp(&self, data_type: &DataType, timestamp: DateTime<Utc>) -> Result<(), SyncError>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataRecord {
    pub id: String,
    pub data_type: DataType,
    pub data: serde_json::Value,
    pub metadata: HashMap<String, String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    pub version: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataFilter {
    pub start_time: Option<DateTime<Utc>>,
    pub end_time: Option<DateTime<Utc>>,
    pub limit: Option<usize>,
}

// 数据库数据源
pub struct DatabaseDataSource {
    source_id: String,
    connection_string: String,
    db_type: DatabaseType,
}

#[derive(Debug, Clone)]
pub enum DatabaseType {
    PostgreSQL,
    MySQL,
    SQLite,
}

impl DataSource for DatabaseDataSource {
    async fn read_data(&self, data_type: &DataType, filter: Option<DataFilter>) -> Result<Vec<DataRecord>, SyncError> {
        // 根据数据库类型实现数据读取
        match self.db_type {
            DatabaseType::PostgreSQL => self.read_from_postgres(data_type, filter).await,
            DatabaseType::MySQL => self.read_from_mysql(data_type, filter).await,
            DatabaseType::SQLite => self.read_from_sqlite(data_type, filter).await,
        }
    }

    async fn write_data(&self, data_type: &DataType, records: Vec<DataRecord>) -> Result<(), SyncError> {
        // 根据数据库类型实现数据写入
        match self.db_type {
            DatabaseType::PostgreSQL => self.write_to_postgres(data_type, records).await,
            DatabaseType::MySQL => self.write_to_mysql(data_type, records).await,
            DatabaseType::SQLite => self.write_to_sqlite(data_type, records).await,
        }
    }

    async fn get_last_sync_timestamp(&self, data_type: &DataType) -> Result<Option<DateTime<Utc>>, SyncError> {
        // 从数据库读取最后同步时间戳
        Ok(None)
    }

    async fn update_sync_timestamp(&self, data_type: &DataType, timestamp: DateTime<Utc>) -> Result<(), SyncError> {
        // 更新数据库中的同步时间戳
        Ok(())
    }
}

impl DatabaseDataSource {
    async fn read_from_postgres(&self, data_type: &DataType, filter: Option<DataFilter>) -> Result<Vec<DataRecord>, SyncError> {
        // PostgreSQL数据读取实现
        Ok(Vec::new())
    }

    async fn write_to_postgres(&self, data_type: &DataType, records: Vec<DataRecord>) -> Result<(), SyncError> {
        // PostgreSQL数据写入实现
        Ok(())
    }

    async fn read_from_mysql(&self, data_type: &DataType, filter: Option<DataFilter>) -> Result<Vec<DataRecord>, SyncError> {
        // MySQL数据读取实现
        Ok(Vec::new())
    }

    async fn write_to_mysql(&self, data_type: &DataType, records: Vec<DataRecord>) -> Result<(), SyncError> {
        // MySQL数据写入实现
        Ok(())
    }

    async fn read_from_sqlite(&self, data_type: &DataType, filter: Option<DataFilter>) -> Result<Vec<DataRecord>, SyncError> {
        // SQLite数据读取实现
        Ok(Vec::new())
    }

    async fn write_to_sqlite(&self, data_type: &DataType, records: Vec<DataRecord>) -> Result<(), SyncError> {
        // SQLite数据写入实现
        Ok(())
    }
}
```

### 3. 冲突解决器

```rust
pub struct ConflictResolver {
    resolution_strategies: HashMap<ConflictResolutionStrategy, Box<dyn ConflictResolutionStrategy>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConflictResolutionStrategy {
    SourceWins,     // 源端优先
    TargetWins,     // 目标端优先
    Merge,          // 合并策略
    Timestamp,      // 时间戳优先
}

impl ConflictResolver {
    pub fn new() -> Self {
        let mut strategies: HashMap<ConflictResolutionStrategy, Box<dyn ConflictResolutionStrategy>> = HashMap::new();
        
        strategies.insert(ConflictResolutionStrategy::SourceWins, Box::new(SourceWinsStrategy));
        strategies.insert(ConflictResolutionStrategy::TargetWins, Box::new(TargetWinsStrategy));
        strategies.insert(ConflictResolutionStrategy::Merge, Box::new(MergeStrategy));
        strategies.insert(ConflictResolutionStrategy::Timestamp, Box::new(TimestampStrategy));
        
        Self { resolution_strategies: strategies }
    }

    // 解决数据冲突
    pub async fn resolve_conflict(&self, source_record: &DataRecord, target_record: &DataRecord, strategy: &ConflictResolutionStrategy) -> DataRecord {
        if let Some(resolution_strategy) = self.resolution_strategies.get(strategy) {
            resolution_strategy.resolve(source_record, target_record).await
        } else {
            source_record.clone()
        }
    }

    // 检测冲突
    pub fn detect_conflicts(&self, source_records: &[DataRecord], target_records: &[DataRecord]) -> Vec<DataConflict> {
        let mut conflicts = Vec::new();
        
        for source_record in source_records {
            if let Some(target_record) = target_records.iter().find(|r| r.id == source_record.id) {
                if source_record.version != target_record.version {
                    conflicts.push(DataConflict {
                        record_id: source_record.id.clone(),
                        source_record: source_record.clone(),
                        target_record: target_record.clone(),
                    });
                }
            }
        }
        
        conflicts
    }
}

pub trait ConflictResolutionStrategy: Send + Sync {
    async fn resolve(&self, source_record: &DataRecord, target_record: &DataRecord) -> DataRecord;
}

// 源端优先策略
pub struct SourceWinsStrategy;

impl ConflictResolutionStrategy for SourceWinsStrategy {
    async fn resolve(&self, source_record: &DataRecord, _target_record: &DataRecord) -> DataRecord {
        source_record.clone()
    }
}

// 目标端优先策略
pub struct TargetWinsStrategy;

impl ConflictResolutionStrategy for TargetWinsStrategy {
    async fn resolve(&self, _source_record: &DataRecord, target_record: &DataRecord) -> DataRecord {
        target_record.clone()
    }
}

// 合并策略
pub struct MergeStrategy;

impl ConflictResolutionStrategy for MergeStrategy {
    async fn resolve(&self, source_record: &DataRecord, target_record: &DataRecord) -> DataRecord {
        let mut merged_data = source_record.data.clone();
        
        // 合并JSON数据
        if let (serde_json::Value::Object(mut source_obj), serde_json::Value::Object(target_obj)) = (merged_data, target_record.data.clone()) {
            for (key, value) in target_obj {
                source_obj.insert(key, value);
            }
            merged_data = serde_json::Value::Object(source_obj);
        }
        
        // 合并元数据
        let mut merged_metadata = source_record.metadata.clone();
        for (key, value) in &target_record.metadata {
            merged_metadata.insert(key.clone(), value.clone());
        }
        
        DataRecord {
            id: source_record.id.clone(),
            data_type: source_record.data_type.clone(),
            data: merged_data,
            metadata: merged_metadata,
            created_at: source_record.created_at,
            updated_at: Utc::now(),
            version: source_record.version.max(target_record.version) + 1,
        }
    }
}

// 时间戳优先策略
pub struct TimestampStrategy;

impl ConflictResolutionStrategy for TimestampStrategy {
    async fn resolve(&self, source_record: &DataRecord, target_record: &DataRecord) -> DataRecord {
        if source_record.updated_at > target_record.updated_at {
            source_record.clone()
        } else {
            target_record.clone()
        }
    }
}

#[derive(Debug, Clone)]
pub struct DataConflict {
    pub record_id: String,
    pub source_record: DataRecord,
    pub target_record: DataRecord,
}
```

### 4. 同步管理器

```rust
pub struct SyncManager {
    tasks: Arc<RwLock<HashMap<String, SyncTask>>>,
    running_tasks: Arc<RwLock<HashSet<String>>>,
}

impl SyncManager {
    pub fn new() -> Self {
        Self {
            tasks: Arc::new(RwLock::new(HashMap::new())),
            running_tasks: Arc::new(RwLock::new(HashSet::new())),
        }
    }

    // 添加同步任务
    pub async fn add_task(&self, task: SyncTask) {
        let mut tasks = self.tasks.write().await;
        tasks.insert(task.id.clone(), task);
    }

    // 更新任务状态
    pub async fn update_task_status(&self, task_id: &str, status: SyncStatus) {
        let mut tasks = self.tasks.write().await;
        if let Some(task) = tasks.get_mut(task_id) {
            task.status = status.clone();
            
            match status {
                SyncStatus::Running => {
                    let mut running = self.running_tasks.write().await;
                    running.insert(task_id.to_string());
                }
                SyncStatus::Completed | SyncStatus::Failed => {
                    let mut running = self.running_tasks.write().await;
                    running.remove(task_id);
                }
                _ => {}
            }
        }
    }

    // 获取任务状态
    pub async fn get_task_status(&self, task_id: &str) -> Option<SyncStatus> {
        let tasks = self.tasks.read().await;
        tasks.get(task_id).map(|t| t.status.clone())
    }

    // 取消任务
    pub async fn cancel_task(&self, task_id: &str) -> Result<(), SyncError> {
        let mut tasks = self.tasks.write().await;
        if let Some(task) = tasks.get_mut(task_id) {
            task.status = SyncStatus::Cancelled;
        }
        
        let mut running = self.running_tasks.write().await;
        running.remove(task_id);
        
        Ok(())
    }

    // 获取所有任务
    pub async fn get_all_tasks(&self) -> Vec<SyncTask> {
        let tasks = self.tasks.read().await;
        tasks.values().cloned().collect()
    }
}
```

### 5. 数据同步API

```rust
#[derive(Deserialize)]
pub struct CreateSyncTaskRequest {
    pub source_id: String,
    pub target_id: String,
    pub sync_type: SyncType,
    pub data_type: DataType,
}

#[derive(Serialize)]
pub struct SyncTaskResponse {
    pub task: SyncTask,
    pub status: SyncStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncResult {
    pub task_id: String,
    pub records_synced: usize,
    pub start_time: DateTime<Utc>,
    pub end_time: DateTime<Utc>,
    pub success: bool,
}

// 数据同步API路由
pub fn data_sync_routes() -> Router {
    Router::new()
        .route("/sync/tasks", post(create_sync_task))
        .route("/sync/tasks", get(list_sync_tasks))
        .route("/sync/tasks/:id", get(get_sync_task))
        .route("/sync/tasks/:id", delete(cancel_sync_task))
        .route("/sync/tasks/:id/execute", post(execute_sync_task))
}

async fn create_sync_task(
    Json(request): Json<CreateSyncTaskRequest>,
    State(sync_system): State<Arc<DataSyncSystem>>,
) -> Result<Json<SyncTaskResponse>, StatusCode> {
    let task = SyncTask {
        id: Uuid::new_v4().to_string(),
        source_id: request.source_id,
        target_id: request.target_id,
        sync_type: request.sync_type,
        data_type: request.data_type,
        status: SyncStatus::Pending,
        created_at: Utc::now(),
    };
    
    sync_system.sync_manager.add_task(task.clone()).await;
    
    Ok(Json(SyncTaskResponse {
        task: task.clone(),
        status: task.status,
    }))
}

async fn execute_sync_task(
    Path(task_id): Path<String>,
    State(sync_system): State<Arc<DataSyncSystem>>,
) -> Result<Json<SyncResult>, StatusCode> {
    let tasks = sync_system.sync_manager.get_all_tasks().await;
    let task = tasks.iter().find(|t| t.id == task_id)
        .ok_or(StatusCode::NOT_FOUND)?;
    
    let result = sync_system.execute_sync(task.clone()).await
        .map_err(|_| StatusCode::INTERNAL_SERVER_ERROR)?;
    
    Ok(Json(result))
}
```

## 使用示例

### 1. 基本数据同步

```rust
#[tokio::main]
async fn main() {
    let sync_system = Arc::new(DataSyncSystem::new());
    
    // 注册数据源
    let source_db = DatabaseDataSource {
        source_id: "source_db".to_string(),
        connection_string: "postgresql://user:pass@localhost/source_db".to_string(),
        db_type: DatabaseType::PostgreSQL,
    };
    
    let target_db = DatabaseDataSource {
        source_id: "target_db".to_string(),
        connection_string: "postgresql://user:pass@localhost/target_db".to_string(),
        db_type: DatabaseType::PostgreSQL,
    };
    
    sync_system.register_data_source("source_db".to_string(), Box::new(source_db)).await;
    sync_system.register_data_source("target_db".to_string(), Box::new(target_db)).await;
    
    // 创建同步任务
    let task = SyncTask {
        id: Uuid::new_v4().to_string(),
        source_id: "source_db".to_string(),
        target_id: "target_db".to_string(),
        sync_type: SyncType::Full,
        data_type: DataType::DeviceData,
        status: SyncStatus::Pending,
        created_at: Utc::now(),
    };
    
    // 执行同步
    let result = sync_system.execute_sync(task).await.unwrap();
    
    println!("同步完成: {} 条记录", result.records_synced);
}
```

### 2. 增量同步

```rust
// 执行增量同步
async fn perform_incremental_sync(sync_system: Arc<DataSyncSystem>) {
    let task = SyncTask {
        id: Uuid::new_v4().to_string(),
        source_id: "source_db".to_string(),
        target_id: "target_db".to_string(),
        sync_type: SyncType::Incremental,
        data_type: DataType::DeviceData,
        status: SyncStatus::Pending,
        created_at: Utc::now(),
    };
    
    let result = sync_system.execute_sync(task).await.unwrap();
    
    if result.success {
        println!("增量同步成功: {} 条记录", result.records_synced);
    } else {
        println!("增量同步失败");
    }
}
```

### 3. 冲突解决

```rust
// 处理数据冲突
async fn handle_data_conflicts(sync_system: Arc<DataSyncSystem>) {
    let source_records = vec![
        DataRecord {
            id: "device_001".to_string(),
            data_type: DataType::DeviceData,
            data: serde_json::json!({"temperature": 25.5}),
            metadata: HashMap::new(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            version: 2,
        }
    ];
    
    let target_records = vec![
        DataRecord {
            id: "device_001".to_string(),
            data_type: DataType::DeviceData,
            data: serde_json::json!({"temperature": 26.0}),
            metadata: HashMap::new(),
            created_at: Utc::now(),
            updated_at: Utc::now(),
            version: 1,
        }
    ];
    
    // 检测冲突
    let conflicts = sync_system.conflict_resolver.detect_conflicts(&source_records, &target_records);
    
    for conflict in conflicts {
        // 使用时间戳策略解决冲突
        let resolved_record = sync_system.conflict_resolver.resolve_conflict(
            &conflict.source_record,
            &conflict.target_record,
            &ConflictResolutionStrategy::Timestamp,
        ).await;
        
        println!("冲突已解决: {}", resolved_record.id);
    }
}
```

## 核心特性

1. **多种同步策略**: 全量、增量、实时同步
2. **多数据源支持**: 数据库、文件系统等
3. **冲突解决**: 多种冲突解决策略
4. **数据一致性**: 版本控制和时间戳管理
5. **错误处理**: 重试机制和错误恢复
6. **API接口**: 完整的RESTful API支持

这个物联网数据同步系统实现提供了全面的数据同步功能，确保数据的一致性和可靠性。
