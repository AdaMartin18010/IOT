# 设备语义标准合规性检查

## 1. 合规性检查框架

```python
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import json

class ComplianceStandard(Enum):
    OPC_UA = "opc_ua"
    IEC_61850 = "iec_61850"
    IEEE_2030_5 = "ieee_2030_5"
    BACNET = "bacnet"
    MQTT = "mqtt"
    COAP = "coap"

@dataclass
class ComplianceRule:
    rule_id: str
    standard: ComplianceStandard
    rule_type: str
    description: str
    validation_function: callable
    severity: str  # "error", "warning", "info"

@dataclass
class ComplianceResult:
    device_id: str
    standard: ComplianceStandard
    compliant: bool
    score: float
    violations: List[Dict[str, Any]]
    warnings: List[Dict[str, Any]]
    recommendations: List[str]
```

## 2. 合规性检查引擎

```python
class SemanticComplianceChecker:
    """语义合规性检查器"""
    
    def __init__(self):
        self.compliance_rules: Dict[ComplianceStandard, List[ComplianceRule]] = {}
        self._initialize_standard_rules()
    
    def _initialize_standard_rules(self):
        """初始化标准规则"""
        # OPC UA规则
        opc_ua_rules = [
            ComplianceRule(
                rule_id="opc_ua_node_id_format",
                standard=ComplianceStandard.OPC_UA,
                rule_type="format",
                description="节点ID格式检查",
                validation_function=self._validate_opc_ua_node_id,
                severity="error"
            ),
            ComplianceRule(
                rule_id="opc_ua_data_type",
                standard=ComplianceStandard.OPC_UA,
                rule_type="data_type",
                description="数据类型合规性检查",
                validation_function=self._validate_opc_ua_data_type,
                severity="error"
            )
        ]
        
        # MQTT规则
        mqtt_rules = [
            ComplianceRule(
                rule_id="mqtt_topic_format",
                standard=ComplianceStandard.MQTT,
                rule_type="format",
                description="主题格式检查",
                validation_function=self._validate_mqtt_topic,
                severity="warning"
            ),
            ComplianceRule(
                rule_id="mqtt_qos_level",
                standard=ComplianceStandard.MQTT,
                rule_type="qos",
                description="QoS级别检查",
                validation_function=self._validate_mqtt_qos,
                severity="info"
            )
        ]
        
        self.compliance_rules[ComplianceStandard.OPC_UA] = opc_ua_rules
        self.compliance_rules[ComplianceStandard.MQTT] = mqtt_rules
    
    def check_compliance(self, device_data: Dict[str, Any], 
                        standard: ComplianceStandard) -> ComplianceResult:
        """检查合规性"""
        violations = []
        warnings = []
        recommendations = []
        
        if standard not in self.compliance_rules:
            return ComplianceResult(
                device_id=device_data.get("device_id", "unknown"),
                standard=standard,
                compliant=False,
                score=0.0,
                violations=[{"error": f"不支持的标准: {standard.value}"}],
                warnings=[],
                recommendations=[]
            )
        
        rules = self.compliance_rules[standard]
        total_rules = len(rules)
        passed_rules = 0
        
        for rule in rules:
            try:
                is_valid, message = rule.validation_function(device_data)
                
                if is_valid:
                    passed_rules += 1
                else:
                    violation = {
                        "rule_id": rule.rule_id,
                        "rule_type": rule.rule_type,
                        "description": rule.description,
                        "message": message,
                        "severity": rule.severity
                    }
                    
                    if rule.severity == "error":
                        violations.append(violation)
                    elif rule.severity == "warning":
                        warnings.append(violation)
                    else:
                        recommendations.append(message)
                        
            except Exception as e:
                violations.append({
                    "rule_id": rule.rule_id,
                    "error": f"规则检查失败: {str(e)}"
                })
        
        compliance_score = passed_rules / total_rules if total_rules > 0 else 0.0
        is_compliant = len(violations) == 0
        
        return ComplianceResult(
            device_id=device_data.get("device_id", "unknown"),
            standard=standard,
            compliant=is_compliant,
            score=compliance_score,
            violations=violations,
            warnings=warnings,
            recommendations=recommendations
        )
    
    def _validate_opc_ua_node_id(self, device_data: Dict[str, Any]) -> tuple[bool, str]:
        """验证OPC UA节点ID格式"""
        node_id = device_data.get("node_id")
        if not node_id:
            return False, "缺少node_id字段"
        
        # 检查节点ID格式 (ns=X;s=Y 或 ns=X;i=Y)
        if not (node_id.startswith("ns=") and ("s=" in node_id or "i=" in node_id)):
            return False, f"节点ID格式不正确: {node_id}"
        
        return True, "节点ID格式正确"
    
    def _validate_opc_ua_data_type(self, device_data: Dict[str, Any]) -> tuple[bool, str]:
        """验证OPC UA数据类型"""
        data_type = device_data.get("data_type")
        if not data_type:
            return False, "缺少data_type字段"
        
        valid_types = ["Boolean", "Byte", "Int16", "Int32", "Float", "Double", "String", "DateTime"]
        if data_type not in valid_types:
            return False, f"不支持的数据类型: {data_type}"
        
        return True, "数据类型正确"
    
    def _validate_mqtt_topic(self, device_data: Dict[str, Any]) -> tuple[bool, str]:
        """验证MQTT主题格式"""
        topic = device_data.get("topic")
        if not topic:
            return False, "缺少topic字段"
        
        # 检查主题是否包含通配符
        if "#" in topic or "+" in topic:
            return False, "发布主题不应包含通配符"
        
        # 检查主题长度
        if len(topic) > 65535:
            return False, "主题长度超过限制"
        
        return True, "主题格式正确"
    
    def _validate_mqtt_qos(self, device_data: Dict[str, Any]) -> tuple[bool, str]:
        """验证MQTT QoS级别"""
        qos = device_data.get("qos")
        if qos is None:
            return True, "QoS未指定，使用默认值"
        
        if qos not in [0, 1, 2]:
            return False, f"无效的QoS级别: {qos}"
        
        return True, f"QoS级别{qos}正确"
```

## 3. 标准兼容性检查

```python
class StandardCompatibilityChecker:
    """标准兼容性检查器"""
    
    def __init__(self):
        self.compatibility_matrix = self._build_compatibility_matrix()
    
    def _build_compatibility_matrix(self) -> Dict[str, Dict[str, float]]:
        """构建兼容性矩阵"""
        return {
            "opc_ua": {
                "mqtt": 0.8,
                "coap": 0.6,
                "http": 0.7,
                "modbus": 0.5
            },
            "mqtt": {
                "opc_ua": 0.8,
                "coap": 0.9,
                "http": 0.6,
                "amqp": 0.7
            },
            "coap": {
                "mqtt": 0.9,
                "http": 0.8,
                "opc_ua": 0.6
            }
        }
    
    def check_cross_standard_compatibility(self, 
                                         source_standard: str, 
                                         target_standard: str) -> Dict[str, Any]:
        """检查跨标准兼容性"""
        if source_standard not in self.compatibility_matrix:
            return {
                "compatible": False,
                "score": 0.0,
                "reason": f"不支持的源标准: {source_standard}"
            }
        
        if target_standard not in self.compatibility_matrix[source_standard]:
            return {
                "compatible": False,
                "score": 0.0,
                "reason": f"不支持的目标标准组合: {source_standard} -> {target_standard}"
            }
        
        compatibility_score = self.compatibility_matrix[source_standard][target_standard]
        
        return {
            "compatible": compatibility_score >= 0.5,
            "score": compatibility_score,
            "reason": f"兼容性评分: {compatibility_score}"
        }
```

## 4. Rust实现

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ComplianceStandard {
    OpcUa,
    Iec61850,
    Ieee2030_5,
    Bacnet,
    Mqtt,
    Coap,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComplianceResult {
    pub device_id: String,
    pub standard: ComplianceStandard,
    pub compliant: bool,
    pub score: f64,
    pub violations: Vec<HashMap<String, String>>,
    pub warnings: Vec<HashMap<String, String>>,
    pub recommendations: Vec<String>,
}

pub struct SemanticComplianceChecker {
    compliance_rules: HashMap<String, Vec<String>>,
}

impl SemanticComplianceChecker {
    pub fn new() -> Self {
        Self {
            compliance_rules: Self::initialize_rules(),
        }
    }
    
    fn initialize_rules() -> HashMap<String, Vec<String>> {
        let mut rules = HashMap::new();
        
        rules.insert("opc_ua".to_string(), vec![
            "node_id_format".to_string(),
            "data_type_validation".to_string(),
            "namespace_check".to_string(),
        ]);
        
        rules.insert("mqtt".to_string(), vec![
            "topic_format".to_string(),
            "qos_validation".to_string(),
            "payload_size".to_string(),
        ]);
        
        rules
    }
    
    pub fn check_compliance(
        &self,
        device_data: &HashMap<String, String>,
        standard: &ComplianceStandard,
    ) -> Result<ComplianceResult, String> {
        let standard_str = format!("{:?}", standard).to_lowercase();
        
        let rules = self.compliance_rules.get(&standard_str)
            .ok_or_else(|| format!("不支持的标准: {:?}", standard))?;
        
        let mut violations = Vec::new();
        let mut warnings = Vec::new();
        let mut passed_rules = 0;
        let total_rules = rules.len();
        
        for rule in rules {
            match self.validate_rule(device_data, rule, &standard_str) {
                Ok(true) => passed_rules += 1,
                Ok(false) => {
                    let mut violation = HashMap::new();
                    violation.insert("rule".to_string(), rule.clone());
                    violation.insert("message".to_string(), format!("规则 {} 验证失败", rule));
                    violations.push(violation);
                }
                Err(e) => {
                    let mut warning = HashMap::new();
                    warning.insert("rule".to_string(), rule.clone());
                    warning.insert("error".to_string(), e);
                    warnings.push(warning);
                }
            }
        }
        
        let compliance_score = if total_rules > 0 {
            passed_rules as f64 / total_rules as f64
        } else {
            0.0
        };
        
        Ok(ComplianceResult {
            device_id: device_data.get("device_id").unwrap_or(&"unknown".to_string()).clone(),
            standard: standard.clone(),
            compliant: violations.is_empty(),
            score: compliance_score,
            violations,
            warnings,
            recommendations: vec![],
        })
    }
    
    fn validate_rule(
        &self,
        device_data: &HashMap<String, String>,
        rule: &str,
        standard: &str,
    ) -> Result<bool, String> {
        match (standard, rule) {
            ("opc_ua", "node_id_format") => self.validate_opc_ua_node_id(device_data),
            ("opc_ua", "data_type_validation") => self.validate_opc_ua_data_type(device_data),
            ("mqtt", "topic_format") => self.validate_mqtt_topic(device_data),
            ("mqtt", "qos_validation") => self.validate_mqtt_qos(device_data),
            _ => Err(format!("未知规则: {}", rule)),
        }
    }
    
    fn validate_opc_ua_node_id(&self, device_data: &HashMap<String, String>) -> Result<bool, String> {
        match device_data.get("node_id") {
            Some(node_id) => {
                if node_id.starts_with("ns=") && (node_id.contains("s=") || node_id.contains("i=")) {
                    Ok(true)
                } else {
                    Ok(false)
                }
            }
            None => Ok(false),
        }
    }
    
    fn validate_opc_ua_data_type(&self, device_data: &HashMap<String, String>) -> Result<bool, String> {
        let valid_types = ["Boolean", "Byte", "Int16", "Int32", "Float", "Double", "String", "DateTime"];
        
        match device_data.get("data_type") {
            Some(data_type) => Ok(valid_types.contains(&data_type.as_str())),
            None => Ok(false),
        }
    }
    
    fn validate_mqtt_topic(&self, device_data: &HashMap<String, String>) -> Result<bool, String> {
        match device_data.get("topic") {
            Some(topic) => {
                if topic.contains('#') || topic.contains('+') {
                    Ok(false)
                } else if topic.len() > 65535 {
                    Ok(false)
                } else {
                    Ok(true)
                }
            }
            None => Ok(false),
        }
    }
    
    fn validate_mqtt_qos(&self, device_data: &HashMap<String, String>) -> Result<bool, String> {
        match device_data.get("qos") {
            Some(qos_str) => {
                match qos_str.parse::<i32>() {
                    Ok(qos) => Ok(qos >= 0 && qos <= 2),
                    Err(_) => Ok(false),
                }
            }
            None => Ok(true), // QoS是可选的
        }
    }
}
```

## 5. 测试用例

```python
import unittest

class TestSemanticComplianceChecker(unittest.TestCase):
    def setUp(self):
        self.checker = SemanticComplianceChecker()
    
    def test_opc_ua_compliance(self):
        """测试OPC UA合规性检查"""
        # 合规的设备数据
        compliant_data = {
            "device_id": "sensor001",
            "node_id": "ns=2;s=Temperature",
            "data_type": "Float",
            "value": 25.5
        }
        
        result = self.checker.check_compliance(compliant_data, ComplianceStandard.OPC_UA)
        
        self.assertTrue(result.compliant)
        self.assertEqual(len(result.violations), 0)
        self.assertGreater(result.score, 0.8)
    
    def test_opc_ua_non_compliance(self):
        """测试OPC UA不合规数据"""
        non_compliant_data = {
            "device_id": "sensor002",
            "node_id": "invalid_node_id",
            "data_type": "InvalidType",
            "value": 25.5
        }
        
        result = self.checker.check_compliance(non_compliant_data, ComplianceStandard.OPC_UA)
        
        self.assertFalse(result.compliant)
        self.assertGreater(len(result.violations), 0)
        self.assertLess(result.score, 0.5)
    
    def test_mqtt_compliance(self):
        """测试MQTT合规性检查"""
        compliant_data = {
            "device_id": "sensor003",
            "topic": "devices/sensor003/temperature",
            "qos": "1",
            "payload": '{"temperature": 25.5}'
        }
        
        result = self.checker.check_compliance(compliant_data, ComplianceStandard.MQTT)
        
        self.assertTrue(result.compliant)
        self.assertEqual(len(result.violations), 0)
    
    def test_cross_standard_compatibility(self):
        """测试跨标准兼容性"""
        compatibility_checker = StandardCompatibilityChecker()
        
        result = compatibility_checker.check_cross_standard_compatibility("mqtt", "opc_ua")
        
        self.assertTrue(result["compatible"])
        self.assertGreater(result["score"], 0.5)

if __name__ == '__main__':
    unittest.main()
```

## 6. 自动化合规性报告

```python
class ComplianceReportGenerator:
    """合规性报告生成器"""
    
    def __init__(self):
        self.checker = SemanticComplianceChecker()
        self.compatibility_checker = StandardCompatibilityChecker()
    
    def generate_compliance_report(self, devices: List[Dict[str, Any]], 
                                 standards: List[ComplianceStandard]) -> Dict[str, Any]:
        """生成合规性报告"""
        report = {
            "timestamp": datetime.now().isoformat(),
            "total_devices": len(devices),
            "standards_checked": [s.value for s in standards],
            "device_results": [],
            "summary": {
                "compliant_devices": 0,
                "non_compliant_devices": 0,
                "average_compliance_score": 0.0
            }
        }
        
        total_score = 0.0
        
        for device in devices:
            device_report = {
                "device_id": device.get("device_id", "unknown"),
                "compliance_results": []
            }
            
            device_compliant = True
            device_total_score = 0.0
            
            for standard in standards:
                result = self.checker.check_compliance(device, standard)
                device_report["compliance_results"].append(result.__dict__)
                
                if not result.compliant:
                    device_compliant = False
                
                device_total_score += result.score
            
            device_avg_score = device_total_score / len(standards) if standards else 0.0
            device_report["average_score"] = device_avg_score
            device_report["overall_compliant"] = device_compliant
            
            report["device_results"].append(device_report)
            
            if device_compliant:
                report["summary"]["compliant_devices"] += 1
            else:
                report["summary"]["non_compliant_devices"] += 1
            
            total_score += device_avg_score
        
        report["summary"]["average_compliance_score"] = (
            total_score / len(devices) if devices else 0.0
        )
        
        return report
    
    def export_report_to_json(self, report: Dict[str, Any], filename: str):
        """导出报告为JSON文件"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
    
    def export_report_to_html(self, report: Dict[str, Any], filename: str):
        """导出报告为HTML文件"""
        html_template = """
        <!DOCTYPE html>
        <html>
        <head>
            <title>设备语义合规性报告</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .header { background-color: #f0f0f0; padding: 20px; }
                .summary { background-color: #e6f3ff; padding: 15px; margin: 20px 0; }
                .device { border: 1px solid #ddd; margin: 10px 0; padding: 15px; }
                .compliant { background-color: #d4edda; }
                .non-compliant { background-color: #f8d7da; }
                .violation { color: #dc3545; margin: 5px 0; }
                .warning { color: #ffc107; margin: 5px 0; }
            </style>
        </head>
        <body>
            <div class="header">
                <h1>设备语义合规性报告</h1>
                <p>生成时间: {timestamp}</p>
            </div>
            
            <div class="summary">
                <h2>总结</h2>
                <p>总设备数: {total_devices}</p>
                <p>合规设备: {compliant_devices}</p>
                <p>不合规设备: {non_compliant_devices}</p>
                <p>平均合规分数: {average_score:.2f}</p>
            </div>
            
            <div class="devices">
                <h2>设备详情</h2>
                {device_details}
            </div>
        </body>
        </html>
        """
        
        device_details = ""
        for device_result in report["device_results"]:
            device_class = "compliant" if device_result["overall_compliant"] else "non-compliant"
            device_details += f'<div class="device {device_class}">'
            device_details += f'<h3>设备: {device_result["device_id"]}</h3>'
            device_details += f'<p>平均分数: {device_result["average_score"]:.2f}</p>'
            
            for compliance_result in device_result["compliance_results"]:
                device_details += f'<h4>标准: {compliance_result["standard"]}</h4>'
                device_details += f'<p>合规: {"是" if compliance_result["compliant"] else "否"}</p>'
                device_details += f'<p>分数: {compliance_result["score"]:.2f}</p>'
                
                if compliance_result["violations"]:
                    device_details += '<div class="violations"><h5>违规:</h5>'
                    for violation in compliance_result["violations"]:
                        device_details += f'<div class="violation">{violation}</div>'
                    device_details += '</div>'
            
            device_details += '</div>'
        
        html_content = html_template.format(
            timestamp=report["timestamp"],
            total_devices=report["total_devices"],
            compliant_devices=report["summary"]["compliant_devices"],
            non_compliant_devices=report["summary"]["non_compliant_devices"],
            average_score=report["summary"]["average_compliance_score"],
            device_details=device_details
        )
        
        with open(filename, 'w', encoding='utf-8') as f:
            f.write(html_content)
```

## 7. 总结

本模块提供了完整的设备语义标准合规性检查解决方案，包括：

1. **多标准支持**：支持OPC UA、MQTT、CoAP等多种IoT标准
2. **规则引擎**：灵活的规则定义和验证机制
3. **兼容性检查**：跨标准兼容性评估
4. **自动化报告**：生成详细的合规性报告
5. **Rust实现**：提供高性能的Rust实现版本

该模块确保IoT设备符合相关行业标准和规范要求。
