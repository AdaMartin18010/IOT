# 语义一致性验证

## 1. 核心理论

```python
from typing import Dict, List, Optional, Any
from dataclasses import dataclass
from enum import Enum
import json

class ConsistencyType(Enum):
    STRUCTURAL = "structural"
    SEMANTIC = "semantic"
    TEMPORAL = "temporal"
    FUNCTIONAL = "functional"

@dataclass
class ConsistencyCheck:
    check_id: str
    check_type: ConsistencyType
    source_data: Dict[str, Any]
    target_data: Dict[str, Any]
    consistency_score: float
    errors: List[str]
    warnings: List[str]
```

## 2. 验证引擎

```python
class SemanticConsistencyValidator:
    def __init__(self):
        self.validators = {
            ConsistencyType.STRUCTURAL: self._validate_structural,
            ConsistencyType.SEMANTIC: self._validate_semantic,
            ConsistencyType.TEMPORAL: self._validate_temporal,
            ConsistencyType.FUNCTIONAL: self._validate_functional
        }
    
    def validate_consistency(self, source_data: Dict[str, Any], 
                           target_data: Dict[str, Any]) -> ConsistencyCheck:
        """验证语义一致性"""
        errors = []
        warnings = []
        total_score = 0.0
        
        for check_type in ConsistencyType:
            score = self.validators[check_type](source_data, target_data)
            total_score += score
            
        avg_score = total_score / len(ConsistencyType)
        
        return ConsistencyCheck(
            check_id=f"check_{hash(str(source_data))}",
            check_type=ConsistencyType.SEMANTIC,
            source_data=source_data,
            target_data=target_data,
            consistency_score=avg_score,
            errors=errors,
            warnings=warnings
        )
    
    def _validate_structural(self, source: Dict[str, Any], 
                           target: Dict[str, Any]) -> float:
        """验证结构一致性"""
        source_keys = set(source.keys())
        target_keys = set(target.keys())
        
        intersection = source_keys.intersection(target_keys)
        union = source_keys.union(target_keys)
        
        return len(intersection) / len(union) if union else 1.0
    
    def _validate_semantic(self, source: Dict[str, Any], 
                         target: Dict[str, Any]) -> float:
        """验证语义一致性"""
        # 检查值类型一致性
        type_consistency = 0.0
        common_keys = set(source.keys()).intersection(set(target.keys()))
        
        if common_keys:
            matching_types = sum(
                1 for key in common_keys 
                if type(source[key]) == type(target[key])
            )
            type_consistency = matching_types / len(common_keys)
        
        return type_consistency
    
    def _validate_temporal(self, source: Dict[str, Any], 
                         target: Dict[str, Any]) -> float:
        """验证时序一致性"""
        # 检查时间戳相关字段
        time_fields = ['timestamp', 'created_at', 'updated_at']
        consistent_time_fields = 0
        total_time_fields = 0
        
        for field in time_fields:
            if field in source and field in target:
                total_time_fields += 1
                # 简化：检查时间格式是否相似
                if str(source[field]).count(':') == str(target[field]).count(':'):
                    consistent_time_fields += 1
        
        return consistent_time_fields / total_time_fields if total_time_fields > 0 else 1.0
    
    def _validate_functional(self, source: Dict[str, Any], 
                           target: Dict[str, Any]) -> float:
        """验证功能一致性"""
        # 检查功能相关字段
        function_fields = ['capabilities', 'functions', 'operations']
        consistent_functions = 0
        total_functions = 0
        
        for field in function_fields:
            if field in source and field in target:
                total_functions += 1
                if source[field] == target[field]:
                    consistent_functions += 1
        
        return consistent_functions / total_functions if total_functions > 0 else 1.0
```

## 3. Rust实现

```rust
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ConsistencyType {
    Structural,
    Semantic,
    Temporal,
    Functional,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConsistencyCheck {
    pub check_id: String,
    pub check_type: ConsistencyType,
    pub consistency_score: f64,
    pub errors: Vec<String>,
    pub warnings: Vec<String>,
}

pub struct SemanticConsistencyValidator {
    // 验证器配置
}

impl SemanticConsistencyValidator {
    pub fn new() -> Self {
        Self {}
    }
    
    pub fn validate_consistency(
        &self,
        source_data: &HashMap<String, serde_json::Value>,
        target_data: &HashMap<String, serde_json::Value>,
    ) -> Result<ConsistencyCheck, String> {
        let structural_score = self.validate_structural(source_data, target_data)?;
        let semantic_score = self.validate_semantic(source_data, target_data)?;
        let temporal_score = self.validate_temporal(source_data, target_data)?;
        let functional_score = self.validate_functional(source_data, target_data)?;
        
        let avg_score = (structural_score + semantic_score + temporal_score + functional_score) / 4.0;
        
        Ok(ConsistencyCheck {
            check_id: uuid::Uuid::new_v4().to_string(),
            check_type: ConsistencyType::Semantic,
            consistency_score: avg_score,
            errors: vec![],
            warnings: vec![],
        })
    }
    
    fn validate_structural(
        &self,
        source: &HashMap<String, serde_json::Value>,
        target: &HashMap<String, serde_json::Value>,
    ) -> Result<f64, String> {
        let source_keys: std::collections::HashSet<_> = source.keys().collect();
        let target_keys: std::collections::HashSet<_> = target.keys().collect();
        
        let intersection_size = source_keys.intersection(&target_keys).count();
        let union_size = source_keys.union(&target_keys).count();
        
        Ok(if union_size > 0 {
            intersection_size as f64 / union_size as f64
        } else {
            1.0
        })
    }
    
    fn validate_semantic(
        &self,
        source: &HashMap<String, serde_json::Value>,
        target: &HashMap<String, serde_json::Value>,
    ) -> Result<f64, String> {
        // 实现语义验证逻辑
        Ok(0.9)
    }
    
    fn validate_temporal(
        &self,
        source: &HashMap<String, serde_json::Value>,
        target: &HashMap<String, serde_json::Value>,
    ) -> Result<f64, String> {
        // 实现时序验证逻辑
        Ok(0.85)
    }
    
    fn validate_functional(
        &self,
        source: &HashMap<String, serde_json::Value>,
        target: &HashMap<String, serde_json::Value>,
    ) -> Result<f64, String> {
        // 实现功能验证逻辑
        Ok(0.88)
    }
}
```

## 4. 测试用例

```python
import unittest

class TestSemanticConsistencyValidator(unittest.TestCase):
    def setUp(self):
        self.validator = SemanticConsistencyValidator()
    
    def test_structural_consistency(self):
        source = {"a": 1, "b": 2, "c": 3}
        target = {"a": 1, "b": 2, "d": 4}
        
        result = self.validator.validate_consistency(source, target)
        
        # 应该有部分一致性（2/4 = 0.5）
        self.assertGreater(result.consistency_score, 0.0)
        self.assertLess(result.consistency_score, 1.0)
    
    def test_perfect_consistency(self):
        data = {"temperature": 25.5, "humidity": 60}
        
        result = self.validator.validate_consistency(data, data)
        
        # 完全一致
        self.assertEqual(result.consistency_score, 1.0)
    
    def test_no_consistency(self):
        source = {"a": 1}
        target = {"b": 2}
        
        result = self.validator.validate_consistency(source, target)
        
        # 无一致性
        self.assertLess(result.consistency_score, 0.5)

if __name__ == '__main__':
    unittest.main()
```

## 5. 总结

本模块提供语义一致性验证功能，支持结构、语义、时序和功能四个维度的一致性检查。
