# 02 嵌入式与硬件抽象

## 6.1 硬件抽象层理论基础

### 6.1.1 硬件抽象定义

**定义 6.1.1** (硬件抽象层)
硬件抽象层(HAL)是位于硬件和操作系统之间的软件层，为上层应用提供统一的硬件接口，隐藏底层硬件的具体实现细节。

**定理 6.1.1** (硬件抽象的一致性)
对于任意硬件平台 $H_1$ 和 $H_2$，如果它们实现了相同的HAL接口 $I$，则上层应用 $A$ 可以在两个平台上无修改运行。

**证明**：
设应用 $A$ 通过接口 $I$ 访问硬件，由于 $H_1$ 和 $H_2$ 都实现了 $I$，因此 $A$ 的行为在两个平台上保持一致。

### 6.1.2 硬件抽象数学模型

设硬件平台集合为 $H = \{h_1, h_2, ..., h_n\}$，抽象接口集合为 $I = \{i_1, i_2, ..., i_m\}$，则HAL映射函数为：
$$f: H \times I \rightarrow \mathbb{R}$$

其中 $f(h, i)$ 表示在硬件 $h$ 上执行接口 $i$ 的性能指标。

## 6.2 Rust嵌入式HAL设计

### 6.2.1 embedded-hal核心接口

```rust
// embedded-hal核心trait定义
use embedded_hal::{
    digital::v2::{InputPin, OutputPin},
    adc::OneShot,
    i2c::I2c,
    spi::SpiDevice,
    timer::CountDown,
};

// GPIO抽象
pub trait GPIO {
    type Pin;
    type Error;
    
    fn configure_pin(&mut self, pin: Self::Pin, mode: PinMode) -> Result<(), Self::Error>;
    fn read_pin(&self, pin: Self::Pin) -> Result<PinState, Self::Error>;
    fn write_pin(&mut self, pin: Self::Pin, state: PinState) -> Result<(), Self::Error>;
}

// ADC抽象
pub trait ADC {
    type Channel;
    type Error;
    
    fn read_channel(&mut self, channel: Self::Channel) -> Result<u16, Self::Error>;
    fn read_voltage(&mut self, channel: Self::Channel) -> Result<f32, Self::Error>;
}

// I2C抽象
pub trait I2C {
    type Error;
    
    fn write(&mut self, address: u8, data: &[u8]) -> Result<(), Self::Error>;
    fn read(&mut self, address: u8, buffer: &mut [u8]) -> Result<(), Self::Error>;
    fn write_read(&mut self, address: u8, write_data: &[u8], read_buffer: &mut [u8]) -> Result<(), Self::Error>;
}

// SPI抽象
pub trait SPI {
    type Error;
    
    fn transfer(&mut self, data: &mut [u8]) -> Result<(), Self::Error>;
    fn transfer_in_place(&mut self, data: &mut [u8]) -> Result<(), Self::Error>;
}
```

### 6.2.2 具体硬件实现

```rust
// STM32F4xx HAL实现
use stm32f4xx_hal::{
    gpio::{GpioExt, Pin, PinMode},
    i2c::I2c,
    spi::Spi,
    adc::Adc,
    prelude::*,
};

pub struct STM32F4HAL {
    gpio: stm32f4xx_hal::gpio::Parts,
    i2c: I2c<stm32f4xx_hal::i2c::I2c1>,
    spi: Spi<stm32f4xx_hal::spi::Spi1>,
    adc: Adc<stm32f4xx_hal::adc::Adc1>,
}

impl GPIO for STM32F4HAL {
    type Pin = Pin<stm32f4xx_hal::gpio::Output<stm32f4xx_hal::gpio::PushPull>>;
    type Error = stm32f4xx_hal::gpio::Error;
    
    fn configure_pin(&mut self, pin: Self::Pin, mode: PinMode) -> Result<(), Self::Error> {
        match mode {
            PinMode::Input => {
                let _ = pin.into_floating_input();
            }
            PinMode::Output => {
                let _ = pin.into_push_pull_output();
            }
            PinMode::PWM => {
                let _ = pin.into_alternate();
            }
        }
        Ok(())
    }
    
    fn read_pin(&self, pin: Self::Pin) -> Result<PinState, Self::Error> {
        let state = pin.is_high().unwrap_or(false);
        Ok(if state { PinState::High } else { PinState::Low })
    }
    
    fn write_pin(&mut self, pin: Self::Pin, state: PinState) -> Result<(), Self::Error> {
        match state {
            PinState::High => pin.set_high().map_err(|_| Self::Error::InvalidPin),
            PinState::Low => pin.set_low().map_err(|_| Self::Error::InvalidPin),
        }
    }
}

impl I2C for STM32F4HAL {
    type Error = stm32f4xx_hal::i2c::Error;
    
    fn write(&mut self, address: u8, data: &[u8]) -> Result<(), Self::Error> {
        self.i2c.write(address, data)
    }
    
    fn read(&mut self, address: u8, buffer: &mut [u8]) -> Result<(), Self::Error> {
        self.i2c.read(address, buffer)
    }
    
    fn write_read(&mut self, address: u8, write_data: &[u8], read_buffer: &mut [u8]) -> Result<(), Self::Error> {
        self.i2c.write_read(address, write_data, read_buffer)
    }
}
```

## 6.3 传感器驱动设计

### 6.3.1 传感器抽象接口

```rust
// 传感器trait定义
pub trait Sensor {
    type Data;
    type Error;
    
    fn initialize(&mut self) -> Result<(), Self::Error>;
    fn read_data(&mut self) -> Result<Self::Data, Self::Error>;
    fn calibrate(&mut self) -> Result<(), Self::Error>;
    fn get_configuration(&self) -> SensorConfig;
}

// 温度传感器
pub trait TemperatureSensor: Sensor {
    fn read_temperature(&mut self) -> Result<f32, Self::Error>;
    fn read_humidity(&mut self) -> Result<f32, Self::Error>;
}

// 加速度传感器
pub trait Accelerometer: Sensor {
    fn read_acceleration(&mut self) -> Result<Acceleration, Self::Error>;
    fn read_gyroscope(&mut self) -> Result<Gyroscope, Self::Error>;
}

// 环境传感器
pub trait EnvironmentalSensor: Sensor {
    fn read_pressure(&mut self) -> Result<f32, Self::Error>;
    fn read_light(&mut self) -> Result<f32, Self::Error>;
    fn read_gas(&mut self) -> Result<f32, Self::Error>;
}
```

### 6.3.2 具体传感器实现

```rust
// DHT22温湿度传感器驱动
use dht_sensor::{dht22, Dht22};

pub struct DHT22Sensor<I2C> {
    sensor: Dht22<I2C>,
    last_reading: Option<DHT22Reading>,
    calibration_offset: f32,
}

impl<I2C> DHT22Sensor<I2C>
where
    I2C: embedded_hal::i2c::I2c,
{
    pub fn new(i2c: I2C) -> Self {
        Self {
            sensor: Dht22::new(i2c),
            last_reading: None,
            calibration_offset: 0.0,
        }
    }
}

impl<I2C> TemperatureSensor for DHT22Sensor<I2C>
where
    I2C: embedded_hal::i2c::I2c,
{
    type Data = DHT22Reading;
    type Error = SensorError;
    
    fn initialize(&mut self) -> Result<(), Self::Error> {
        // DHT22初始化
        Ok(())
    }
    
    fn read_temperature(&mut self) -> Result<f32, Self::Error> {
        let reading = self.read_data()?;
        Ok(reading.temperature + self.calibration_offset)
    }
    
    fn read_humidity(&mut self) -> Result<f32, Self::Error> {
        let reading = self.read_data()?;
        Ok(reading.humidity)
    }
    
    fn read_data(&mut self) -> Result<Self::Data, Self::Error> {
        match dht22::Reading::read(&mut self.sensor) {
            Ok(reading) => {
                let data = DHT22Reading {
                    temperature: reading.temperature,
                    humidity: reading.humidity,
                    timestamp: Utc::now(),
                };
                self.last_reading = Some(data.clone());
                Ok(data)
            }
            Err(e) => Err(SensorError::ReadFailed(e.to_string())),
        }
    }
    
    fn calibrate(&mut self) -> Result<(), Self::Error> {
        // 执行校准过程
        let mut readings = Vec::new();
        
        for _ in 0..10 {
            if let Ok(reading) = self.read_temperature() {
                readings.push(reading);
            }
            delay_ms(100);
        }
        
        if readings.len() >= 5 {
            let avg = readings.iter().sum::<f32>() / readings.len() as f32;
            self.calibration_offset = 25.0 - avg; // 假设标准温度为25°C
        }
        
        Ok(())
    }
    
    fn get_configuration(&self) -> SensorConfig {
        SensorConfig {
            sensor_type: SensorType::Temperature,
            sampling_rate: Duration::from_secs(2),
            accuracy: 0.5,
            range: SensorRange::new(-40.0, 80.0),
        }
    }
}

// BME280环境传感器驱动
pub struct BME280Sensor<I2C> {
    sensor: bme280::BME280<I2C>,
    config: BME280Config,
}

impl<I2C> BME280Sensor<I2C>
where
    I2C: embedded_hal::i2c::I2c,
{
    pub fn new(i2c: I2C) -> Result<Self, SensorError> {
        let mut sensor = bme280::BME280::new(i2c, 0x76);
        sensor.init()?;
        
        Ok(Self {
            sensor,
            config: BME280Config::default(),
        })
    }
}

impl<I2C> EnvironmentalSensor for BME280Sensor<I2C>
where
    I2C: embedded_hal::i2c::I2c,
{
    type Data = BME280Reading;
    type Error = SensorError;
    
    fn read_pressure(&mut self) -> Result<f32, Self::Error> {
        let measurement = self.sensor.measure()?;
        Ok(measurement.pressure)
    }
    
    fn read_light(&mut self) -> Result<f32, Self::Error> {
        // BME280不直接支持光照，返回默认值
        Ok(0.0)
    }
    
    fn read_gas(&mut self) -> Result<f32, Self::Error> {
        // BME280不直接支持气体，返回默认值
        Ok(0.0)
    }
    
    fn read_data(&mut self) -> Result<Self::Data, Self::Error> {
        let measurement = self.sensor.measure()?;
        
        Ok(BME280Reading {
            temperature: measurement.temperature,
            pressure: measurement.pressure,
            humidity: measurement.humidity,
            timestamp: Utc::now(),
        })
    }
}
```

## 6.4 执行器控制设计

### 6.4.1 执行器抽象接口

```rust
// 执行器trait定义
pub trait Actuator {
    type Command;
    type Error;
    
    fn initialize(&mut self) -> Result<(), Self::Error>;
    fn execute(&mut self, command: Self::Command) -> Result<(), Self::Error>;
    fn get_status(&self) -> ActuatorStatus;
    fn stop(&mut self) -> Result<(), Self::Error>;
}

// 电机控制
pub trait Motor: Actuator {
    fn set_speed(&mut self, speed: f32) -> Result<(), Self::Error>;
    fn set_direction(&mut self, direction: MotorDirection) -> Result<(), Self::Error>;
    fn get_current_speed(&self) -> f32;
    fn get_current_direction(&self) -> MotorDirection;
}

// 继电器控制
pub trait Relay: Actuator {
    fn turn_on(&mut self) -> Result<(), Self::Error>;
    fn turn_off(&mut self) -> Result<(), Self::Error>;
    fn toggle(&mut self) -> Result<(), Self::Error>;
    fn is_on(&self) -> bool;
}

// LED控制
pub trait LED: Actuator {
    fn set_brightness(&mut self, brightness: u8) -> Result<(), Self::Error>;
    fn set_color(&mut self, color: RGBColor) -> Result<(), Self::Error>;
    fn blink(&mut self, frequency: f32) -> Result<(), Self::Error>;
}
```

### 6.4.2 具体执行器实现

```rust
// PWM电机驱动
pub struct PWMMotor<PWM> {
    pwm: PWM,
    current_speed: f32,
    current_direction: MotorDirection,
    max_speed: f32,
}

impl<PWM> PWMMotor<PWM>
where
    PWM: embedded_hal::PwmPin<Duty = u16>,
{
    pub fn new(pwm: PWM, max_speed: f32) -> Self {
        Self {
            pwm,
            current_speed: 0.0,
            current_direction: MotorDirection::Forward,
            max_speed,
        }
    }
}

impl<PWM> Motor for PWMMotor<PWM>
where
    PWM: embedded_hal::PwmPin<Duty = u16>,
{
    type Command = MotorCommand;
    type Error = ActuatorError;
    
    fn initialize(&mut self) -> Result<(), Self::Error> {
        self.pwm.enable().map_err(|_| ActuatorError::InitializationFailed)?;
        self.set_speed(0.0)?;
        Ok(())
    }
    
    fn set_speed(&mut self, speed: f32) -> Result<(), Self::Error> {
        let clamped_speed = speed.clamp(-self.max_speed, self.max_speed);
        self.current_speed = clamped_speed;
        
        let duty_cycle = ((clamped_speed.abs() / self.max_speed) * 65535.0) as u16;
        self.pwm.set_duty(duty_cycle);
        
        if clamped_speed < 0.0 {
            self.current_direction = MotorDirection::Reverse;
        } else {
            self.current_direction = MotorDirection::Forward;
        }
        
        Ok(())
    }
    
    fn set_direction(&mut self, direction: MotorDirection) -> Result<(), Self::Error> {
        self.current_direction = direction;
        if direction == MotorDirection::Reverse {
            self.current_speed = -self.current_speed.abs();
        } else {
            self.current_speed = self.current_speed.abs();
        }
        self.set_speed(self.current_speed)
    }
    
    fn execute(&mut self, command: Self::Command) -> Result<(), Self::Error> {
        match command {
            MotorCommand::SetSpeed(speed) => self.set_speed(speed),
            MotorCommand::SetDirection(direction) => self.set_direction(direction),
            MotorCommand::Stop => self.stop(),
        }
    }
    
    fn get_status(&self) -> ActuatorStatus {
        ActuatorStatus {
            is_active: self.current_speed != 0.0,
            current_value: self.current_speed,
            error: None,
        }
    }
    
    fn stop(&mut self) -> Result<(), Self::Error> {
        self.set_speed(0.0)
    }
    
    fn get_current_speed(&self) -> f32 {
        self.current_speed
    }
    
    fn get_current_direction(&self) -> MotorDirection {
        self.current_direction
    }
}

// GPIO继电器驱动
pub struct GPIORelay<Pin> {
    pin: Pin,
    is_on: bool,
}

impl<Pin> GPIORelay<Pin>
where
    Pin: embedded_hal::digital::v2::OutputPin,
{
    pub fn new(pin: Pin) -> Self {
        Self { pin, is_on: false }
    }
}

impl<Pin> Relay for GPIORelay<Pin>
where
    Pin: embedded_hal::digital::v2::OutputPin,
{
    type Command = RelayCommand;
    type Error = ActuatorError;
    
    fn initialize(&mut self) -> Result<(), Self::Error> {
        self.turn_off()?;
        Ok(())
    }
    
    fn turn_on(&mut self) -> Result<(), Self::Error> {
        self.pin.set_high().map_err(|_| ActuatorError::CommandFailed)?;
        self.is_on = true;
        Ok(())
    }
    
    fn turn_off(&mut self) -> Result<(), Self::Error> {
        self.pin.set_low().map_err(|_| ActuatorError::CommandFailed)?;
        self.is_on = false;
        Ok(())
    }
    
    fn toggle(&mut self) -> Result<(), Self::Error> {
        if self.is_on {
            self.turn_off()
        } else {
            self.turn_on()
        }
    }
    
    fn execute(&mut self, command: Self::Command) -> Result<(), Self::Error> {
        match command {
            RelayCommand::TurnOn => self.turn_on(),
            RelayCommand::TurnOff => self.turn_off(),
            RelayCommand::Toggle => self.toggle(),
        }
    }
    
    fn get_status(&self) -> ActuatorStatus {
        ActuatorStatus {
            is_active: self.is_on,
            current_value: if self.is_on { 1.0 } else { 0.0 },
            error: None,
        }
    }
    
    fn stop(&mut self) -> Result<(), Self::Error> {
        self.turn_off()
    }
    
    fn is_on(&self) -> bool {
        self.is_on
    }
}
```

## 6.5 嵌入式系统设计

### 6.5.1 RTIC实时系统

```rust
// RTIC实时任务定义
use rtic::app;

#[app(device = stm32f4xx_hal::pac)]
mod app {
    use super::*;
    
    #[shared]
    struct Shared {
        sensor_data: SensorData,
        actuator_status: ActuatorStatus,
    }
    
    #[local]
    struct Local {
        temperature_sensor: DHT22Sensor<I2C1>,
        motor: PWMMotor<TIM2_CH1>,
        relay: GPIORelay<PA0>,
    }
    
    #[init]
    fn init(cx: init::Context) -> (Shared, Local, init::Monotonics) {
        // 初始化硬件
        let device = cx.device;
        let mut flash = device.FLASH.constrain();
        let mut rcc = device.RCC.constrain();
        
        let clocks = rcc.cfgr
            .sysclk(84.mhz())
            .freeze(&mut flash.acr);
        
        let mut gpioa = device.GPIOA.split(&mut rcc.ahb1);
        let mut gpiob = device.GPIOB.split(&mut rcc.ahb1);
        
        // 初始化I2C
        let scl = gpiob.pb6.into_alternate::<4>();
        let sda = gpiob.pb7.into_alternate::<4>();
        let i2c = I2c::new(device.I2C1, (scl, sda), 400.khz(), &clocks);
        
        // 初始化传感器和执行器
        let temperature_sensor = DHT22Sensor::new(i2c);
        let motor = PWMMotor::new(/* PWM配置 */);
        let relay = GPIORelay::new(gpioa.pa0.into_push_pull_output());
        
        // 启动定时任务
        sensor_task::spawn().unwrap();
        control_task::spawn().unwrap();
        
        (
            Shared {
                sensor_data: SensorData::default(),
                actuator_status: ActuatorStatus::default(),
            },
            Local {
                temperature_sensor,
                motor,
                relay,
            },
            init::Monotonics(),
        )
    }
    
    #[task(shared = [sensor_data], local = [temperature_sensor])]
    fn sensor_task(cx: sensor_task::Context) {
        if let Ok(reading) = cx.local.temperature_sensor.read_data() {
            cx.shared.sensor_data.lock(|data| {
                *data = reading;
            });
        }
        
        sensor_task::spawn_after(2.secs()).unwrap();
    }
    
    #[task(shared = [sensor_data, actuator_status], local = [motor, relay])]
    fn control_task(cx: control_task::Context) {
        let temperature = cx.shared.sensor_data.lock(|data| data.temperature);
        
        // 温度控制逻辑
        if temperature > 30.0 {
            // 温度过高，启动风扇
            let _ = cx.local.motor.set_speed(0.5);
            let _ = cx.local.relay.turn_on();
        } else if temperature < 20.0 {
            // 温度过低，关闭风扇
            let _ = cx.local.motor.set_speed(0.0);
            let _ = cx.local.relay.turn_off();
        }
        
        // 更新执行器状态
        cx.shared.actuator_status.lock(|status| {
            status.motor_speed = cx.local.motor.get_current_speed();
            status.relay_on = cx.local.relay.is_on();
        });
        
        control_task::spawn_after(1.secs()).unwrap();
    }
}
```

### 6.5.2 中断处理

```rust
// 中断处理器
pub struct InterruptHandler {
    gpio_interrupts: HashMap<u8, Box<dyn Fn() + Send + Sync>>,
    timer_interrupts: HashMap<u8, Box<dyn Fn() + Send + Sync>>,
}

impl InterruptHandler {
    pub fn new() -> Self {
        Self {
            gpio_interrupts: HashMap::new(),
            timer_interrupts: HashMap::new(),
        }
    }
    
    pub fn register_gpio_interrupt<F>(&mut self, pin: u8, handler: F)
    where
        F: Fn() + Send + Sync + 'static,
    {
        self.gpio_interrupts.insert(pin, Box::new(handler));
    }
    
    pub fn register_timer_interrupt<F>(&mut self, timer: u8, handler: F)
    where
        F: Fn() + Send + Sync + 'static,
    {
        self.timer_interrupts.insert(timer, Box::new(handler));
    }
    
    pub fn handle_gpio_interrupt(&self, pin: u8) {
        if let Some(handler) = self.gpio_interrupts.get(&pin) {
            handler();
        }
    }
    
    pub fn handle_timer_interrupt(&self, timer: u8) {
        if let Some(handler) = self.timer_interrupts.get(&timer) {
            handler();
        }
    }
}
```

## 6.6 电源管理

### 6.6.1 低功耗设计

```rust
// 电源管理器
pub struct PowerManager {
    current_mode: PowerMode,
    battery_level: f32,
    power_consumption: PowerConsumption,
}

impl PowerManager {
    pub fn new() -> Self {
        Self {
            current_mode: PowerMode::Normal,
            battery_level: 100.0,
            power_consumption: PowerConsumption::default(),
        }
    }
    
    pub fn enter_sleep_mode(&mut self) -> Result<(), PowerError> {
        self.current_mode = PowerMode::Sleep;
        
        // 关闭不必要的外设
        self.disable_unnecessary_peripherals()?;
        
        // 降低CPU频率
        self.reduce_cpu_frequency()?;
        
        // 进入低功耗模式
        self.enter_low_power_state()?;
        
        Ok(())
    }
    
    pub fn enter_deep_sleep_mode(&mut self) -> Result<(), PowerError> {
        self.current_mode = PowerMode::DeepSleep;
        
        // 保存关键数据
        self.save_critical_data()?;
        
        // 关闭所有外设
        self.disable_all_peripherals()?;
        
        // 进入深度睡眠
        self.enter_deep_sleep_state()?;
        
        Ok(())
    }
    
    pub fn wake_up(&mut self) -> Result<(), PowerError> {
        // 恢复CPU频率
        self.restore_cpu_frequency()?;
        
        // 重新初始化外设
        self.reinitialize_peripherals()?;
        
        // 恢复关键数据
        self.restore_critical_data()?;
        
        self.current_mode = PowerMode::Normal;
        Ok(())
    }
    
    pub fn monitor_battery(&mut self) -> f32 {
        // 读取电池电压
        let voltage = self.read_battery_voltage();
        
        // 转换为电量百分比
        self.battery_level = self.voltage_to_percentage(voltage);
        
        // 检查低电量警告
        if self.battery_level < 20.0 {
            self.trigger_low_battery_warning();
        }
        
        self.battery_level
    }
}
```

---

> 本文档详细描述了IOT系统的嵌入式与硬件抽象设计，包含HAL接口、传感器驱动、执行器控制和嵌入式系统设计。
