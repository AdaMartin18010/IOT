# 02 事件驱动与工作流

## 7.1 事件驱动架构理论基础

### 7.1.1 事件驱动定义

**定义 7.1.1** (事件驱动架构)
事件驱动架构是一种软件架构模式，其中系统组件通过事件进行通信，组件之间松耦合，事件的生产者和消费者相互独立。

**定理 7.1.1** (事件驱动解耦性)
在事件驱动架构中，事件生产者 $P$ 和事件消费者 $C$ 之间不存在直接依赖关系，即 $P \not\perp C$。

**证明**：
事件生产者通过事件总线发布事件，消费者通过订阅机制接收事件，两者不直接交互，因此不存在直接依赖关系。

### 7.1.2 事件驱动数学模型

设事件集合为 $E = \{e_1, e_2, ..., e_n\}$，生产者集合为 $P = \{p_1, p_2, ..., p_m\}$，消费者集合为 $C = \{c_1, c_2, ..., c_k\}$，则事件驱动关系可以表示为：
$$R: P \times E \times C \rightarrow \{0, 1\}$$

其中 $R(p, e, c) = 1$ 表示生产者 $p$ 发布的事件 $e$ 被消费者 $c$ 处理。

## 7.2 事件系统设计

### 7.2.1 事件定义

```rust
// 事件trait定义
pub trait Event: Send + Sync {
    fn event_type(&self) -> &str;
    fn timestamp(&self) -> DateTime<Utc>;
    fn source(&self) -> &str;
    fn priority(&self) -> EventPriority;
}

// 具体事件类型
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum IoTEvent {
    DeviceConnected(DeviceConnectedEvent),
    DeviceDisconnected(DeviceDisconnectedEvent),
    SensorDataReceived(SensorDataEvent),
    AlertTriggered(AlertEvent),
    CommandExecuted(CommandEvent),
    RuleTriggered(RuleEvent),
    SystemError(SystemErrorEvent),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceConnectedEvent {
    pub device_id: DeviceId,
    pub timestamp: DateTime<Utc>,
    pub connection_info: ConnectionInfo,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SensorDataEvent {
    pub device_id: DeviceId,
    pub sensor_type: String,
    pub value: f64,
    pub unit: String,
    pub timestamp: DateTime<Utc>,
    pub quality: DataQuality,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AlertEvent {
    pub alert_id: AlertId,
    pub device_id: DeviceId,
    pub alert_type: AlertType,
    pub severity: AlertSeverity,
    pub message: String,
    pub timestamp: DateTime<Utc>,
}

impl Event for IoTEvent {
    fn event_type(&self) -> &str {
        match self {
            IoTEvent::DeviceConnected(_) => "device.connected",
            IoTEvent::DeviceDisconnected(_) => "device.disconnected",
            IoTEvent::SensorDataReceived(_) => "sensor.data.received",
            IoTEvent::AlertTriggered(_) => "alert.triggered",
            IoTEvent::CommandExecuted(_) => "command.executed",
            IoTEvent::RuleTriggered(_) => "rule.triggered",
            IoTEvent::SystemError(_) => "system.error",
        }
    }
    
    fn timestamp(&self) -> DateTime<Utc> {
        match self {
            IoTEvent::DeviceConnected(e) => e.timestamp,
            IoTEvent::DeviceDisconnected(e) => e.timestamp,
            IoTEvent::SensorDataReceived(e) => e.timestamp,
            IoTEvent::AlertTriggered(e) => e.timestamp,
            IoTEvent::CommandExecuted(e) => e.timestamp,
            IoTEvent::RuleTriggered(e) => e.timestamp,
            IoTEvent::SystemError(e) => e.timestamp,
        }
    }
    
    fn source(&self) -> &str {
        match self {
            IoTEvent::DeviceConnected(e) => &e.device_id.0,
            IoTEvent::DeviceDisconnected(e) => &e.device_id.0,
            IoTEvent::SensorDataReceived(e) => &e.device_id.0,
            IoTEvent::AlertTriggered(e) => &e.device_id.0,
            IoTEvent::CommandExecuted(e) => &e.device_id.0,
            IoTEvent::RuleTriggered(e) => &e.rule_id.0,
            IoTEvent::SystemError(e) => &e.component,
        }
    }
    
    fn priority(&self) -> EventPriority {
        match self {
            IoTEvent::AlertTriggered(e) => match e.severity {
                AlertSeverity::Critical => EventPriority::High,
                AlertSeverity::High => EventPriority::High,
                AlertSeverity::Medium => EventPriority::Normal,
                AlertSeverity::Low => EventPriority::Low,
            },
            IoTEvent::SystemError(_) => EventPriority::High,
            _ => EventPriority::Normal,
        }
    }
}
```

### 7.2.2 事件总线实现

```rust
// 事件总线
pub struct EventBus {
    handlers: Arc<RwLock<HashMap<String, Vec<Box<dyn EventHandler>>>>>,
    event_queue: mpsc::Sender<IoTEvent>,
    metrics: Arc<EventMetrics>,
}

impl EventBus {
    pub fn new() -> Self {
        let (sender, receiver) = mpsc::channel(1000);
        
        let event_bus = Self {
            handlers: Arc::new(RwLock::new(HashMap::new())),
            event_queue: sender,
            metrics: Arc::new(EventMetrics::new()),
        };
        
        // 启动事件处理循环
        let handlers = event_bus.handlers.clone();
        let metrics = event_bus.metrics.clone();
        
        tokio::spawn(async move {
            event_bus.process_events(receiver, handlers, metrics).await;
        });
        
        event_bus
    }
    
    pub async fn publish(&self, event: IoTEvent) -> Result<(), EventError> {
        // 记录事件发布
        self.metrics.record_event_published(&event).await;
        
        // 发送到事件队列
        self.event_queue.send(event).await
            .map_err(|_| EventError::PublishFailed)
    }
    
    pub async fn subscribe<E: Event + 'static>(
        &self,
        event_type: &str,
        handler: Box<dyn EventHandler>,
    ) -> Result<(), EventError> {
        let mut handlers = self.handlers.write().await;
        handlers
            .entry(event_type.to_string())
            .or_insert_with(Vec::new)
            .push(handler);
        
        Ok(())
    }
    
    async fn process_events(
        &self,
        mut receiver: mpsc::Receiver<IoTEvent>,
        handlers: Arc<RwLock<HashMap<String, Vec<Box<dyn EventHandler>>>>>,
        metrics: Arc<EventMetrics>,
    ) {
        while let Some(event) = receiver.recv().await {
            let event_type = event.event_type();
            
            // 获取事件处理器
            let event_handlers = {
                let handlers = handlers.read().await;
                handlers.get(event_type).cloned().unwrap_or_default()
            };
            
            // 并发处理事件
            let mut tasks = Vec::new();
            for handler in event_handlers {
                let event_clone = event.clone();
                let metrics_clone = metrics.clone();
                
                let task = tokio::spawn(async move {
                    let start_time = Instant::now();
                    
                    match handler.handle(&event_clone).await {
                        Ok(_) => {
                            metrics_clone.record_event_processed(&event_clone, start_time.elapsed()).await;
                        }
                        Err(e) => {
                            metrics_clone.record_event_error(&event_clone, &e).await;
                        }
                    }
                });
                
                tasks.push(task);
            }
            
            // 等待所有处理器完成
            for task in tasks {
                let _ = task.await;
            }
        }
    }
}

// 事件处理器trait
pub trait EventHandler: Send + Sync {
    async fn handle(&self, event: &IoTEvent) -> Result<(), EventError>;
}

// 具体事件处理器
pub struct DeviceEventHandler {
    device_manager: Arc<DeviceManager>,
    logger: Arc<Logger>,
}

impl DeviceEventHandler {
    pub fn new(device_manager: Arc<DeviceManager>, logger: Arc<Logger>) -> Self {
        Self {
            device_manager,
            logger,
        }
    }
}

impl EventHandler for DeviceEventHandler {
    async fn handle(&self, event: &IoTEvent) -> Result<(), EventError> {
        match event {
            IoTEvent::DeviceConnected(connected_event) => {
                self.handle_device_connected(connected_event).await?;
            }
            IoTEvent::DeviceDisconnected(disconnected_event) => {
                self.handle_device_disconnected(disconnected_event).await?;
            }
            _ => {}
        }
        Ok(())
    }
}

impl DeviceEventHandler {
    async fn handle_device_connected(&self, event: &DeviceConnectedEvent) -> Result<(), EventError> {
        self.logger.info(&format!("Device {} connected", event.device_id.0));
        
        // 更新设备状态
        self.device_manager.update_device_status(
            &event.device_id,
            DeviceStatus::Online,
        ).await?;
        
        Ok(())
    }
    
    async fn handle_device_disconnected(&self, event: &DeviceDisconnectedEvent) -> Result<(), EventError> {
        self.logger.info(&format!("Device {} disconnected", event.device_id.0));
        
        // 更新设备状态
        self.device_manager.update_device_status(
            &event.device_id,
            DeviceStatus::Offline,
        ).await?;
        
        Ok(())
    }
}
```

## 7.3 工作流引擎设计

### 7.3.1 工作流定义

```rust
// 工作流定义
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Workflow {
    pub id: WorkflowId,
    pub name: String,
    pub description: String,
    pub steps: Vec<WorkflowStep>,
    pub triggers: Vec<WorkflowTrigger>,
    pub variables: HashMap<String, VariableDefinition>,
    pub timeout: Duration,
    pub retry_policy: RetryPolicy,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkflowStep {
    pub id: String,
    pub name: String,
    pub step_type: StepType,
    pub parameters: HashMap<String, Value>,
    pub conditions: Vec<Condition>,
    pub actions: Vec<Action>,
    pub timeout: Option<Duration>,
    pub retry_count: u32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StepType {
    DataProcessing,
    DeviceControl,
    RuleEvaluation,
    AlertGeneration,
    ExternalAPICall,
    DataTransformation,
    Decision,
    Wait,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkflowTrigger {
    pub trigger_type: TriggerType,
    pub conditions: Vec<Condition>,
    pub schedule: Option<Schedule>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum TriggerType {
    Event,
    Schedule,
    Manual,
    API,
}
```

### 7.3.2 工作流引擎实现

```rust
// 工作流引擎
pub struct WorkflowEngine {
    workflows: Arc<RwLock<HashMap<WorkflowId, Workflow>>>,
    executions: Arc<RwLock<HashMap<ExecutionId, WorkflowExecution>>>,
    step_executor: Arc<StepExecutor>,
    event_bus: Arc<EventBus>,
}

impl WorkflowEngine {
    pub fn new(step_executor: Arc<StepExecutor>, event_bus: Arc<EventBus>) -> Self {
        Self {
            workflows: Arc::new(RwLock::new(HashMap::new())),
            executions: Arc::new(RwLock::new(HashMap::new())),
            step_executor,
            event_bus,
        }
    }
    
    pub async fn register_workflow(&self, workflow: Workflow) -> Result<(), WorkflowError> {
        let mut workflows = self.workflows.write().await;
        workflows.insert(workflow.id.clone(), workflow);
        Ok(())
    }
    
    pub async fn start_workflow(&self, workflow_id: &WorkflowId, context: WorkflowContext) -> Result<ExecutionId, WorkflowError> {
        let workflow = {
            let workflows = self.workflows.read().await;
            workflows.get(workflow_id)
                .ok_or(WorkflowError::WorkflowNotFound)?
                .clone()
        };
        
        let execution_id = ExecutionId::generate();
        let execution = WorkflowExecution::new(execution_id.clone(), workflow, context);
        
        // 保存执行实例
        {
            let mut executions = self.executions.write().await;
            executions.insert(execution_id.clone(), execution);
        }
        
        // 启动工作流执行
        let step_executor = self.step_executor.clone();
        let executions = self.executions.clone();
        let event_bus = self.event_bus.clone();
        
        tokio::spawn(async move {
            Self::execute_workflow(execution_id, step_executor, executions, event_bus).await;
        });
        
        Ok(execution_id)
    }
    
    async fn execute_workflow(
        execution_id: ExecutionId,
        step_executor: Arc<StepExecutor>,
        executions: Arc<RwLock<HashMap<ExecutionId, WorkflowExecution>>>,
        event_bus: Arc<EventBus>,
    ) {
        let mut execution = {
            let mut executions = executions.write().await;
            executions.get_mut(&execution_id).unwrap().clone()
        };
        
        // 执行工作流步骤
        for step in &execution.workflow.steps {
            execution.current_step = Some(step.id.clone());
            execution.status = ExecutionStatus::Running;
            
            // 检查步骤条件
            if !Self::evaluate_conditions(&step.conditions, &execution.context).await {
                execution.status = ExecutionStatus::Skipped;
                continue;
            }
            
            // 执行步骤
            match step_executor.execute_step(step, &execution.context).await {
                Ok(result) => {
                    execution.context.variables.extend(result);
                    execution.completed_steps.push(step.id.clone());
                }
                Err(e) => {
                    execution.status = ExecutionStatus::Failed;
                    execution.error = Some(e.to_string());
                    break;
                }
            }
        }
        
        // 更新执行状态
        if execution.status != ExecutionStatus::Failed {
            execution.status = ExecutionStatus::Completed;
        }
        
        // 保存执行结果
        {
            let mut executions = executions.write().await;
            executions.insert(execution_id.clone(), execution.clone());
        }
        
        // 发布工作流完成事件
        let _ = event_bus.publish(IoTEvent::WorkflowCompleted(WorkflowCompletedEvent {
            execution_id: execution_id.clone(),
            workflow_id: execution.workflow.id.clone(),
            status: execution.status.clone(),
            timestamp: Utc::now(),
        })).await;
    }
    
    async fn evaluate_conditions(conditions: &[Condition], context: &WorkflowContext) -> bool {
        for condition in conditions {
            if !condition.evaluate(context).await {
                return false;
            }
        }
        true
    }
}

// 工作流执行实例
#[derive(Debug, Clone)]
pub struct WorkflowExecution {
    pub execution_id: ExecutionId,
    pub workflow: Workflow,
    pub context: WorkflowContext,
    pub status: ExecutionStatus,
    pub current_step: Option<String>,
    pub completed_steps: Vec<String>,
    pub error: Option<String>,
    pub start_time: DateTime<Utc>,
    pub end_time: Option<DateTime<Utc>>,
}

impl WorkflowExecution {
    pub fn new(execution_id: ExecutionId, workflow: Workflow, context: WorkflowContext) -> Self {
        Self {
            execution_id,
            workflow,
            context,
            status: ExecutionStatus::Pending,
            current_step: None,
            completed_steps: Vec::new(),
            error: None,
            start_time: Utc::now(),
            end_time: None,
        }
    }
}
```

### 7.3.3 步骤执行器

```rust
// 步骤执行器
pub struct StepExecutor {
    data_processor: Arc<DataProcessor>,
    device_controller: Arc<DeviceController>,
    rule_engine: Arc<RuleEngine>,
    alert_manager: Arc<AlertManager>,
    api_client: Arc<APIClient>,
}

impl StepExecutor {
    pub fn new(
        data_processor: Arc<DataProcessor>,
        device_controller: Arc<DeviceController>,
        rule_engine: Arc<RuleEngine>,
        alert_manager: Arc<AlertManager>,
        api_client: Arc<APIClient>,
    ) -> Self {
        Self {
            data_processor,
            device_controller,
            rule_engine,
            alert_manager,
            api_client,
        }
    }
    
    pub async fn execute_step(&self, step: &WorkflowStep, context: &WorkflowContext) -> Result<HashMap<String, Value>, StepError> {
        let mut result = HashMap::new();
        
        match &step.step_type {
            StepType::DataProcessing => {
                result = self.execute_data_processing(step, context).await?;
            }
            StepType::DeviceControl => {
                result = self.execute_device_control(step, context).await?;
            }
            StepType::RuleEvaluation => {
                result = self.execute_rule_evaluation(step, context).await?;
            }
            StepType::AlertGeneration => {
                result = self.execute_alert_generation(step, context).await?;
            }
            StepType::ExternalAPICall => {
                result = self.execute_api_call(step, context).await?;
            }
            StepType::DataTransformation => {
                result = self.execute_data_transformation(step, context).await?;
            }
            StepType::Decision => {
                result = self.execute_decision(step, context).await?;
            }
            StepType::Wait => {
                result = self.execute_wait(step, context).await?;
            }
        }
        
        Ok(result)
    }
    
    async fn execute_data_processing(&self, step: &WorkflowStep, context: &WorkflowContext) -> Result<HashMap<String, Value>, StepError> {
        let input_data = step.parameters.get("input_data")
            .ok_or(StepError::MissingParameter("input_data".to_string()))?;
        
        let processed_data = self.data_processor.process(input_data).await?;
        
        let mut result = HashMap::new();
        result.insert("processed_data".to_string(), serde_json::to_value(processed_data)?);
        
        Ok(result)
    }
    
    async fn execute_device_control(&self, step: &WorkflowStep, context: &WorkflowContext) -> Result<HashMap<String, Value>, StepError> {
        let device_id = step.parameters.get("device_id")
            .ok_or(StepError::MissingParameter("device_id".to_string()))?;
        let command = step.parameters.get("command")
            .ok_or(StepError::MissingParameter("command".to_string()))?;
        
        let result = self.device_controller.execute_command(device_id, command).await?;
        
        let mut response = HashMap::new();
        response.insert("command_result".to_string(), serde_json::to_value(result)?);
        
        Ok(response)
    }
    
    async fn execute_rule_evaluation(&self, step: &WorkflowStep, context: &WorkflowContext) -> Result<HashMap<String, Value>, StepError> {
        let rule_id = step.parameters.get("rule_id")
            .ok_or(StepError::MissingParameter("rule_id".to_string()))?;
        
        let evaluation_result = self.rule_engine.evaluate_rule(rule_id, context).await?;
        
        let mut result = HashMap::new();
        result.insert("rule_result".to_string(), serde_json::to_value(evaluation_result)?);
        
        Ok(result)
    }
    
    async fn execute_alert_generation(&self, step: &WorkflowStep, context: &WorkflowContext) -> Result<HashMap<String, Value>, StepError> {
        let alert_type = step.parameters.get("alert_type")
            .ok_or(StepError::MissingParameter("alert_type".to_string()))?;
        let message = step.parameters.get("message")
            .ok_or(StepError::MissingParameter("message".to_string()))?;
        
        let alert = self.alert_manager.create_alert(alert_type, message).await?;
        
        let mut result = HashMap::new();
        result.insert("alert_id".to_string(), serde_json::to_value(alert.id)?);
        
        Ok(result)
    }
}
```

## 7.4 状态机设计

### 7.4.1 状态机定义

```rust
// 状态机trait
pub trait StateMachine {
    type State;
    type Event;
    type Action;
    type Error;
    
    fn current_state(&self) -> &Self::State;
    fn transition(&mut self, event: Self::Event) -> Result<Vec<Self::Action>, Self::Error>;
    fn can_transition(&self, event: &Self::Event) -> bool;
}

// 设备状态机
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum DeviceState {
    Offline,
    Online,
    Maintenance,
    Error,
    Updating,
}

#[derive(Debug, Clone)]
pub enum DeviceEvent {
    Connect,
    Disconnect,
    StartMaintenance,
    EndMaintenance,
    Error,
    StartUpdate,
    UpdateComplete,
    UpdateFailed,
}

#[derive(Debug, Clone)]
pub enum DeviceAction {
    UpdateStatus,
    SendNotification,
    LogEvent,
    TriggerAlert,
}

pub struct DeviceStateMachine {
    current_state: DeviceState,
    device_id: DeviceId,
    state_history: Vec<(DeviceState, DateTime<Utc>)>,
}

impl DeviceStateMachine {
    pub fn new(device_id: DeviceId) -> Self {
        Self {
            current_state: DeviceState::Offline,
            device_id,
            state_history: Vec::new(),
        }
    }
    
    fn record_state_change(&mut self, new_state: DeviceState) {
        self.state_history.push((new_state.clone(), Utc::now()));
        self.current_state = new_state;
    }
}

impl StateMachine for DeviceStateMachine {
    type State = DeviceState;
    type Event = DeviceEvent;
    type Action = DeviceAction;
    type Error = StateMachineError;
    
    fn current_state(&self) -> &Self::State {
        &self.current_state
    }
    
    fn transition(&mut self, event: Self::Event) -> Result<Vec<Self::Action>, Self::Error> {
        let mut actions = Vec::new();
        
        match (&self.current_state, event) {
            (DeviceState::Offline, DeviceEvent::Connect) => {
                self.record_state_change(DeviceState::Online);
                actions.push(DeviceAction::UpdateStatus);
                actions.push(DeviceAction::LogEvent);
            }
            (DeviceState::Online, DeviceEvent::Disconnect) => {
                self.record_state_change(DeviceState::Offline);
                actions.push(DeviceAction::UpdateStatus);
                actions.push(DeviceAction::LogEvent);
            }
            (DeviceState::Online, DeviceEvent::StartMaintenance) => {
                self.record_state_change(DeviceState::Maintenance);
                actions.push(DeviceAction::UpdateStatus);
                actions.push(DeviceAction::SendNotification);
            }
            (DeviceState::Maintenance, DeviceEvent::EndMaintenance) => {
                self.record_state_change(DeviceState::Online);
                actions.push(DeviceAction::UpdateStatus);
                actions.push(DeviceAction::LogEvent);
            }
            (_, DeviceEvent::Error) => {
                self.record_state_change(DeviceState::Error);
                actions.push(DeviceAction::UpdateStatus);
                actions.push(DeviceAction::TriggerAlert);
            }
            (DeviceState::Online, DeviceEvent::StartUpdate) => {
                self.record_state_change(DeviceState::Updating);
                actions.push(DeviceAction::UpdateStatus);
                actions.push(DeviceAction::SendNotification);
            }
            (DeviceState::Updating, DeviceEvent::UpdateComplete) => {
                self.record_state_change(DeviceState::Online);
                actions.push(DeviceAction::UpdateStatus);
                actions.push(DeviceAction::LogEvent);
            }
            (DeviceState::Updating, DeviceEvent::UpdateFailed) => {
                self.record_state_change(DeviceState::Error);
                actions.push(DeviceAction::UpdateStatus);
                actions.push(DeviceAction::TriggerAlert);
            }
            _ => {
                return Err(StateMachineError::InvalidTransition {
                    from: self.current_state.clone(),
                    event: event,
                });
            }
        }
        
        Ok(actions)
    }
    
    fn can_transition(&self, event: &Self::Event) -> bool {
        match (&self.current_state, event) {
            (DeviceState::Offline, DeviceEvent::Connect) => true,
            (DeviceState::Online, DeviceEvent::Disconnect) => true,
            (DeviceState::Online, DeviceEvent::StartMaintenance) => true,
            (DeviceState::Maintenance, DeviceEvent::EndMaintenance) => true,
            (_, DeviceEvent::Error) => true,
            (DeviceState::Online, DeviceEvent::StartUpdate) => true,
            (DeviceState::Updating, DeviceEvent::UpdateComplete) => true,
            (DeviceState::Updating, DeviceEvent::UpdateFailed) => true,
            _ => false,
        }
    }
}
```

---

> 本文档详细描述了IOT系统的事件驱动与工作流设计，包含事件系统、工作流引擎和状态机实现。
