# Rust IoTæŠ€æœ¯æ ˆåˆ†æ

## ğŸ“‹ æ¨¡å—æ¦‚è§ˆ

**æ¨¡å—åç§°**: Rust IoTæŠ€æœ¯æ ˆ  
**æ¨¡å—ç¼–å·**: 09  
**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**æœ€åæ›´æ–°**: 2024-12-19  

## ğŸ¯ æ¨¡å—ç›®æ ‡

æœ¬æ¨¡å—åˆ†æRustè¯­è¨€åœ¨IoTé¢†åŸŸçš„åº”ç”¨ï¼ŒåŒ…æ‹¬ï¼š

1. **è¯­è¨€ç‰¹æ€§**: å†…å­˜å®‰å…¨ã€é›¶æˆæœ¬æŠ½è±¡ã€å¹¶å‘æ¨¡å‹
2. **ç”Ÿæ€ç³»ç»Ÿ**: åµŒå…¥å¼å¼€å‘ã€ç½‘ç»œç¼–ç¨‹ã€æ•°æ®å¤„ç†
3. **æ¶æ„æ¨¡å¼**: å¼‚æ­¥ç¼–ç¨‹ã€å¾®æœåŠ¡ã€äº‹ä»¶é©±åŠ¨
4. **æ€§èƒ½ä¼˜åŒ–**: å†…å­˜ç®¡ç†ã€å¹¶å‘æ§åˆ¶ã€èµ„æºä¼˜åŒ–
5. **å®‰å…¨æœºåˆ¶**: ç±»å‹å®‰å…¨ã€å†…å­˜å®‰å…¨ã€å¹¶å‘å®‰å…¨

## ğŸ“š æ–‡æ¡£ç»“æ„

### 1. è¯­è¨€åŸºç¡€

- [01_Rust_Language_Foundations](01_Rust_Language_Foundations.md) - Rustè¯­è¨€åŸºç¡€
- [02_Ownership_System](02_Ownership_System.md) - æ‰€æœ‰æƒç³»ç»Ÿ
- [03_Type_System](03_Type_System.md) - ç±»å‹ç³»ç»Ÿ
- [04_Concurrency_Model](04_Concurrency_Model.md) - å¹¶å‘æ¨¡å‹
- [05_Async_Await](05_Async_Await.md) - å¼‚æ­¥ç¼–ç¨‹

### 2. IoTä¸“ç”¨æŠ€æœ¯

- [06_Embedded_Development](06_Embedded_Development.md) - åµŒå…¥å¼å¼€å‘
- [07_Network_Programming](07_Network_Programming.md) - ç½‘ç»œç¼–ç¨‹
- [08_Data_Processing](08_Data_Processing.md) - æ•°æ®å¤„ç†
- [09_Device_Management](09_Device_Management.md) - è®¾å¤‡ç®¡ç†
- [10_Security_Implementation](10_Security_Implementation.md) - å®‰å…¨å®ç°

### 3. æ¶æ„å®ç°

- [11_Microservices_Architecture](11_Microservices_Architecture.md) - å¾®æœåŠ¡æ¶æ„
- [12_Event_Driven_Architecture](12_Event_Driven_Architecture.md) - äº‹ä»¶é©±åŠ¨æ¶æ„
- [13_Edge_Computing](13_Edge_Computing.md) - è¾¹ç¼˜è®¡ç®—
- [14_Cloud_Integration](14_Cloud_Integration.md) - äº‘ç«¯é›†æˆ
- [15_Performance_Optimization](15_Performance_Optimization.md) - æ€§èƒ½ä¼˜åŒ–

## ğŸ”— å¿«é€Ÿå¯¼èˆª

### æ ¸å¿ƒæ¦‚å¿µ

- [Rust IoTå¼€å‘æ¡†æ¶](01_Rust_Language_Foundations.md#rust-iotå¼€å‘æ¡†æ¶)
- [åµŒå…¥å¼ç³»ç»Ÿè®¾è®¡](06_Embedded_Development.md#åµŒå…¥å¼ç³»ç»Ÿè®¾è®¡)
- [å¼‚æ­¥ç½‘ç»œç¼–ç¨‹](07_Network_Programming.md#å¼‚æ­¥ç½‘ç»œç¼–ç¨‹)

### æŠ€æœ¯å®ç°

- [è®¾å¤‡ç®¡ç†æœåŠ¡](09_Device_Management.md#è®¾å¤‡ç®¡ç†æœåŠ¡)
- [å¾®æœåŠ¡æ¶æ„](11_Microservices_Architecture.md#å¾®æœåŠ¡æ¶æ„)
- [äº‹ä»¶é©±åŠ¨ç³»ç»Ÿ](12_Event_Driven_Architecture.md#äº‹ä»¶é©±åŠ¨ç³»ç»Ÿ)

## ğŸ“Š æŠ€æœ¯æ ˆæ¡†æ¶

### 1. Rust IoTæŠ€æœ¯æ ˆå±‚æ¬¡

```text
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    åº”ç”¨å±‚ (Application Layer)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ ä¸šåŠ¡é€»è¾‘    â”‚ â”‚ æ•°æ®åˆ†æ    â”‚ â”‚ ç”¨æˆ·ç•Œé¢    â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æœåŠ¡å±‚ (Service Layer)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ è®¾å¤‡ç®¡ç†    â”‚ â”‚ æ•°æ®å¤„ç†    â”‚ â”‚ å®‰å…¨æœåŠ¡    â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ¡†æ¶å±‚ (Framework Layer)                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   Tokio     â”‚ â”‚   Actix     â”‚ â”‚   Rocket    â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç³»ç»Ÿå±‚ (System Layer)                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  æ ‡å‡†åº“     â”‚ â”‚  åµŒå…¥å¼     â”‚ â”‚  ç½‘ç»œåº“     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç¡¬ä»¶å±‚ (Hardware Layer)                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   ä¼ æ„Ÿå™¨    â”‚ â”‚   æ‰§è¡Œå™¨    â”‚ â”‚   é€šä¿¡æ¨¡å—  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. æ ¸å¿ƒä¾èµ–é…ç½®

```toml
[dependencies]
# å¼‚æ­¥è¿è¡Œæ—¶
tokio = { version = "1.35", features = ["full"] }
async-std = "1.35"

# ç½‘ç»œé€šä¿¡
tokio-mqtt = "0.8"
rumqttc = "0.24"
coap = "0.3"
reqwest = { version = "0.11", features = ["json"] }

# åºåˆ—åŒ–
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
bincode = "1.3"

# æ•°æ®åº“
sqlx = { version = "0.7", features = ["sqlite", "runtime-tokio-rustls"] }
rusqlite = "0.29"
sled = "0.34"

# åŠ å¯†å’Œå®‰å…¨
ring = "0.17"
rustls = "0.21"
webpki-roots = "0.25"

# é…ç½®ç®¡ç†
config = "0.14"
toml = "0.8"

# æ—¥å¿—
tracing = "0.1"
tracing-subscriber = "0.3"
log = "0.4"

# ç¡¬ä»¶æŠ½è±¡
embedded-hal = "0.2"
cortex-m = "0.7"
cortex-m-rt = "0.7"

# ä¼ æ„Ÿå™¨æ”¯æŒ
embedded-sensors = "0.1"
dht-sensor = "0.1"

# æ—¶é—´å¤„ç†
chrono = { version = "0.4", features = ["serde"] }
time = "0.3"

# æ¶ˆæ¯é˜Ÿåˆ—
lapin = "2.3"
redis = { version = "0.24", features = ["tokio-comp"] }

# ç¼“å­˜
moka = "0.12"
```

## ğŸ¯ æ ¸å¿ƒç‰¹æ€§åˆ†æ

### 1. å†…å­˜å®‰å…¨

**ç‰¹æ€§**: Rustçš„æ‰€æœ‰æƒç³»ç»Ÿåœ¨ç¼–è¯‘æ—¶é˜²æ­¢å†…å­˜é”™è¯¯
**ä¼˜åŠ¿**:

- é˜²æ­¢ç©ºæŒ‡é’ˆè§£å¼•ç”¨
- é˜²æ­¢æ•°æ®ç«äº‰
- é˜²æ­¢å†…å­˜æ³„æ¼
- æ— éœ€åƒåœ¾æ”¶é›†å™¨

**IoTåº”ç”¨ä»·å€¼**:

```rust
// å®‰å…¨çš„è®¾å¤‡çŠ¶æ€ç®¡ç†
pub struct DeviceState {
    pub status: DeviceStatus,
    pub data: HashMap<String, f64>,
    pub last_update: DateTime<Utc>,
}

impl DeviceState {
    pub fn update_data(&mut self, key: String, value: f64) {
        // ç¼–è¯‘æ—¶ä¿è¯çº¿ç¨‹å®‰å…¨
        self.data.insert(key, value);
        self.last_update = Utc::now();
    }
    
    pub fn get_data(&self, key: &str) -> Option<&f64> {
        // å€Ÿç”¨æ£€æŸ¥ç¡®ä¿æ•°æ®å®‰å…¨
        self.data.get(key)
    }
}
```

### 2. é›¶æˆæœ¬æŠ½è±¡

**ç‰¹æ€§**: é«˜çº§æŠ½è±¡ä¸å¢åŠ è¿è¡Œæ—¶å¼€é”€
**ä¼˜åŠ¿**:

- æ€§èƒ½ä¸C/C++ç›¸å½“
- å†…å­˜ä½¿ç”¨æ•ˆç‡é«˜
- ç¼–è¯‘æ—¶ä¼˜åŒ–

**IoTåº”ç”¨ä»·å€¼**:

```rust
// é›¶æˆæœ¬çš„è®¾å¤‡æŠ½è±¡
pub trait Device {
    fn read_sensor(&self) -> Result<f64, DeviceError>;
    fn write_actuator(&mut self, value: f64) -> Result<(), DeviceError>;
}

// ç¼–è¯‘æ—¶å¤šæ€ï¼Œæ— è¿è¡Œæ—¶å¼€é”€
pub struct TemperatureSensor {
    address: u8,
    calibration: f64,
}

impl Device for TemperatureSensor {
    fn read_sensor(&self) -> Result<f64, DeviceError> {
        // ç›´æ¥ç¡¬ä»¶è®¿é—®ï¼Œæ— æŠ½è±¡å¼€é”€
        let raw_value = self.read_hardware_register(self.address)?;
        Ok(raw_value * self.calibration)
    }
    
    fn write_actuator(&mut self, _value: f64) -> Result<(), DeviceError> {
        Err(DeviceError::NotSupported)
    }
}
```

### 3. å¹¶å‘å®‰å…¨

**ç‰¹æ€§**: åŸºäºç±»å‹çš„å¹¶å‘å®‰å…¨ä¿è¯
**ä¼˜åŠ¿**:

- ç¼–è¯‘æ—¶é˜²æ­¢æ•°æ®ç«äº‰
- å®‰å…¨çš„å¼‚æ­¥ç¼–ç¨‹
- é«˜æ•ˆçš„å¹¶å‘æ§åˆ¶

**IoTåº”ç”¨ä»·å€¼**:

```rust
use tokio::sync::mpsc;
use std::sync::Arc;
use tokio::sync::RwLock;

// çº¿ç¨‹å®‰å…¨çš„è®¾å¤‡ç®¡ç†å™¨
pub struct DeviceManager {
    devices: Arc<RwLock<HashMap<String, DeviceState>>>,
    event_sender: mpsc::Sender<DeviceEvent>,
}

impl DeviceManager {
    pub async fn update_device_state(
        &self,
        device_id: String,
        new_state: DeviceState,
    ) -> Result<(), DeviceError> {
        // è¯»å†™é”ä¿è¯å¹¶å‘å®‰å…¨
        let mut devices = self.devices.write().await;
        devices.insert(device_id.clone(), new_state);
        
        // å¼‚æ­¥äº‹ä»¶å‘é€
        let event = DeviceEvent::StateChanged(device_id);
        self.event_sender.send(event).await
            .map_err(|_| DeviceError::EventSendFailed)?;
        
        Ok(())
    }
    
    pub async fn get_device_state(
        &self,
        device_id: &str,
    ) -> Option<DeviceState> {
        // åªè¯»è®¿é—®ï¼Œå…è®¸å¤šä¸ªå¹¶å‘è¯»å–
        let devices = self.devices.read().await;
        devices.get(device_id).cloned()
    }
}
```

## ğŸ”§ æ¶æ„æ¨¡å¼å®ç°

### 1. åˆ†å±‚æ¶æ„

```rust
// åº”ç”¨å±‚
pub mod application {
    use crate::services::device_service::DeviceService;
    use crate::services::data_service::DataService;
    
    pub struct IoTApplication {
        device_service: DeviceService,
        data_service: DataService,
    }
    
    impl IoTApplication {
        pub async fn process_sensor_data(&self, device_id: &str) -> Result<(), AppError> {
            // ä¸šåŠ¡é€»è¾‘å¤„ç†
            let data = self.device_service.read_sensor(device_id).await?;
            self.data_service.store_data(device_id, data).await?;
            Ok(())
        }
    }
}

// æœåŠ¡å±‚
pub mod services {
    use crate::protocols::mqtt::MqttClient;
    use crate::storage::database::Database;
    
    pub struct DeviceService {
        mqtt_client: MqttClient,
        database: Database,
    }
    
    impl DeviceService {
        pub async fn read_sensor(&self, device_id: &str) -> Result<SensorData, ServiceError> {
            // æœåŠ¡å±‚é€»è¾‘
            let data = self.mqtt_client.request_data(device_id).await?;
            Ok(data)
        }
    }
}

// åè®®å±‚
pub mod protocols {
    use rumqttc::{AsyncClient, MqttOptions};
    
    pub struct MqttClient {
        client: AsyncClient,
    }
    
    impl MqttClient {
        pub async fn request_data(&self, device_id: &str) -> Result<SensorData, ProtocolError> {
            // åè®®å±‚å®ç°
            let topic = format!("device/{}/sensor", device_id);
            let payload = self.client.get(topic).await?;
            Ok(SensorData::from_bytes(payload))
        }
    }
}
```

### 2. äº‹ä»¶é©±åŠ¨æ¶æ„

```rust
use tokio::sync::mpsc;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum IoTEvent {
    DeviceConnected(DeviceConnectedEvent),
    DeviceDisconnected(DeviceDisconnectedEvent),
    SensorDataReceived(SensorDataEvent),
    AlertTriggered(AlertEvent),
    CommandExecuted(CommandEvent),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeviceConnectedEvent {
    pub device_id: String,
    pub timestamp: DateTime<Utc>,
    pub capabilities: Vec<Capability>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SensorDataEvent {
    pub device_id: String,
    pub sensor_type: String,
    pub value: f64,
    pub timestamp: DateTime<Utc>,
}

// äº‹ä»¶å¤„ç†å™¨
pub trait EventHandler {
    async fn handle(&self, event: &IoTEvent) -> Result<(), EventError>;
}

// è®¾å¤‡è¿æ¥äº‹ä»¶å¤„ç†å™¨
pub struct DeviceConnectionHandler {
    device_manager: Arc<DeviceManager>,
}

impl EventHandler for DeviceConnectionHandler {
    async fn handle(&self, event: &IoTEvent) -> Result<(), EventError> {
        match event {
            IoTEvent::DeviceConnected(conn_event) => {
                self.device_manager.add_device(conn_event.device_id.clone()).await?;
                tracing::info!("Device {} connected", conn_event.device_id);
            }
            IoTEvent::DeviceDisconnected(disconn_event) => {
                self.device_manager.remove_device(&disconn_event.device_id).await?;
                tracing::info!("Device {} disconnected", disconn_event.device_id);
            }
            _ => {}
        }
        Ok(())
    }
}

// äº‹ä»¶æ€»çº¿
pub struct EventBus {
    handlers: HashMap<TypeId, Vec<Box<dyn EventHandler>>>,
    event_sender: mpsc::Sender<IoTEvent>,
    event_receiver: mpsc::Receiver<IoTEvent>,
}

impl EventBus {
    pub fn new() -> Self {
        let (event_sender, event_receiver) = mpsc::channel(1000);
        Self {
            handlers: HashMap::new(),
            event_sender,
            event_receiver,
        }
    }
    
    pub fn subscribe<T: 'static>(&mut self, handler: Box<dyn EventHandler>) {
        let type_id = TypeId::of::<T>();
        self.handlers.entry(type_id).or_insert_with(Vec::new).push(handler);
    }
    
    pub async fn publish(&self, event: IoTEvent) -> Result<(), EventError> {
        self.event_sender.send(event).await
            .map_err(|_| EventError::PublishFailed)
    }
    
    pub async fn run(&mut self) -> Result<(), EventError> {
        while let Some(event) = self.event_receiver.recv().await {
            let type_id = TypeId::of::<IoTEvent>();
            if let Some(handlers) = self.handlers.get(&type_id) {
                for handler in handlers {
                    handler.handle(&event).await?;
                }
            }
        }
        Ok(())
    }
}
```

### 3. å¾®æœåŠ¡æ¶æ„

```rust
use actix_web::{web, App, HttpServer, HttpResponse};
use serde::{Deserialize, Serialize};

// è®¾å¤‡ç®¡ç†å¾®æœåŠ¡
pub struct DeviceManagementService {
    device_repository: Arc<DeviceRepository>,
    event_bus: Arc<EventBus>,
}

#[derive(Deserialize)]
pub struct CreateDeviceRequest {
    pub device_id: String,
    pub device_type: DeviceType,
    pub capabilities: Vec<Capability>,
    pub location: Location,
}

#[derive(Serialize)]
pub struct DeviceResponse {
    pub device_id: String,
    pub status: DeviceStatus,
    pub last_seen: DateTime<Utc>,
}

impl DeviceManagementService {
    pub async fn create_device(
        &self,
        request: CreateDeviceRequest,
    ) -> Result<DeviceResponse, ServiceError> {
        // åˆ›å»ºè®¾å¤‡
        let device = Device::new(
            request.device_id,
            request.device_type,
            request.capabilities,
            request.location,
        );
        
        // ä¿å­˜åˆ°æ•°æ®åº“
        self.device_repository.save_device(&device).await?;
        
        // å‘å¸ƒäº‹ä»¶
        let event = IoTEvent::DeviceConnected(DeviceConnectedEvent {
            device_id: device.id.clone(),
            timestamp: Utc::now(),
            capabilities: device.capabilities.clone(),
        });
        self.event_bus.publish(event).await?;
        
        Ok(DeviceResponse {
            device_id: device.id,
            status: device.status,
            last_seen: device.last_seen,
        })
    }
    
    pub async fn get_device(&self, device_id: &str) -> Result<DeviceResponse, ServiceError> {
        let device = self.device_repository.find_device(device_id).await?;
        Ok(DeviceResponse {
            device_id: device.id,
            status: device.status,
            last_seen: device.last_seen,
        })
    }
    
    pub async fn update_device_status(
        &self,
        device_id: &str,
        status: DeviceStatus,
    ) -> Result<(), ServiceError> {
        self.device_repository.update_device_status(device_id, status).await?;
        
        let event = IoTEvent::DeviceStatusChanged(DeviceStatusChangedEvent {
            device_id: device_id.to_string(),
            status,
            timestamp: Utc::now(),
        });
        self.event_bus.publish(event).await?;
        
        Ok(())
    }
}

// HTTPè·¯ç”±
async fn create_device(
    service: web::Data<Arc<DeviceManagementService>>,
    request: web::Json<CreateDeviceRequest>,
) -> Result<HttpResponse, actix_web::Error> {
    let response = service.create_device(request.into_inner()).await
        .map_err(|e| actix_web::error::ErrorInternalServerError(e))?;
    Ok(HttpResponse::Ok().json(response))
}

async fn get_device(
    service: web::Data<Arc<DeviceManagementService>>,
    path: web::Path<String>,
) -> Result<HttpResponse, actix_web::Error> {
    let device_id = path.into_inner();
    let response = service.get_device(&device_id).await
        .map_err(|e| actix_web::error::ErrorInternalServerError(e))?;
    Ok(HttpResponse::Ok().json(response))
}

// æœåŠ¡å¯åŠ¨
#[actix_web::main]
async fn main() -> std::io::Result<()> {
    // åˆå§‹åŒ–æ—¥å¿—
    tracing_subscriber::fmt::init();
    
    // åˆ›å»ºæœåŠ¡å®ä¾‹
    let device_repository = Arc::new(DeviceRepository::new().await);
    let event_bus = Arc::new(EventBus::new());
    let service = Arc::new(DeviceManagementService {
        device_repository,
        event_bus,
    });
    
    // å¯åŠ¨HTTPæœåŠ¡å™¨
    HttpServer::new(move || {
        App::new()
            .app_data(web::Data::new(service.clone()))
            .route("/devices", web::post().to(create_device))
            .route("/devices/{device_id}", web::get().to(get_device))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}
```

## ğŸ“ˆ æ€§èƒ½åˆ†æ

### 1. å†…å­˜ä½¿ç”¨å¯¹æ¯”

| è¯­è¨€ | å†…å­˜ä½¿ç”¨ | åƒåœ¾æ”¶é›† | å†…å­˜å®‰å…¨ |
|------|----------|----------|----------|
| Rust | ä½ | æ—  | ç¼–è¯‘æ—¶ä¿è¯ |
| C/C++ | ä½ | æ—  | æ‰‹åŠ¨ç®¡ç† |
| Java | é«˜ | æœ‰ | è¿è¡Œæ—¶ä¿è¯ |
| Python | é«˜ | æœ‰ | è¿è¡Œæ—¶ä¿è¯ |

### 2. æ€§èƒ½åŸºå‡†æµ‹è¯•

```rust
use criterion::{criterion_group, criterion_main, Criterion};
use std::time::Instant;

// è®¾å¤‡æ•°æ®å¤„ç†æ€§èƒ½æµ‹è¯•
fn benchmark_device_data_processing(c: &mut Criterion) {
    let mut group = c.benchmark_group("device_data_processing");
    
    group.bench_function("rust_processing", |b| {
        b.iter(|| {
            let mut processor = DataProcessor::new();
            let data = generate_test_data(1000);
            processor.process_batch(data)
        });
    });
    
    group.finish();
}

// ç½‘ç»œé€šä¿¡æ€§èƒ½æµ‹è¯•
fn benchmark_network_communication(c: &mut Criterion) {
    let mut group = c.benchmark_group("network_communication");
    
    group.bench_function("mqtt_publish", |b| {
        b.iter(|| {
            let client = MqttClient::new();
            client.publish("test/topic", "test_message")
        });
    });
    
    group.finish();
}

criterion_group!(benches, benchmark_device_data_processing, benchmark_network_communication);
criterion_main!(benches);
```

### 3. èµ„æºæ¶ˆè€—åˆ†æ

```rust
// å†…å­˜ä½¿ç”¨ç›‘æ§
pub struct MemoryMonitor {
    initial_memory: usize,
    peak_memory: usize,
}

impl MemoryMonitor {
    pub fn new() -> Self {
        Self {
            initial_memory: Self::get_current_memory(),
            peak_memory: 0,
        }
    }
    
    pub fn update(&mut self) {
        let current = Self::get_current_memory();
        if current > self.peak_memory {
            self.peak_memory = current;
        }
    }
    
    pub fn get_usage(&self) -> usize {
        Self::get_current_memory() - self.initial_memory
    }
    
    pub fn get_peak_usage(&self) -> usize {
        self.peak_memory - self.initial_memory
    }
    
    fn get_current_memory() -> usize {
        // è·å–å½“å‰è¿›ç¨‹å†…å­˜ä½¿ç”¨
        std::process::id() as usize
    }
}

// CPUä½¿ç”¨ç›‘æ§
pub struct CpuMonitor {
    start_time: Instant,
    total_cycles: u64,
}

impl CpuMonitor {
    pub fn new() -> Self {
        Self {
            start_time: Instant::now(),
            total_cycles: 0,
        }
    }
    
    pub fn record_operation(&mut self, cycles: u64) {
        self.total_cycles += cycles;
    }
    
    pub fn get_average_cycles(&self) -> f64 {
        let elapsed = self.start_time.elapsed().as_secs_f64();
        self.total_cycles as f64 / elapsed
    }
}
```

## ğŸš€ æœ€ä½³å®è·µ

### 1. é”™è¯¯å¤„ç†

```rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum IoTError {
    #[error("è®¾å¤‡æœªæ‰¾åˆ°: {device_id}")]
    DeviceNotFound { device_id: String },
    
    #[error("ç½‘ç»œè¿æ¥å¤±è´¥: {reason}")]
    NetworkError { reason: String },
    
    #[error("æ•°æ®å¤„ç†é”™è¯¯: {message}")]
    DataProcessingError { message: String },
    
    #[error("é…ç½®é”™è¯¯: {field}")]
    ConfigurationError { field: String },
    
    #[error("æƒé™ä¸è¶³: {operation}")]
    PermissionDenied { operation: String },
}

// é”™è¯¯å¤„ç†å®
macro_rules! handle_iot_error {
    ($result:expr, $context:expr) => {
        $result.map_err(|e| IoTError::DataProcessingError {
            message: format!("{}: {}", $context, e),
        })
    };
}

// ä½¿ç”¨ç¤ºä¾‹
pub async fn process_device_data(device_id: &str) -> Result<(), IoTError> {
    let device = find_device(device_id)
        .ok_or_else(|| IoTError::DeviceNotFound {
            device_id: device_id.to_string(),
        })?;
    
    let data = device.read_sensor()
        .map_err(|e| IoTError::DataProcessingError {
            message: format!("è¯»å–ä¼ æ„Ÿå™¨å¤±è´¥: {}", e),
        })?;
    
    Ok(())
}
```

### 2. é…ç½®ç®¡ç†

```rust
use config::{Config, Environment, File};
use serde::Deserialize;

#[derive(Debug, Deserialize)]
pub struct IoTConfig {
    pub database: DatabaseConfig,
    pub network: NetworkConfig,
    pub security: SecurityConfig,
    pub logging: LoggingConfig,
}

#[derive(Debug, Deserialize)]
pub struct DatabaseConfig {
    pub url: String,
    pub max_connections: u32,
    pub timeout_seconds: u64,
}

#[derive(Debug, Deserialize)]
pub struct NetworkConfig {
    pub mqtt_broker: String,
    pub mqtt_port: u16,
    pub mqtt_username: Option<String>,
    pub mqtt_password: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct SecurityConfig {
    pub encryption_enabled: bool,
    pub certificate_path: Option<String>,
    pub private_key_path: Option<String>,
}

#[derive(Debug, Deserialize)]
pub struct LoggingConfig {
    pub level: String,
    pub file_path: Option<String>,
    pub max_files: usize,
}

impl IoTConfig {
    pub fn load() -> Result<Self, config::ConfigError> {
        let config = Config::builder()
            .add_source(File::with_name("config/default"))
            .add_source(File::with_name("config/local").required(false))
            .add_source(Environment::with_prefix("IOT"))
            .build()?;
        
        config.try_deserialize()
    }
}
```

### 3. æ—¥å¿—è®°å½•

```rust
use tracing::{info, warn, error, debug};
use tracing_subscriber::{layer::SubscriberExt, util::SubscriberInitExt};

// ç»“æ„åŒ–æ—¥å¿—
#[derive(Debug)]
pub struct DeviceLog {
    pub device_id: String,
    pub operation: String,
    pub timestamp: DateTime<Utc>,
    pub result: LogResult,
}

#[derive(Debug)]
pub enum LogResult {
    Success,
    Error(String),
    Warning(String),
}

// æ—¥å¿—è®°å½•å™¨
pub struct IoTLogger {
    device_id: String,
}

impl IoTLogger {
    pub fn new(device_id: String) -> Self {
        Self { device_id }
    }
    
    pub fn log_operation(&self, operation: &str, result: LogResult) {
        let log = DeviceLog {
            device_id: self.device_id.clone(),
            operation: operation.to_string(),
            timestamp: Utc::now(),
            result,
        };
        
        match &log.result {
            LogResult::Success => {
                info!(
                    device_id = %log.device_id,
                    operation = %log.operation,
                    "æ“ä½œæˆåŠŸ"
                );
            }
            LogResult::Error(msg) => {
                error!(
                    device_id = %log.device_id,
                    operation = %log.operation,
                    error = %msg,
                    "æ“ä½œå¤±è´¥"
                );
            }
            LogResult::Warning(msg) => {
                warn!(
                    device_id = %log.device_id,
                    operation = %log.operation,
                    warning = %msg,
                    "æ“ä½œè­¦å‘Š"
                );
            }
        }
    }
}

// åˆå§‹åŒ–æ—¥å¿—ç³»ç»Ÿ
pub fn init_logging(config: &LoggingConfig) -> Result<(), Box<dyn std::error::Error>> {
    let mut layers = Vec::new();
    
    // æ§åˆ¶å°è¾“å‡º
    let console_layer = tracing_subscriber::fmt::layer()
        .with_target(false)
        .with_thread_ids(true)
        .with_thread_names(true);
    layers.push(console_layer.boxed());
    
    // æ–‡ä»¶è¾“å‡º
    if let Some(file_path) = &config.file_path {
        let file_appender = tracing_appender::rolling::RollingFileAppender::new(
            tracing_appender::rolling::RollingFileAppender::builder()
                .rotation(tracing_appender::rolling::Rotation::DAILY)
                .filename_prefix("iot")
                .filename_suffix("log")
                .max_files(config.max_files)
                .build_in(file_path)?,
        );
        
        let file_layer = tracing_subscriber::fmt::layer()
            .with_ansi(false)
            .with_writer(file_appender);
        layers.push(file_layer.boxed());
    }
    
    tracing_subscriber::registry()
        .with(layers)
        .init();
    
    Ok(())
}
```

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. **Rustå®˜æ–¹æ–‡æ¡£**
   - [Rust Programming Language](https://doc.rust-lang.org/book/)
   - [Rust Reference](https://doc.rust-lang.org/reference/)
   - [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)

2. **IoTå¼€å‘æŒ‡å—**
   - [Rust Embedded Book](https://rust-embedded.github.io/book/)
   - [Embedded Rust on ESP](https://esp-rs.github.io/book/)
   - [Rust IoT Examples](https://github.com/rust-embedded/awesome-embedded-rust)

3. **å¼‚æ­¥ç¼–ç¨‹**
   - [Asynchronous Programming in Rust](https://rust-lang.github.io/async-book/)
   - [Tokio Documentation](https://tokio.rs/tokio/tutorial)
   - [Async Rust Patterns](https://rust-lang.github.io/async-book/patterns/)

4. **æ€§èƒ½ä¼˜åŒ–**
   - [Rust Performance Book](https://nnethercote.github.io/perf-book/)
   - [Rust Optimization Guide](https://github.com/rust-lang/rustc-dev-guide)
   - [Criterion.rs Documentation](https://bheisler.github.io/criterion.rs/book/)

---

*RustæŠ€æœ¯æ ˆä¸ºIoTç³»ç»Ÿæä¾›äº†é«˜æ€§èƒ½ã€é«˜å®‰å…¨æ€§çš„å¼€å‘å¹³å°ï¼Œæ˜¯ç°ä»£IoTæ¶æ„çš„ç†æƒ³é€‰æ‹©ã€‚*
